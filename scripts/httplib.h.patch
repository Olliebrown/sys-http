--- httplib.h.temp	2024-01-26 19:06:01.013616200 +0000
+++ httplib.h	2024-01-26 18:38:49.251682200 +0000
@@ -4,6 +4,8 @@
 //  Copyright (c) 2023 Yuji Hirose. All rights reserved.
 //  MIT License
 //
+// File taken from https://github.com/yhirose/cpp-httplib/blob/master/httplib.h
+// Modifications for Nintendo Switch made by zaksabeast and olliebrown
 
 #ifndef CPPHTTPLIB_HTTPLIB_H
 #define CPPHTTPLIB_HTTPLIB_H
@@ -168,7 +170,7 @@
 #else // not _WIN32
 
 #include <arpa/inet.h>
-#if !defined(_AIX) && !defined(__MVS__)
+#if !defined(_AIX) && !defined(__MVS__) && !defined(__SWITCH__)
 #include <ifaddrs.h>
 #endif
 #ifdef __MVS__
@@ -189,10 +191,12 @@
 #endif
 #include <csignal>
 #include <pthread.h>
+#if !defined(__SWITCH__)
 #include <sys/mman.h>
+#include <sys/un.h>
+#endif
 #include <sys/select.h>
 #include <sys/socket.h>
-#include <sys/un.h>
 #include <unistd.h>
 
 using socket_t = int;
@@ -2702,8 +2706,12 @@
   }
   size_ = static_cast<size_t>(sb.st_size);
 
+#if defined(__SWITCH__)
+  addr_ = nullptr;
+#else
   addr_ = ::mmap(NULL, size_, PROT_READ, MAP_PRIVATE, fd_, 0);
 #endif
+#endif
 
   if (addr_ == nullptr) {
     close();
@@ -2739,7 +2747,9 @@
   }
 #else
   if (addr_ != nullptr) {
+#if !defined(__SWITCH__)
     munmap(addr_, size_);
+#endif
     addr_ = nullptr;
   }
 
@@ -3219,7 +3229,7 @@
   return ret;
 }
 
-#if !defined _WIN32 && !defined ANDROID && !defined _AIX && !defined __MVS__
+#if !defined _WIN32 && !defined ANDROID && !defined _AIX && !defined __MVS__ && !defined __SWITCH__
 #define USE_IF2IP
 #endif
 
@@ -6272,19 +6282,28 @@
   auto se = detail::scope_exit([&]() { is_running_ = false; });
 
   {
+#if !defined(__SWITCH__)
     std::unique_ptr<TaskQueue> task_queue(new_task_queue());
+#endif
 
     while (svr_sock_ != INVALID_SOCKET) {
-#ifndef _WIN32
+#if !defined(_WIN32) && !defined(__SWITCH__)
       if (idle_interval_sec_ > 0 || idle_interval_usec_ > 0) {
 #endif
-        auto val = detail::select_read(svr_sock_, idle_interval_sec_,
-                                       idle_interval_usec_);
+
+#if defined(__SWITCH__)
+        auto val = detail::select_read(svr_sock_, 0, 100000);
+#else
+        auto val = detail::select_read(svr_sock_, idle_interval_sec_, idle_interval_usec_);
+#endif
+
         if (val == 0) { // Timeout
+#ifndef __SWITCH__
           task_queue->on_idle();
+#endif
           continue;
         }
-#ifndef _WIN32
+#if !defined(_WIN32) && !defined(__SWITCH__)
       }
 #endif
       socket_t sock = accept(svr_sock_, nullptr, nullptr);
@@ -6337,14 +6356,21 @@
 #endif
       }
 
-      if (!task_queue->enqueue(
-              [this, sock]() { process_and_close_socket(sock); })) {
+#if defined(__SWITCH__)
+      process_and_close_socket(sock);
+      detail::shutdown_socket(sock);
+      detail::close_socket(sock);
+#else
+      if (!task_queue->enqueue([this, sock]() { process_and_close_socket(sock); })) {
         detail::shutdown_socket(sock);
         detail::close_socket(sock);
       }
+#endif
     }
 
+#ifndef __SWITCH__
     task_queue->shutdown();
+#endif
   }
 
   return ret;

7,8d6
< // File taken from https://github.com/yhirose/cpp-httplib/blob/master/httplib.h
< // Modifications for Nintendo Switch made by zaksabeast
82,83c80,83
< #define CPPHTTPLIB_THREAD_POOL_COUNT \
<   ((std::max)(8u, std::thread::hardware_concurrency() > 0 ? std::thread::hardware_concurrency() - 1 : 0))
---
> #define CPPHTTPLIB_THREAD_POOL_COUNT                                           \
>   ((std::max)(8u, std::thread::hardware_concurrency() > 0                      \
>                       ? std::thread::hardware_concurrency() - 1                \
>                       : 0))
144c144
< #else  // not _WIN32
---
> #else // not _WIN32
148d147
< #ifndef __SWITCH__
150d148
< #endif
215,229c213
<   namespace detail {
< 
<     struct ci {
<       bool operator()(const std::string &s1, const std::string &s2) const {
<         return std::lexicographical_compare(s1.begin(), s1.end(), s2.begin(), s2.end(),
<                                             [](char c1, char c2) { return ::tolower(c1) < ::tolower(c2); });
<       }
<     };
< 
<   }  // namespace detail
< 
<   using Headers = std::multimap<std::string, std::string, detail::ci>;
< 
<   using Params = std::multimap<std::string, std::string>;
<   using Match = std::smatch;
---
> namespace detail {
231c215,221
<   using Progress = std::function<bool(uint64_t current, uint64_t total)>;
---
> struct ci {
>   bool operator()(const std::string &s1, const std::string &s2) const {
>     return std::lexicographical_compare(
>         s1.begin(), s1.end(), s2.begin(), s2.end(),
>         [](char c1, char c2) { return ::tolower(c1) < ::tolower(c2); });
>   }
> };
233,234c223
<   struct Response;
<   using ResponseHandler = std::function<bool(const Response &response)>;
---
> } // namespace detail
236,243c225
<   struct MultipartFormData {
<     std::string name;
<     std::string content;
<     std::string filename;
<     std::string content_type;
<   };
<   using MultipartFormDataItems = std::vector<MultipartFormData>;
<   using MultipartFormDataMap = std::multimap<std::string, MultipartFormData>;
---
> using Headers = std::multimap<std::string, std::string, detail::ci>;
245,268c227,228
<   class DataSink {
<    public:
<     DataSink() : os(&sb_), sb_(*this) {}
< 
<     DataSink(const DataSink &) = delete;
<     DataSink &operator=(const DataSink &) = delete;
<     DataSink(DataSink &&) = delete;
<     DataSink &operator=(DataSink &&) = delete;
< 
<     std::function<void(const char *data, size_t data_len)> write;
<     std::function<void()> done;
<     std::function<bool()> is_writable;
<     std::ostream os;
< 
<    private:
<     class data_sink_streambuf : public std::streambuf {
<      public:
<       data_sink_streambuf(DataSink &sink) : sink_(sink) {}
< 
<      protected:
<       std::streamsize xsputn(const char *s, std::streamsize n) {
<         sink_.write(s, static_cast<size_t>(n));
<         return n;
<       }
---
> using Params = std::multimap<std::string, std::string>;
> using Match = std::smatch;
270,272c230
<      private:
<       DataSink &sink_;
<     };
---
> using Progress = std::function<bool(uint64_t current, uint64_t total)>;
274,275c232,233
<     data_sink_streambuf sb_;
<   };
---
> struct Response;
> using ResponseHandler = std::function<bool(const Response &response)>;
277c235,242
<   using ContentProvider = std::function<bool(size_t offset, size_t length, DataSink &sink)>;
---
> struct MultipartFormData {
>   std::string name;
>   std::string content;
>   std::string filename;
>   std::string content_type;
> };
> using MultipartFormDataItems = std::vector<MultipartFormData>;
> using MultipartFormDataMap = std::multimap<std::string, MultipartFormData>;
279c244,246
<   using ChunkedContentProvider = std::function<bool(size_t offset, DataSink &sink)>;
---
> class DataSink {
> public:
>   DataSink() : os(&sb_), sb_(*this) {}
281c248,251
<   using ContentReceiver = std::function<bool(const char *data, size_t data_length)>;
---
>   DataSink(const DataSink &) = delete;
>   DataSink &operator=(const DataSink &) = delete;
>   DataSink(DataSink &&) = delete;
>   DataSink &operator=(DataSink &&) = delete;
283c253,256
<   using MultipartContentHeader = std::function<bool(const MultipartFormData &file)>;
---
>   std::function<void(const char *data, size_t data_len)> write;
>   std::function<void()> done;
>   std::function<bool()> is_writable;
>   std::ostream os;
285,288c258,261
<   class ContentReader {
<    public:
<     using Reader = std::function<bool(ContentReceiver receiver)>;
<     using MultipartReader = std::function<bool(MultipartContentHeader header, ContentReceiver receiver)>;
---
> private:
>   class data_sink_streambuf : public std::streambuf {
>   public:
>     data_sink_streambuf(DataSink &sink) : sink_(sink) {}
290c263,267
<     ContentReader(Reader reader, MultipartReader multipart_reader) : reader_(reader), multipart_reader_(multipart_reader) {}
---
>   protected:
>     std::streamsize xsputn(const char *s, std::streamsize n) {
>       sink_.write(s, static_cast<size_t>(n));
>       return n;
>     }
292c269,271
<     bool operator()(MultipartContentHeader header, ContentReceiver receiver) const { return multipart_reader_(header, receiver); }
---
>   private:
>     DataSink &sink_;
>   };
294c273,274
<     bool operator()(ContentReceiver receiver) const { return reader_(receiver); }
---
>   data_sink_streambuf sb_;
> };
296,298c276,277
<     Reader reader_;
<     MultipartReader multipart_reader_;
<   };
---
> using ContentProvider =
>     std::function<bool(size_t offset, size_t length, DataSink &sink)>;
300,301c279,280
<   using Range = std::pair<ssize_t, ssize_t>;
<   using Ranges = std::vector<Range>;
---
> using ChunkedContentProvider =
>     std::function<bool(size_t offset, DataSink &sink)>;
303,326c282,334
<   struct Request {
<     std::string method;
<     std::string path;
<     Headers headers;
<     std::string body;
< 
<     std::string remote_addr;
<     int remote_port = -1;
< 
<     // for server
<     std::string version;
<     std::string target;
<     Params params;
<     MultipartFormDataMap files;
<     Ranges ranges;
<     Match matches;
< 
<     // for client
<     size_t redirect_count = CPPHTTPLIB_REDIRECT_MAX_COUNT;
<     ResponseHandler response_handler;
<     ContentReceiver content_receiver;
<     size_t content_length = 0;
<     ContentProvider content_provider;
<     Progress progress;
---
> using ContentReceiver =
>     std::function<bool(const char *data, size_t data_length)>;
> 
> using MultipartContentHeader =
>     std::function<bool(const MultipartFormData &file)>;
> 
> class ContentReader {
> public:
>   using Reader = std::function<bool(ContentReceiver receiver)>;
>   using MultipartReader = std::function<bool(MultipartContentHeader header,
>                                              ContentReceiver receiver)>;
> 
>   ContentReader(Reader reader, MultipartReader multipart_reader)
>       : reader_(reader), multipart_reader_(multipart_reader) {}
> 
>   bool operator()(MultipartContentHeader header,
>                   ContentReceiver receiver) const {
>     return multipart_reader_(header, receiver);
>   }
> 
>   bool operator()(ContentReceiver receiver) const { return reader_(receiver); }
> 
>   Reader reader_;
>   MultipartReader multipart_reader_;
> };
> 
> using Range = std::pair<ssize_t, ssize_t>;
> using Ranges = std::vector<Range>;
> 
> struct Request {
>   std::string method;
>   std::string path;
>   Headers headers;
>   std::string body;
> 
>   std::string remote_addr;
>   int remote_port = -1;
> 
>   // for server
>   std::string version;
>   std::string target;
>   Params params;
>   MultipartFormDataMap files;
>   Ranges ranges;
>   Match matches;
> 
>   // for client
>   size_t redirect_count = CPPHTTPLIB_REDIRECT_MAX_COUNT;
>   ResponseHandler response_handler;
>   ContentReceiver content_receiver;
>   size_t content_length = 0;
>   ContentProvider content_provider;
>   Progress progress;
329c337
<     const SSL *ssl;
---
>   const SSL *ssl;
332,336c340,409
<     bool has_header(const char *key) const;
<     std::string get_header_value(const char *key, size_t id = 0) const;
<     size_t get_header_value_count(const char *key) const;
<     void set_header(const char *key, const char *val);
<     void set_header(const char *key, const std::string &val);
---
>   bool has_header(const char *key) const;
>   std::string get_header_value(const char *key, size_t id = 0) const;
>   size_t get_header_value_count(const char *key) const;
>   void set_header(const char *key, const char *val);
>   void set_header(const char *key, const std::string &val);
> 
>   bool has_param(const char *key) const;
>   std::string get_param_value(const char *key, size_t id = 0) const;
>   size_t get_param_value_count(const char *key) const;
> 
>   bool is_multipart_form_data() const;
> 
>   bool has_file(const char *key) const;
>   MultipartFormData get_file_value(const char *key) const;
> 
>   // private members...
>   size_t authorization_count_ = 0;
> };
> 
> struct Response {
>   std::string version;
>   int status = -1;
>   Headers headers;
>   std::string body;
> 
>   bool has_header(const char *key) const;
>   std::string get_header_value(const char *key, size_t id = 0) const;
>   size_t get_header_value_count(const char *key) const;
>   void set_header(const char *key, const char *val);
>   void set_header(const char *key, const std::string &val);
> 
>   void set_redirect(const char *url, int status = 302);
>   void set_content(const char *s, size_t n, const char *content_type);
>   void set_content(std::string s, const char *content_type);
> 
>   void set_content_provider(
>       size_t length, ContentProvider provider,
>       std::function<void()> resource_releaser = [] {});
> 
>   void set_chunked_content_provider(
>       ChunkedContentProvider provider,
>       std::function<void()> resource_releaser = [] {});
> 
>   Response() = default;
>   Response(const Response &) = default;
>   Response &operator=(const Response &) = default;
>   Response(Response &&) = default;
>   Response &operator=(Response &&) = default;
>   ~Response() {
>     if (content_provider_resource_releaser_) {
>       content_provider_resource_releaser_();
>     }
>   }
> 
>   // private members...
>   size_t content_length_ = 0;
>   ContentProvider content_provider_;
>   std::function<void()> content_provider_resource_releaser_;
> };
> 
> class Stream {
> public:
>   virtual ~Stream() = default;
> 
>   virtual bool is_readable() const = 0;
>   virtual bool is_writable() const = 0;
> 
>   virtual ssize_t read(char *ptr, size_t size) = 0;
>   virtual ssize_t write(const char *ptr, size_t size) = 0;
>   virtual void get_remote_ip_and_port(std::string &ip, int &port) const = 0;
338,340c411,415
<     bool has_param(const char *key) const;
<     std::string get_param_value(const char *key, size_t id = 0) const;
<     size_t get_param_value_count(const char *key) const;
---
>   template <typename... Args>
>   ssize_t write_format(const char *fmt, const Args &... args);
>   ssize_t write(const char *ptr);
>   ssize_t write(const std::string &s);
> };
342c417,420
<     bool is_multipart_form_data() const;
---
> class TaskQueue {
> public:
>   TaskQueue() = default;
>   virtual ~TaskQueue() = default;
344,345c422,423
<     bool has_file(const char *key) const;
<     MultipartFormData get_file_value(const char *key) const;
---
>   virtual void enqueue(std::function<void()> fn) = 0;
>   virtual void shutdown() = 0;
347,349c425,426
<     // private members...
<     size_t authorization_count_ = 0;
<   };
---
>   virtual void on_idle(){};
> };
351,381c428,433
<   struct Response {
<     std::string version;
<     int status = -1;
<     Headers headers;
<     std::string body;
< 
<     bool has_header(const char *key) const;
<     std::string get_header_value(const char *key, size_t id = 0) const;
<     size_t get_header_value_count(const char *key) const;
<     void set_header(const char *key, const char *val);
<     void set_header(const char *key, const std::string &val);
< 
<     void set_redirect(const char *url, int status = 302);
<     void set_content(const char *s, size_t n, const char *content_type);
<     void set_content(std::string s, const char *content_type);
< 
<     void set_content_provider(
<         size_t length, ContentProvider provider, std::function<void()> resource_releaser = [] {});
< 
<     void set_chunked_content_provider(
<         ChunkedContentProvider provider, std::function<void()> resource_releaser = [] {});
< 
<     Response() = default;
<     Response(const Response &) = default;
<     Response &operator=(const Response &) = default;
<     Response(Response &&) = default;
<     Response &operator=(Response &&) = default;
<     ~Response() {
<       if (content_provider_resource_releaser_) {
<         content_provider_resource_releaser_();
<       }
---
> class ThreadPool : public TaskQueue {
> public:
>   explicit ThreadPool(size_t n) : shutdown_(false) {
>     while (n) {
>       threads_.emplace_back(worker(*this));
>       n--;
382a435
>   }
384,425c437,438
<     // private members...
<     size_t content_length_ = 0;
<     ContentProvider content_provider_;
<     std::function<void()> content_provider_resource_releaser_;
<   };
< 
<   class Stream {
<    public:
<     virtual ~Stream() = default;
< 
<     virtual bool is_readable() const = 0;
<     virtual bool is_writable() const = 0;
< 
<     virtual ssize_t read(char *ptr, size_t size) = 0;
<     virtual ssize_t write(const char *ptr, size_t size) = 0;
<     virtual void get_remote_ip_and_port(std::string &ip, int &port) const = 0;
< 
<     template <typename... Args>
<     ssize_t write_format(const char *fmt, const Args &... args);
<     ssize_t write(const char *ptr);
<     ssize_t write(const std::string &s);
<   };
< 
<   class TaskQueue {
<    public:
<     TaskQueue() = default;
<     virtual ~TaskQueue() = default;
< 
<     virtual void enqueue(std::function<void()> fn) = 0;
<     virtual void shutdown() = 0;
< 
<     virtual void on_idle() {};
<   };
< 
<   class ThreadPool : public TaskQueue {
<    public:
<     explicit ThreadPool(size_t n) : shutdown_(false) {
<       while (n) {
<         threads_.emplace_back(worker(*this));
<         n--;
<       }
<     }
---
>   ThreadPool(const ThreadPool &) = delete;
>   ~ThreadPool() override = default;
427,428c440,444
<     ThreadPool(const ThreadPool &) = delete;
<     ~ThreadPool() override = default;
---
>   void enqueue(std::function<void()> fn) override {
>     std::unique_lock<std::mutex> lock(mutex_);
>     jobs_.push_back(fn);
>     cond_.notify_one();
>   }
430c446,448
<     void enqueue(std::function<void()> fn) override {
---
>   void shutdown() override {
>     // Stop all worker threads...
>     {
432,433c450
<       jobs_.push_back(fn);
<       cond_.notify_one();
---
>       shutdown_ = true;
436,443c453
<     void shutdown() override {
<       // Stop all worker threads...
<       {
<         std::unique_lock<std::mutex> lock(mutex_);
<         shutdown_ = true;
<       }
< 
<       cond_.notify_all();
---
>     cond_.notify_all();
445,448c455,457
<       // Join...
<       for (auto &t : threads_) {
<         t.join();
<       }
---
>     // Join...
>     for (auto &t : threads_) {
>       t.join();
449a459
>   }
451,453c461,463
<    private:
<     struct worker {
<       explicit worker(ThreadPool &pool) : pool_(pool) {}
---
> private:
>   struct worker {
>     explicit worker(ThreadPool &pool) : pool_(pool) {}
455,459c465,469
<       void operator()() {
<         for (;;) {
<           std::function<void()> fn;
<           {
<             std::unique_lock<std::mutex> lock(pool_.mutex_);
---
>     void operator()() {
>       for (;;) {
>         std::function<void()> fn;
>         {
>           std::unique_lock<std::mutex> lock(pool_.mutex_);
461c471,472
<             pool_.cond_.wait(lock, [&] { return !pool_.jobs_.empty() || pool_.shutdown_; });
---
>           pool_.cond_.wait(
>               lock, [&] { return !pool_.jobs_.empty() || pool_.shutdown_; });
463,465c474
<             if (pool_.shutdown_ && pool_.jobs_.empty()) {
<               break;
<             }
---
>           if (pool_.shutdown_ && pool_.jobs_.empty()) { break; }
467,472c476,477
<             fn = pool_.jobs_.front();
<             pool_.jobs_.pop_front();
<           }
< 
<           assert(true == static_cast<bool>(fn));
<           fn();
---
>           fn = pool_.jobs_.front();
>           pool_.jobs_.pop_front();
474,481d478
<       }
< 
<       ThreadPool &pool_;
<     };
<     friend struct worker;
< 
<     std::vector<std::thread> threads_;
<     std::list<std::function<void()>> jobs_;
483,489c480,483
<     bool shutdown_;
< 
<     std::condition_variable cond_;
<     std::mutex mutex_;
<   };
< 
<   using Logger = std::function<void(const Request &, const Response &)>;
---
>         assert(true == static_cast<bool>(fn));
>         fn();
>       }
>     }
491,599c485
<   class Server {
<    public:
<     using Handler = std::function<void(const Request &, Response &)>;
<     using HandlerWithContentReader = std::function<void(const Request &, Response &, const ContentReader &content_reader)>;
<     using Expect100ContinueHandler = std::function<int(const Request &, Response &)>;
< 
<     Server();
< 
<     virtual ~Server();
< 
<     virtual bool is_valid() const;
< 
<     Server &Get(const char *pattern, Handler handler);
<     Server &Post(const char *pattern, Handler handler);
<     Server &Post(const char *pattern, HandlerWithContentReader handler);
<     Server &Put(const char *pattern, Handler handler);
<     Server &Put(const char *pattern, HandlerWithContentReader handler);
<     Server &Patch(const char *pattern, Handler handler);
<     Server &Patch(const char *pattern, HandlerWithContentReader handler);
<     Server &Delete(const char *pattern, Handler handler);
<     Server &Delete(const char *pattern, HandlerWithContentReader handler);
<     Server &Options(const char *pattern, Handler handler);
< 
<     [[deprecated]] bool set_base_dir(const char *dir, const char *mount_point = nullptr);
<     bool set_mount_point(const char *mount_point, const char *dir);
<     bool remove_mount_point(const char *mount_point);
<     void set_file_extension_and_mimetype_mapping(const char *ext, const char *mime);
<     void set_file_request_handler(Handler handler);
< 
<     void set_error_handler(Handler handler);
<     void set_logger(Logger logger);
< 
<     void set_expect_100_continue_handler(Expect100ContinueHandler handler);
< 
<     void set_keep_alive_max_count(size_t count);
<     void set_read_timeout(time_t sec, time_t usec = 0);
<     void set_write_timeout(time_t sec, time_t usec = 0);
<     void set_idle_interval(time_t sec, time_t usec = 0);
< 
<     void set_payload_max_length(size_t length);
< 
<     bool bind_to_port(const char *host, int port, int socket_flags = 0);
<     int bind_to_any_port(const char *host, int socket_flags = 0);
<     bool listen_after_bind();
< 
<     bool listen(const char *host, int port, int socket_flags = 0);
< 
<     bool is_running() const;
<     void stop();
< 
<     std::function<TaskQueue *(void)> new_task_queue;
< 
<    protected:
<     bool process_request(Stream &strm, bool last_connection, bool &connection_close,
<                          const std::function<void(Request &)> &setup_request);
< 
<     size_t keep_alive_max_count_ = CPPHTTPLIB_KEEPALIVE_MAX_COUNT;
<     time_t read_timeout_sec_ = CPPHTTPLIB_READ_TIMEOUT_SECOND;
<     time_t read_timeout_usec_ = CPPHTTPLIB_READ_TIMEOUT_USECOND;
<     time_t write_timeout_sec_ = CPPHTTPLIB_WRITE_TIMEOUT_SECOND;
<     time_t write_timeout_usec_ = CPPHTTPLIB_WRITE_TIMEOUT_USECOND;
<     time_t idle_interval_sec_ = CPPHTTPLIB_IDLE_INTERVAL_SECOND;
<     time_t idle_interval_usec_ = CPPHTTPLIB_IDLE_INTERVAL_USECOND;
<     size_t payload_max_length_ = CPPHTTPLIB_PAYLOAD_MAX_LENGTH;
< 
<    private:
<     using Handlers = std::vector<std::pair<std::regex, Handler>>;
<     using HandlersForContentReader = std::vector<std::pair<std::regex, HandlerWithContentReader>>;
< 
<     socket_t create_server_socket(const char *host, int port, int socket_flags) const;
<     int bind_internal(const char *host, int port, int socket_flags);
<     bool listen_internal();
< 
<     bool routing(Request &req, Response &res, Stream &strm);
<     bool handle_file_request(Request &req, Response &res, bool head = false);
<     bool dispatch_request(Request &req, Response &res, Handlers &handlers);
<     bool dispatch_request_for_content_reader(Request &req, Response &res, ContentReader content_reader,
<                                              HandlersForContentReader &handlers);
< 
<     bool parse_request_line(const char *s, Request &req);
<     bool write_response(Stream &strm, bool last_connection, const Request &req, Response &res);
<     bool write_content_with_provider(Stream &strm, const Request &req, Response &res, const std::string &boundary,
<                                      const std::string &content_type);
<     bool read_content(Stream &strm, Request &req, Response &res);
<     bool read_content_with_content_receiver(Stream &strm, Request &req, Response &res, ContentReceiver receiver,
<                                             MultipartContentHeader multipart_header, ContentReceiver multipart_receiver);
<     bool read_content_core(Stream &strm, Request &req, Response &res, ContentReceiver receiver,
<                            MultipartContentHeader mulitpart_header, ContentReceiver multipart_receiver);
< 
<     virtual bool process_and_close_socket(socket_t sock);
< 
<     std::atomic<bool> is_running_;
<     std::atomic<socket_t> svr_sock_;
<     std::vector<std::pair<std::string, std::string>> base_dirs_;
<     std::map<std::string, std::string> file_extension_and_mimetype_map_;
<     Handler file_request_handler_;
<     Handlers get_handlers_;
<     Handlers post_handlers_;
<     HandlersForContentReader post_handlers_for_content_reader_;
<     Handlers put_handlers_;
<     HandlersForContentReader put_handlers_for_content_reader_;
<     Handlers patch_handlers_;
<     HandlersForContentReader patch_handlers_for_content_reader_;
<     Handlers delete_handlers_;
<     HandlersForContentReader delete_handlers_for_content_reader_;
<     Handlers options_handlers_;
<     Handler error_handler_;
<     Logger logger_;
<     Expect100ContinueHandler expect_100_continue_handler_;
---
>     ThreadPool &pool_;
600a487
>   friend struct worker;
602,606c489,490
<   class Client {
<    public:
<     explicit Client(const std::string &host);
< 
<     explicit Client(const std::string &host, int port);
---
>   std::vector<std::thread> threads_;
>   std::list<std::function<void()>> jobs_;
608c492
<     explicit Client(const std::string &host, int port, const std::string &client_cert_path, const std::string &client_key_path);
---
>   bool shutdown_;
610c494,720
<     virtual ~Client();
---
>   std::condition_variable cond_;
>   std::mutex mutex_;
> };
> 
> using Logger = std::function<void(const Request &, const Response &)>;
> 
> class Server {
> public:
>   using Handler = std::function<void(const Request &, Response &)>;
>   using HandlerWithContentReader = std::function<void(
>       const Request &, Response &, const ContentReader &content_reader)>;
>   using Expect100ContinueHandler =
>       std::function<int(const Request &, Response &)>;
> 
>   Server();
> 
>   virtual ~Server();
> 
>   virtual bool is_valid() const;
> 
>   Server &Get(const char *pattern, Handler handler);
>   Server &Post(const char *pattern, Handler handler);
>   Server &Post(const char *pattern, HandlerWithContentReader handler);
>   Server &Put(const char *pattern, Handler handler);
>   Server &Put(const char *pattern, HandlerWithContentReader handler);
>   Server &Patch(const char *pattern, Handler handler);
>   Server &Patch(const char *pattern, HandlerWithContentReader handler);
>   Server &Delete(const char *pattern, Handler handler);
>   Server &Delete(const char *pattern, HandlerWithContentReader handler);
>   Server &Options(const char *pattern, Handler handler);
> 
>   [[deprecated]] bool set_base_dir(const char *dir,
>                                    const char *mount_point = nullptr);
>   bool set_mount_point(const char *mount_point, const char *dir);
>   bool remove_mount_point(const char *mount_point);
>   void set_file_extension_and_mimetype_mapping(const char *ext,
>                                                const char *mime);
>   void set_file_request_handler(Handler handler);
> 
>   void set_error_handler(Handler handler);
>   void set_logger(Logger logger);
> 
>   void set_expect_100_continue_handler(Expect100ContinueHandler handler);
> 
>   void set_keep_alive_max_count(size_t count);
>   void set_read_timeout(time_t sec, time_t usec = 0);
>   void set_write_timeout(time_t sec, time_t usec = 0);
>   void set_idle_interval(time_t sec, time_t usec = 0);
> 
>   void set_payload_max_length(size_t length);
> 
>   bool bind_to_port(const char *host, int port, int socket_flags = 0);
>   int bind_to_any_port(const char *host, int socket_flags = 0);
>   bool listen_after_bind();
> 
>   bool listen(const char *host, int port, int socket_flags = 0);
> 
>   bool is_running() const;
>   void stop();
> 
>   std::function<TaskQueue *(void)> new_task_queue;
> 
> protected:
>   bool process_request(Stream &strm, bool last_connection,
>                        bool &connection_close,
>                        const std::function<void(Request &)> &setup_request);
> 
>   size_t keep_alive_max_count_ = CPPHTTPLIB_KEEPALIVE_MAX_COUNT;
>   time_t read_timeout_sec_ = CPPHTTPLIB_READ_TIMEOUT_SECOND;
>   time_t read_timeout_usec_ = CPPHTTPLIB_READ_TIMEOUT_USECOND;
>   time_t write_timeout_sec_ = CPPHTTPLIB_WRITE_TIMEOUT_SECOND;
>   time_t write_timeout_usec_ = CPPHTTPLIB_WRITE_TIMEOUT_USECOND;
>   time_t idle_interval_sec_ = CPPHTTPLIB_IDLE_INTERVAL_SECOND;
>   time_t idle_interval_usec_ = CPPHTTPLIB_IDLE_INTERVAL_USECOND;
>   size_t payload_max_length_ = CPPHTTPLIB_PAYLOAD_MAX_LENGTH;
> 
> private:
>   using Handlers = std::vector<std::pair<std::regex, Handler>>;
>   using HandlersForContentReader =
>       std::vector<std::pair<std::regex, HandlerWithContentReader>>;
> 
>   socket_t create_server_socket(const char *host, int port,
>                                 int socket_flags) const;
>   int bind_internal(const char *host, int port, int socket_flags);
>   bool listen_internal();
> 
>   bool routing(Request &req, Response &res, Stream &strm);
>   bool handle_file_request(Request &req, Response &res, bool head = false);
>   bool dispatch_request(Request &req, Response &res, Handlers &handlers);
>   bool dispatch_request_for_content_reader(Request &req, Response &res,
>                                            ContentReader content_reader,
>                                            HandlersForContentReader &handlers);
> 
>   bool parse_request_line(const char *s, Request &req);
>   bool write_response(Stream &strm, bool last_connection, const Request &req,
>                       Response &res);
>   bool write_content_with_provider(Stream &strm, const Request &req,
>                                    Response &res, const std::string &boundary,
>                                    const std::string &content_type);
>   bool read_content(Stream &strm, Request &req, Response &res);
>   bool
>   read_content_with_content_receiver(Stream &strm, Request &req, Response &res,
>                                      ContentReceiver receiver,
>                                      MultipartContentHeader multipart_header,
>                                      ContentReceiver multipart_receiver);
>   bool read_content_core(Stream &strm, Request &req, Response &res,
>                          ContentReceiver receiver,
>                          MultipartContentHeader mulitpart_header,
>                          ContentReceiver multipart_receiver);
> 
>   virtual bool process_and_close_socket(socket_t sock);
> 
>   std::atomic<bool> is_running_;
>   std::atomic<socket_t> svr_sock_;
>   std::vector<std::pair<std::string, std::string>> base_dirs_;
>   std::map<std::string, std::string> file_extension_and_mimetype_map_;
>   Handler file_request_handler_;
>   Handlers get_handlers_;
>   Handlers post_handlers_;
>   HandlersForContentReader post_handlers_for_content_reader_;
>   Handlers put_handlers_;
>   HandlersForContentReader put_handlers_for_content_reader_;
>   Handlers patch_handlers_;
>   HandlersForContentReader patch_handlers_for_content_reader_;
>   Handlers delete_handlers_;
>   HandlersForContentReader delete_handlers_for_content_reader_;
>   Handlers options_handlers_;
>   Handler error_handler_;
>   Logger logger_;
>   Expect100ContinueHandler expect_100_continue_handler_;
> };
> 
> class Client {
> public:
>   explicit Client(const std::string &host);
> 
>   explicit Client(const std::string &host, int port);
> 
>   explicit Client(const std::string &host, int port,
>                   const std::string &client_cert_path,
>                   const std::string &client_key_path);
> 
>   virtual ~Client();
> 
>   virtual bool is_valid() const;
> 
>   std::shared_ptr<Response> Get(const char *path);
> 
>   std::shared_ptr<Response> Get(const char *path, const Headers &headers);
> 
>   std::shared_ptr<Response> Get(const char *path, Progress progress);
> 
>   std::shared_ptr<Response> Get(const char *path, const Headers &headers,
>                                 Progress progress);
> 
>   std::shared_ptr<Response> Get(const char *path,
>                                 ContentReceiver content_receiver);
> 
>   std::shared_ptr<Response> Get(const char *path, const Headers &headers,
>                                 ContentReceiver content_receiver);
> 
>   std::shared_ptr<Response>
>   Get(const char *path, ContentReceiver content_receiver, Progress progress);
> 
>   std::shared_ptr<Response> Get(const char *path, const Headers &headers,
>                                 ContentReceiver content_receiver,
>                                 Progress progress);
> 
>   std::shared_ptr<Response> Get(const char *path, const Headers &headers,
>                                 ResponseHandler response_handler,
>                                 ContentReceiver content_receiver);
> 
>   std::shared_ptr<Response> Get(const char *path, const Headers &headers,
>                                 ResponseHandler response_handler,
>                                 ContentReceiver content_receiver,
>                                 Progress progress);
> 
>   std::shared_ptr<Response> Head(const char *path);
> 
>   std::shared_ptr<Response> Head(const char *path, const Headers &headers);
> 
>   std::shared_ptr<Response> Post(const char *path);
> 
>   std::shared_ptr<Response> Post(const char *path, const std::string &body,
>                                  const char *content_type);
> 
>   std::shared_ptr<Response> Post(const char *path, const Headers &headers,
>                                  const std::string &body,
>                                  const char *content_type);
> 
>   std::shared_ptr<Response> Post(const char *path, size_t content_length,
>                                  ContentProvider content_provider,
>                                  const char *content_type);
> 
>   std::shared_ptr<Response> Post(const char *path, const Headers &headers,
>                                  size_t content_length,
>                                  ContentProvider content_provider,
>                                  const char *content_type);
> 
>   std::shared_ptr<Response> Post(const char *path, const Params &params);
> 
>   std::shared_ptr<Response> Post(const char *path, const Headers &headers,
>                                  const Params &params);
> 
>   std::shared_ptr<Response> Post(const char *path,
>                                  const MultipartFormDataItems &items);
> 
>   std::shared_ptr<Response> Post(const char *path, const Headers &headers,
>                                  const MultipartFormDataItems &items);
> 
>   std::shared_ptr<Response> Put(const char *path);
> 
>   std::shared_ptr<Response> Put(const char *path, const std::string &body,
>                                 const char *content_type);
> 
>   std::shared_ptr<Response> Put(const char *path, const Headers &headers,
>                                 const std::string &body,
>                                 const char *content_type);
> 
>   std::shared_ptr<Response> Put(const char *path, size_t content_length,
>                                 ContentProvider content_provider,
>                                 const char *content_type);
> 
>   std::shared_ptr<Response> Put(const char *path, const Headers &headers,
>                                 size_t content_length,
>                                 ContentProvider content_provider,
>                                 const char *content_type);
612c722
<     virtual bool is_valid() const;
---
>   std::shared_ptr<Response> Put(const char *path, const Params &params);
614c724,725
<     std::shared_ptr<Response> Get(const char *path);
---
>   std::shared_ptr<Response> Put(const char *path, const Headers &headers,
>                                 const Params &params);
616,666c727
<     std::shared_ptr<Response> Get(const char *path, const Headers &headers);
< 
<     std::shared_ptr<Response> Get(const char *path, Progress progress);
< 
<     std::shared_ptr<Response> Get(const char *path, const Headers &headers, Progress progress);
< 
<     std::shared_ptr<Response> Get(const char *path, ContentReceiver content_receiver);
< 
<     std::shared_ptr<Response> Get(const char *path, const Headers &headers, ContentReceiver content_receiver);
< 
<     std::shared_ptr<Response> Get(const char *path, ContentReceiver content_receiver, Progress progress);
< 
<     std::shared_ptr<Response> Get(const char *path, const Headers &headers, ContentReceiver content_receiver, Progress progress);
< 
<     std::shared_ptr<Response> Get(const char *path, const Headers &headers, ResponseHandler response_handler,
<                                   ContentReceiver content_receiver);
< 
<     std::shared_ptr<Response> Get(const char *path, const Headers &headers, ResponseHandler response_handler,
<                                   ContentReceiver content_receiver, Progress progress);
< 
<     std::shared_ptr<Response> Head(const char *path);
< 
<     std::shared_ptr<Response> Head(const char *path, const Headers &headers);
< 
<     std::shared_ptr<Response> Post(const char *path);
< 
<     std::shared_ptr<Response> Post(const char *path, const std::string &body, const char *content_type);
< 
<     std::shared_ptr<Response> Post(const char *path, const Headers &headers, const std::string &body, const char *content_type);
< 
<     std::shared_ptr<Response> Post(const char *path, size_t content_length, ContentProvider content_provider,
<                                    const char *content_type);
< 
<     std::shared_ptr<Response> Post(const char *path, const Headers &headers, size_t content_length,
<                                    ContentProvider content_provider, const char *content_type);
< 
<     std::shared_ptr<Response> Post(const char *path, const Params &params);
< 
<     std::shared_ptr<Response> Post(const char *path, const Headers &headers, const Params &params);
< 
<     std::shared_ptr<Response> Post(const char *path, const MultipartFormDataItems &items);
< 
<     std::shared_ptr<Response> Post(const char *path, const Headers &headers, const MultipartFormDataItems &items);
< 
<     std::shared_ptr<Response> Put(const char *path);
< 
<     std::shared_ptr<Response> Put(const char *path, const std::string &body, const char *content_type);
< 
<     std::shared_ptr<Response> Put(const char *path, const Headers &headers, const std::string &body, const char *content_type);
< 
<     std::shared_ptr<Response> Put(const char *path, size_t content_length, ContentProvider content_provider,
---
>   std::shared_ptr<Response> Patch(const char *path, const std::string &body,
669,678c730,732
<     std::shared_ptr<Response> Put(const char *path, const Headers &headers, size_t content_length,
<                                   ContentProvider content_provider, const char *content_type);
< 
<     std::shared_ptr<Response> Put(const char *path, const Params &params);
< 
<     std::shared_ptr<Response> Put(const char *path, const Headers &headers, const Params &params);
< 
<     std::shared_ptr<Response> Patch(const char *path, const std::string &body, const char *content_type);
< 
<     std::shared_ptr<Response> Patch(const char *path, const Headers &headers, const std::string &body, const char *content_type);
---
>   std::shared_ptr<Response> Patch(const char *path, const Headers &headers,
>                                   const std::string &body,
>                                   const char *content_type);
680,681c734,736
<     std::shared_ptr<Response> Patch(const char *path, size_t content_length, ContentProvider content_provider,
<                                     const char *content_type);
---
>   std::shared_ptr<Response> Patch(const char *path, size_t content_length,
>                                   ContentProvider content_provider,
>                                   const char *content_type);
683,684c738,741
<     std::shared_ptr<Response> Patch(const char *path, const Headers &headers, size_t content_length,
<                                     ContentProvider content_provider, const char *content_type);
---
>   std::shared_ptr<Response> Patch(const char *path, const Headers &headers,
>                                   size_t content_length,
>                                   ContentProvider content_provider,
>                                   const char *content_type);
686c743
<     std::shared_ptr<Response> Delete(const char *path);
---
>   std::shared_ptr<Response> Delete(const char *path);
688c745,746
<     std::shared_ptr<Response> Delete(const char *path, const std::string &body, const char *content_type);
---
>   std::shared_ptr<Response> Delete(const char *path, const std::string &body,
>                                    const char *content_type);
690c748
<     std::shared_ptr<Response> Delete(const char *path, const Headers &headers);
---
>   std::shared_ptr<Response> Delete(const char *path, const Headers &headers);
692c750,752
<     std::shared_ptr<Response> Delete(const char *path, const Headers &headers, const std::string &body, const char *content_type);
---
>   std::shared_ptr<Response> Delete(const char *path, const Headers &headers,
>                                    const std::string &body,
>                                    const char *content_type);
694c754
<     std::shared_ptr<Response> Options(const char *path);
---
>   std::shared_ptr<Response> Options(const char *path);
696c756
<     std::shared_ptr<Response> Options(const char *path, const Headers &headers);
---
>   std::shared_ptr<Response> Options(const char *path, const Headers &headers);
698c758
<     bool send(const Request &req, Response &res);
---
>   bool send(const Request &req, Response &res);
700c760,761
<     bool send(const std::vector<Request> &requests, std::vector<Response> &responses);
---
>   bool send(const std::vector<Request> &requests,
>             std::vector<Response> &responses);
702c763
<     void stop();
---
>   void stop();
704,707c765,768
<     [[deprecated]] void set_timeout_sec(time_t timeout_sec);
<     void set_connection_timeout(time_t sec, time_t usec = 0);
<     void set_read_timeout(time_t sec, time_t usec = 0);
<     void set_write_timeout(time_t sec, time_t usec = 0);
---
>   [[deprecated]] void set_timeout_sec(time_t timeout_sec);
>   void set_connection_timeout(time_t sec, time_t usec = 0);
>   void set_read_timeout(time_t sec, time_t usec = 0);
>   void set_write_timeout(time_t sec, time_t usec = 0);
709c770
<     void set_keep_alive_max_count(size_t count);
---
>   void set_keep_alive_max_count(size_t count);
711c772
<     void set_basic_auth(const char *username, const char *password);
---
>   void set_basic_auth(const char *username, const char *password);
713c774
<     void set_digest_auth(const char *username, const char *password);
---
>   void set_digest_auth(const char *username, const char *password);
716c777,779
<     void set_follow_location(bool on);
---
>   void set_follow_location(bool on);
> 
>   void set_compress(bool on);
718c781
<     void set_compress(bool on);
---
>   void set_decompress(bool on);
720c783
<     void set_interface(const char *intf);
---
>   void set_interface(const char *intf);
722,723c785,786
<     void set_proxy(const char *host, int port);
<     void set_proxy_basic_auth(const char *username, const char *password);
---
>   void set_proxy(const char *host, int port);
>   void set_proxy_basic_auth(const char *username, const char *password);
725c788
<     void set_proxy_digest_auth(const char *username, const char *password);
---
>   void set_proxy_digest_auth(const char *username, const char *password);
728c791
<     void set_logger(Logger logger);
---
>   void set_logger(Logger logger);
730,731c793,795
<    protected:
<     bool process_request(Stream &strm, const Request &req, Response &res, bool last_connection, bool &connection_close);
---
> protected:
>   bool process_request(Stream &strm, const Request &req, Response &res,
>                        bool last_connection, bool &connection_close);
733c797
<     std::atomic<socket_t> sock_;
---
>   std::atomic<socket_t> sock_;
735,737c799,801
<     const std::string host_;
<     const int port_;
<     const std::string host_and_port_;
---
>   const std::string host_;
>   const int port_;
>   const std::string host_and_port_;
739,741c803,805
<     // Settings
<     std::string client_cert_path_;
<     std::string client_key_path_;
---
>   // Settings
>   std::string client_cert_path_;
>   std::string client_key_path_;
743,748c807,812
<     time_t connection_timeout_sec_ = CPPHTTPLIB_CONNECTION_TIMEOUT_SECOND;
<     time_t connection_timeout_usec_ = CPPHTTPLIB_CONNECTION_TIMEOUT_USECOND;
<     time_t read_timeout_sec_ = CPPHTTPLIB_READ_TIMEOUT_SECOND;
<     time_t read_timeout_usec_ = CPPHTTPLIB_READ_TIMEOUT_USECOND;
<     time_t write_timeout_sec_ = CPPHTTPLIB_WRITE_TIMEOUT_SECOND;
<     time_t write_timeout_usec_ = CPPHTTPLIB_WRITE_TIMEOUT_USECOND;
---
>   time_t connection_timeout_sec_ = CPPHTTPLIB_CONNECTION_TIMEOUT_SECOND;
>   time_t connection_timeout_usec_ = CPPHTTPLIB_CONNECTION_TIMEOUT_USECOND;
>   time_t read_timeout_sec_ = CPPHTTPLIB_READ_TIMEOUT_SECOND;
>   time_t read_timeout_usec_ = CPPHTTPLIB_READ_TIMEOUT_USECOND;
>   time_t write_timeout_sec_ = CPPHTTPLIB_WRITE_TIMEOUT_SECOND;
>   time_t write_timeout_usec_ = CPPHTTPLIB_WRITE_TIMEOUT_USECOND;
750c814
<     size_t keep_alive_max_count_ = CPPHTTPLIB_KEEPALIVE_MAX_COUNT;
---
>   size_t keep_alive_max_count_ = CPPHTTPLIB_KEEPALIVE_MAX_COUNT;
752,753c816,817
<     std::string basic_auth_username_;
<     std::string basic_auth_password_;
---
>   std::string basic_auth_username_;
>   std::string basic_auth_password_;
755,756c819,820
<     std::string digest_auth_username_;
<     std::string digest_auth_password_;
---
>   std::string digest_auth_username_;
>   std::string digest_auth_password_;
759c823
<     bool follow_location_ = false;
---
>   bool follow_location_ = false;
761c825,826
<     bool compress_ = false;
---
>   bool compress_ = false;
>   bool decompress_ = true;
763c828
<     std::string interface_;
---
>   std::string interface_;
765,766c830,831
<     std::string proxy_host_;
<     int proxy_port_;
---
>   std::string proxy_host_;
>   int proxy_port_;
768,769c833,834
<     std::string proxy_basic_auth_username_;
<     std::string proxy_basic_auth_password_;
---
>   std::string proxy_basic_auth_username_;
>   std::string proxy_basic_auth_password_;
771,772c836,837
<     std::string proxy_digest_auth_username_;
<     std::string proxy_digest_auth_password_;
---
>   std::string proxy_digest_auth_username_;
>   std::string proxy_digest_auth_password_;
775c840
<     Logger logger_;
---
>   Logger logger_;
777,787c842,852
<     void copy_settings(const Client &rhs) {
<       client_cert_path_ = rhs.client_cert_path_;
<       client_key_path_ = rhs.client_key_path_;
<       connection_timeout_sec_ = rhs.connection_timeout_sec_;
<       read_timeout_sec_ = rhs.read_timeout_sec_;
<       read_timeout_usec_ = rhs.read_timeout_usec_;
<       write_timeout_sec_ = rhs.write_timeout_sec_;
<       write_timeout_usec_ = rhs.write_timeout_usec_;
<       keep_alive_max_count_ = rhs.keep_alive_max_count_;
<       basic_auth_username_ = rhs.basic_auth_username_;
<       basic_auth_password_ = rhs.basic_auth_password_;
---
>   void copy_settings(const Client &rhs) {
>     client_cert_path_ = rhs.client_cert_path_;
>     client_key_path_ = rhs.client_key_path_;
>     connection_timeout_sec_ = rhs.connection_timeout_sec_;
>     read_timeout_sec_ = rhs.read_timeout_sec_;
>     read_timeout_usec_ = rhs.read_timeout_usec_;
>     write_timeout_sec_ = rhs.write_timeout_sec_;
>     write_timeout_usec_ = rhs.write_timeout_usec_;
>     keep_alive_max_count_ = rhs.keep_alive_max_count_;
>     basic_auth_username_ = rhs.basic_auth_username_;
>     basic_auth_password_ = rhs.basic_auth_password_;
789,790c854,855
<       digest_auth_username_ = rhs.digest_auth_username_;
<       digest_auth_password_ = rhs.digest_auth_password_;
---
>     digest_auth_username_ = rhs.digest_auth_username_;
>     digest_auth_password_ = rhs.digest_auth_password_;
792,798c857,864
<       follow_location_ = rhs.follow_location_;
<       compress_ = rhs.compress_;
<       interface_ = rhs.interface_;
<       proxy_host_ = rhs.proxy_host_;
<       proxy_port_ = rhs.proxy_port_;
<       proxy_basic_auth_username_ = rhs.proxy_basic_auth_username_;
<       proxy_basic_auth_password_ = rhs.proxy_basic_auth_password_;
---
>     follow_location_ = rhs.follow_location_;
>     compress_ = rhs.compress_;
>     decompress_ = rhs.decompress_;
>     interface_ = rhs.interface_;
>     proxy_host_ = rhs.proxy_host_;
>     proxy_port_ = rhs.proxy_port_;
>     proxy_basic_auth_username_ = rhs.proxy_basic_auth_username_;
>     proxy_basic_auth_password_ = rhs.proxy_basic_auth_password_;
800,801c866,867
<       proxy_digest_auth_username_ = rhs.proxy_digest_auth_username_;
<       proxy_digest_auth_password_ = rhs.proxy_digest_auth_password_;
---
>     proxy_digest_auth_username_ = rhs.proxy_digest_auth_username_;
>     proxy_digest_auth_password_ = rhs.proxy_digest_auth_password_;
803,804c869,870
<       logger_ = rhs.logger_;
<     }
---
>     logger_ = rhs.logger_;
>   }
806,811c872,878
<    private:
<     socket_t create_client_socket() const;
<     bool read_response_line(Stream &strm, Response &res);
<     bool write_request(Stream &strm, const Request &req, bool last_connection);
<     bool redirect(const Request &req, Response &res);
<     bool handle_request(Stream &strm, const Request &req, Response &res, bool last_connection, bool &connection_close);
---
> private:
>   socket_t create_client_socket() const;
>   bool read_response_line(Stream &strm, Response &res);
>   bool write_request(Stream &strm, const Request &req, bool last_connection);
>   bool redirect(const Request &req, Response &res);
>   bool handle_request(Stream &strm, const Request &req, Response &res,
>                       bool last_connection, bool &connection_close);
813c880
<     bool connect(socket_t sock, Response &res, bool &error);
---
>   bool connect(socket_t sock, Response &res, bool &error);
816,833c883,904
<     std::shared_ptr<Response> send_with_content_provider(const char *method, const char *path, const Headers &headers,
<                                                          const std::string &body, size_t content_length,
<                                                          ContentProvider content_provider, const char *content_type);
< 
<     virtual bool
<     process_and_close_socket(socket_t sock, size_t request_count,
<                              std::function<bool(Stream &strm, bool last_connection, bool &connection_close)> callback);
< 
<     virtual bool is_ssl() const;
<   };
< 
<   inline void Get(std::vector<Request> &requests, const char *path, const Headers &headers) {
<     Request req;
<     req.method = "GET";
<     req.path = path;
<     req.headers = headers;
<     requests.emplace_back(std::move(req));
<   }
---
>   std::shared_ptr<Response> send_with_content_provider(
>       const char *method, const char *path, const Headers &headers,
>       const std::string &body, size_t content_length,
>       ContentProvider content_provider, const char *content_type);
> 
>   virtual bool process_and_close_socket(
>       socket_t sock, size_t request_count,
>       std::function<bool(Stream &strm, bool last_connection,
>                          bool &connection_close)>
>           callback);
> 
>   virtual bool is_ssl() const;
> };
> 
> inline void Get(std::vector<Request> &requests, const char *path,
>                 const Headers &headers) {
>   Request req;
>   req.method = "GET";
>   req.path = path;
>   req.headers = headers;
>   requests.emplace_back(std::move(req));
> }
835c906,908
<   inline void Get(std::vector<Request> &requests, const char *path) { Get(requests, path, Headers()); }
---
> inline void Get(std::vector<Request> &requests, const char *path) {
>   Get(requests, path, Headers());
> }
837,848c910,920
<   inline void Post(std::vector<Request> &requests, const char *path, const Headers &headers, const std::string &body,
<                    const char *content_type) {
<     Request req;
<     req.method = "POST";
<     req.path = path;
<     req.headers = headers;
<     if (content_type) {
<       req.headers.emplace("Content-Type", content_type);
<     }
<     req.body = body;
<     requests.emplace_back(std::move(req));
<   }
---
> inline void Post(std::vector<Request> &requests, const char *path,
>                  const Headers &headers, const std::string &body,
>                  const char *content_type) {
>   Request req;
>   req.method = "POST";
>   req.path = path;
>   req.headers = headers;
>   if (content_type) { req.headers.emplace("Content-Type", content_type); }
>   req.body = body;
>   requests.emplace_back(std::move(req));
> }
850,852c922,925
<   inline void Post(std::vector<Request> &requests, const char *path, const std::string &body, const char *content_type) {
<     Post(requests, path, Headers(), body, content_type);
<   }
---
> inline void Post(std::vector<Request> &requests, const char *path,
>                  const std::string &body, const char *content_type) {
>   Post(requests, path, Headers(), body, content_type);
> }
854,861c927,935
<   inline void Post(std::vector<Request> &requests, const char *path, size_t content_length, ContentProvider content_provider,
<                    const char *content_type) {
<     Request req;
<     req.method = "POST";
<     req.headers = Headers();
<     req.path = path;
<     req.content_length = content_length;
<     req.content_provider = content_provider;
---
> inline void Post(std::vector<Request> &requests, const char *path,
>                  size_t content_length, ContentProvider content_provider,
>                  const char *content_type) {
>   Request req;
>   req.method = "POST";
>   req.headers = Headers();
>   req.path = path;
>   req.content_length = content_length;
>   req.content_provider = content_provider;
863,865c937
<     if (content_type) {
<       req.headers.emplace("Content-Type", content_type);
<     }
---
>   if (content_type) { req.headers.emplace("Content-Type", content_type); }
867,868c939,940
<     requests.emplace_back(std::move(req));
<   }
---
>   requests.emplace_back(std::move(req));
> }
871,874c943,947
<   class SSLServer : public Server {
<    public:
<     SSLServer(const char *cert_path, const char *private_key_path, const char *client_ca_cert_file_path = nullptr,
<               const char *client_ca_cert_dir_path = nullptr);
---
> class SSLServer : public Server {
> public:
>   SSLServer(const char *cert_path, const char *private_key_path,
>             const char *client_ca_cert_file_path = nullptr,
>             const char *client_ca_cert_dir_path = nullptr);
876c949,950
<     SSLServer(X509 *cert, EVP_PKEY *private_key, X509_STORE *client_ca_cert_store = nullptr);
---
>   SSLServer(X509 *cert, EVP_PKEY *private_key,
>             X509_STORE *client_ca_cert_store = nullptr);
878c952
<     ~SSLServer() override;
---
>   ~SSLServer() override;
880c954
<     bool is_valid() const override;
---
>   bool is_valid() const override;
882,883c956,957
<    private:
<     bool process_and_close_socket(socket_t sock) override;
---
> private:
>   bool process_and_close_socket(socket_t sock) override;
885,887c959,961
<     SSL_CTX *ctx_;
<     std::mutex ctx_mutex_;
<   };
---
>   SSL_CTX *ctx_;
>   std::mutex ctx_mutex_;
> };
889,891c963,965
<   class SSLClient : public Client {
<    public:
<     explicit SSLClient(const std::string &host);
---
> class SSLClient : public Client {
> public:
>   explicit SSLClient(const std::string &host);
893c967
<     explicit SSLClient(const std::string &host, int port);
---
>   explicit SSLClient(const std::string &host, int port);
895,896c969,971
<     explicit SSLClient(const std::string &host, int port, const std::string &client_cert_path,
<                        const std::string &client_key_path);
---
>   explicit SSLClient(const std::string &host, int port,
>                      const std::string &client_cert_path,
>                      const std::string &client_key_path);
898c973,974
<     explicit SSLClient(const std::string &host, int port, X509 *client_cert, EVP_PKEY *client_key);
---
>   explicit SSLClient(const std::string &host, int port, X509 *client_cert,
>                      EVP_PKEY *client_key);
900c976
<     ~SSLClient() override;
---
>   ~SSLClient() override;
902c978
<     bool is_valid() const override;
---
>   bool is_valid() const override;
904c980,981
<     void set_ca_cert_path(const char *ca_cert_file_path, const char *ca_cert_dir_path = nullptr);
---
>   void set_ca_cert_path(const char *ca_cert_file_path,
>                         const char *ca_cert_dir_path = nullptr);
906c983
<     void set_ca_cert_store(X509_STORE *ca_cert_store);
---
>   void set_ca_cert_store(X509_STORE *ca_cert_store);
908c985
<     void enable_server_certificate_verification(bool enabled);
---
>   void enable_server_certificate_verification(bool enabled);
910c987
<     long get_openssl_verify_result() const;
---
>   long get_openssl_verify_result() const;
912c989
<     SSL_CTX *ssl_context() const;
---
>   SSL_CTX *ssl_context() const;
914,918c991,997
<    private:
<     bool
<     process_and_close_socket(socket_t sock, size_t request_count,
<                              std::function<bool(Stream &strm, bool last_connection, bool &connection_close)> callback) override;
<     bool is_ssl() const override;
---
> private:
>   bool process_and_close_socket(
>       socket_t sock, size_t request_count,
>       std::function<bool(Stream &strm, bool last_connection,
>                          bool &connection_close)>
>           callback) override;
>   bool is_ssl() const override;
920,923c999,1002
<     bool verify_host(X509 *server_cert) const;
<     bool verify_host_with_subject_alt_name(X509 *server_cert) const;
<     bool verify_host_with_common_name(X509 *server_cert) const;
<     bool check_host_name(const char *pattern, size_t pattern_len) const;
---
>   bool verify_host(X509 *server_cert) const;
>   bool verify_host_with_subject_alt_name(X509 *server_cert) const;
>   bool verify_host_with_common_name(X509 *server_cert) const;
>   bool check_host_name(const char *pattern, size_t pattern_len) const;
925,927c1004,1006
<     SSL_CTX *ctx_;
<     std::mutex ctx_mutex_;
<     std::vector<std::string> host_components_;
---
>   SSL_CTX *ctx_;
>   std::mutex ctx_mutex_;
>   std::vector<std::string> host_components_;
929,934c1008,1013
<     std::string ca_cert_file_path_;
<     std::string ca_cert_dir_path_;
<     X509_STORE *ca_cert_store_ = nullptr;
<     bool server_certificate_verification_ = false;
<     long verify_result_ = 0;
<   };
---
>   std::string ca_cert_file_path_;
>   std::string ca_cert_dir_path_;
>   X509_STORE *ca_cert_store_ = nullptr;
>   bool server_certificate_verification_ = false;
>   long verify_result_ = 0;
> };
937,948c1016,1019
<   class Client2 {
<    public:
<     explicit Client2(const char *scheme_host_port) : Client2(scheme_host_port, std::string(), std::string()) {}
< 
<     explicit Client2(const char *scheme_host_port, const std::string &client_cert_path, const std::string &client_key_path) {
<       const static std::regex re(R"(^(https?)://([^:/?#]+)(?::(\d+))?)");
< 
<       std::cmatch m;
<       if (std::regex_match(scheme_host_port, m, re)) {
<         auto scheme = m[1].str();
<         auto host = m[2].str();
<         auto port_str = m[3].str();
---
> class Client2 {
> public:
>   explicit Client2(const char *scheme_host_port)
>       : Client2(scheme_host_port, std::string(), std::string()) {}
950c1021,1024
<         auto port = !port_str.empty() ? std::stoi(port_str) : (scheme == "https" ? 443 : 80);
---
>   explicit Client2(const char *scheme_host_port,
>                    const std::string &client_cert_path,
>                    const std::string &client_key_path) {
>     const static std::regex re(R"(^(https?)://([^:/?#]+)(?::(\d+))?)");
952c1026,1035
<         if (scheme == "https") {
---
>     std::cmatch m;
>     if (std::regex_match(scheme_host_port, m, re)) {
>       auto scheme = m[1].str();
>       auto host = m[2].str();
>       auto port_str = m[3].str();
> 
>       auto port = !port_str.empty() ? std::stoi(port_str)
>                                     : (scheme == "https" ? 443 : 80);
> 
>       if (scheme == "https") {
954,955c1037,1039
<           is_ssl_ = true;
<           cli_ = std::make_shared<SSLClient>(host.c_str(), port, client_cert_path, client_key_path);
---
>         is_ssl_ = true;
>         cli_ = std::make_shared<SSLClient>(host.c_str(), port, client_cert_path,
>                                            client_key_path);
957,959c1041,1043
<         } else {
<           cli_ = std::make_shared<Client>(host.c_str(), port, client_cert_path, client_key_path);
<         }
---
>       } else {
>         cli_ = std::make_shared<Client>(host.c_str(), port, client_cert_path,
>                                         client_key_path);
961a1046
>   }
963c1048
<     ~Client2() {}
---
>   ~Client2() {}
965c1050
<     bool is_valid() const { return cli_ != nullptr; }
---
>   bool is_valid() const { return cli_ != nullptr; }
967c1052
<     std::shared_ptr<Response> Get(const char *path) { return cli_->Get(path); }
---
>   std::shared_ptr<Response> Get(const char *path) { return cli_->Get(path); }
969c1054,1056
<     std::shared_ptr<Response> Get(const char *path, const Headers &headers) { return cli_->Get(path, headers); }
---
>   std::shared_ptr<Response> Get(const char *path, const Headers &headers) {
>     return cli_->Get(path, headers);
>   }
971c1058,1060
<     std::shared_ptr<Response> Get(const char *path, Progress progress) { return cli_->Get(path, progress); }
---
>   std::shared_ptr<Response> Get(const char *path, Progress progress) {
>     return cli_->Get(path, progress);
>   }
973,975c1062,1065
<     std::shared_ptr<Response> Get(const char *path, const Headers &headers, Progress progress) {
<       return cli_->Get(path, headers, progress);
<     }
---
>   std::shared_ptr<Response> Get(const char *path, const Headers &headers,
>                                 Progress progress) {
>     return cli_->Get(path, headers, progress);
>   }
977,979c1067,1070
<     std::shared_ptr<Response> Get(const char *path, ContentReceiver content_receiver) {
<       return cli_->Get(path, content_receiver);
<     }
---
>   std::shared_ptr<Response> Get(const char *path,
>                                 ContentReceiver content_receiver) {
>     return cli_->Get(path, content_receiver);
>   }
981,983c1072,1075
<     std::shared_ptr<Response> Get(const char *path, const Headers &headers, ContentReceiver content_receiver) {
<       return cli_->Get(path, headers, content_receiver);
<     }
---
>   std::shared_ptr<Response> Get(const char *path, const Headers &headers,
>                                 ContentReceiver content_receiver) {
>     return cli_->Get(path, headers, content_receiver);
>   }
985,987c1077,1080
<     std::shared_ptr<Response> Get(const char *path, ContentReceiver content_receiver, Progress progress) {
<       return cli_->Get(path, content_receiver, progress);
<     }
---
>   std::shared_ptr<Response>
>   Get(const char *path, ContentReceiver content_receiver, Progress progress) {
>     return cli_->Get(path, content_receiver, progress);
>   }
989,991c1082,1086
<     std::shared_ptr<Response> Get(const char *path, const Headers &headers, ContentReceiver content_receiver, Progress progress) {
<       return cli_->Get(path, headers, content_receiver, progress);
<     }
---
>   std::shared_ptr<Response> Get(const char *path, const Headers &headers,
>                                 ContentReceiver content_receiver,
>                                 Progress progress) {
>     return cli_->Get(path, headers, content_receiver, progress);
>   }
993,996c1088,1092
<     std::shared_ptr<Response> Get(const char *path, const Headers &headers, ResponseHandler response_handler,
<                                   ContentReceiver content_receiver) {
<       return cli_->Get(path, headers, response_handler, content_receiver);
<     }
---
>   std::shared_ptr<Response> Get(const char *path, const Headers &headers,
>                                 ResponseHandler response_handler,
>                                 ContentReceiver content_receiver) {
>     return cli_->Get(path, headers, response_handler, content_receiver);
>   }
998,1001c1094,1100
<     std::shared_ptr<Response> Get(const char *path, const Headers &headers, ResponseHandler response_handler,
<                                   ContentReceiver content_receiver, Progress progress) {
<       return cli_->Get(path, headers, response_handler, content_receiver, progress);
<     }
---
>   std::shared_ptr<Response> Get(const char *path, const Headers &headers,
>                                 ResponseHandler response_handler,
>                                 ContentReceiver content_receiver,
>                                 Progress progress) {
>     return cli_->Get(path, headers, response_handler, content_receiver,
>                      progress);
>   }
1003c1102
<     std::shared_ptr<Response> Head(const char *path) { return cli_->Head(path); }
---
>   std::shared_ptr<Response> Head(const char *path) { return cli_->Head(path); }
1005c1104,1106
<     std::shared_ptr<Response> Head(const char *path, const Headers &headers) { return cli_->Head(path, headers); }
---
>   std::shared_ptr<Response> Head(const char *path, const Headers &headers) {
>     return cli_->Head(path, headers);
>   }
1007c1108
<     std::shared_ptr<Response> Post(const char *path) { return cli_->Post(path); }
---
>   std::shared_ptr<Response> Post(const char *path) { return cli_->Post(path); }
1009,1011c1110,1113
<     std::shared_ptr<Response> Post(const char *path, const std::string &body, const char *content_type) {
<       return cli_->Post(path, body, content_type);
<     }
---
>   std::shared_ptr<Response> Post(const char *path, const std::string &body,
>                                  const char *content_type) {
>     return cli_->Post(path, body, content_type);
>   }
1013,1015c1115,1119
<     std::shared_ptr<Response> Post(const char *path, const Headers &headers, const std::string &body, const char *content_type) {
<       return cli_->Post(path, headers, body, content_type);
<     }
---
>   std::shared_ptr<Response> Post(const char *path, const Headers &headers,
>                                  const std::string &body,
>                                  const char *content_type) {
>     return cli_->Post(path, headers, body, content_type);
>   }
1017,1020c1121,1125
<     std::shared_ptr<Response> Post(const char *path, size_t content_length, ContentProvider content_provider,
<                                    const char *content_type) {
<       return cli_->Post(path, content_length, content_provider, content_type);
<     }
---
>   std::shared_ptr<Response> Post(const char *path, size_t content_length,
>                                  ContentProvider content_provider,
>                                  const char *content_type) {
>     return cli_->Post(path, content_length, content_provider, content_type);
>   }
1022,1025c1127,1133
<     std::shared_ptr<Response> Post(const char *path, const Headers &headers, size_t content_length,
<                                    ContentProvider content_provider, const char *content_type) {
<       return cli_->Post(path, headers, content_length, content_provider, content_type);
<     }
---
>   std::shared_ptr<Response> Post(const char *path, const Headers &headers,
>                                  size_t content_length,
>                                  ContentProvider content_provider,
>                                  const char *content_type) {
>     return cli_->Post(path, headers, content_length, content_provider,
>                       content_type);
>   }
1027c1135,1137
<     std::shared_ptr<Response> Post(const char *path, const Params &params) { return cli_->Post(path, params); }
---
>   std::shared_ptr<Response> Post(const char *path, const Params &params) {
>     return cli_->Post(path, params);
>   }
1029,1031c1139,1142
<     std::shared_ptr<Response> Post(const char *path, const Headers &headers, const Params &params) {
<       return cli_->Post(path, headers, params);
<     }
---
>   std::shared_ptr<Response> Post(const char *path, const Headers &headers,
>                                  const Params &params) {
>     return cli_->Post(path, headers, params);
>   }
1033c1144,1147
<     std::shared_ptr<Response> Post(const char *path, const MultipartFormDataItems &items) { return cli_->Post(path, items); }
---
>   std::shared_ptr<Response> Post(const char *path,
>                                  const MultipartFormDataItems &items) {
>     return cli_->Post(path, items);
>   }
1035,1037c1149,1152
<     std::shared_ptr<Response> Post(const char *path, const Headers &headers, const MultipartFormDataItems &items) {
<       return cli_->Post(path, headers, items);
<     }
---
>   std::shared_ptr<Response> Post(const char *path, const Headers &headers,
>                                  const MultipartFormDataItems &items) {
>     return cli_->Post(path, headers, items);
>   }
1039c1154
<     std::shared_ptr<Response> Put(const char *path) { return cli_->Put(path); }
---
>   std::shared_ptr<Response> Put(const char *path) { return cli_->Put(path); }
1041,1043c1156,1159
<     std::shared_ptr<Response> Put(const char *path, const std::string &body, const char *content_type) {
<       return cli_->Put(path, body, content_type);
<     }
---
>   std::shared_ptr<Response> Put(const char *path, const std::string &body,
>                                 const char *content_type) {
>     return cli_->Put(path, body, content_type);
>   }
1045,1047c1161,1165
<     std::shared_ptr<Response> Put(const char *path, const Headers &headers, const std::string &body, const char *content_type) {
<       return cli_->Put(path, headers, body, content_type);
<     }
---
>   std::shared_ptr<Response> Put(const char *path, const Headers &headers,
>                                 const std::string &body,
>                                 const char *content_type) {
>     return cli_->Put(path, headers, body, content_type);
>   }
1049,1052c1167,1171
<     std::shared_ptr<Response> Put(const char *path, size_t content_length, ContentProvider content_provider,
<                                   const char *content_type) {
<       return cli_->Put(path, content_length, content_provider, content_type);
<     }
---
>   std::shared_ptr<Response> Put(const char *path, size_t content_length,
>                                 ContentProvider content_provider,
>                                 const char *content_type) {
>     return cli_->Put(path, content_length, content_provider, content_type);
>   }
1054,1057c1173,1179
<     std::shared_ptr<Response> Put(const char *path, const Headers &headers, size_t content_length,
<                                   ContentProvider content_provider, const char *content_type) {
<       return cli_->Put(path, headers, content_length, content_provider, content_type);
<     }
---
>   std::shared_ptr<Response> Put(const char *path, const Headers &headers,
>                                 size_t content_length,
>                                 ContentProvider content_provider,
>                                 const char *content_type) {
>     return cli_->Put(path, headers, content_length, content_provider,
>                      content_type);
>   }
1059c1181,1183
<     std::shared_ptr<Response> Put(const char *path, const Params &params) { return cli_->Put(path, params); }
---
>   std::shared_ptr<Response> Put(const char *path, const Params &params) {
>     return cli_->Put(path, params);
>   }
1061,1063c1185,1188
<     std::shared_ptr<Response> Put(const char *path, const Headers &headers, const Params &params) {
<       return cli_->Put(path, headers, params);
<     }
---
>   std::shared_ptr<Response> Put(const char *path, const Headers &headers,
>                                 const Params &params) {
>     return cli_->Put(path, headers, params);
>   }
1065,1067c1190,1193
<     std::shared_ptr<Response> Patch(const char *path, const std::string &body, const char *content_type) {
<       return cli_->Patch(path, body, content_type);
<     }
---
>   std::shared_ptr<Response> Patch(const char *path, const std::string &body,
>                                   const char *content_type) {
>     return cli_->Patch(path, body, content_type);
>   }
1069,1071c1195,1199
<     std::shared_ptr<Response> Patch(const char *path, const Headers &headers, const std::string &body, const char *content_type) {
<       return cli_->Patch(path, headers, body, content_type);
<     }
---
>   std::shared_ptr<Response> Patch(const char *path, const Headers &headers,
>                                   const std::string &body,
>                                   const char *content_type) {
>     return cli_->Patch(path, headers, body, content_type);
>   }
1073,1076c1201,1205
<     std::shared_ptr<Response> Patch(const char *path, size_t content_length, ContentProvider content_provider,
<                                     const char *content_type) {
<       return cli_->Patch(path, content_length, content_provider, content_type);
<     }
---
>   std::shared_ptr<Response> Patch(const char *path, size_t content_length,
>                                   ContentProvider content_provider,
>                                   const char *content_type) {
>     return cli_->Patch(path, content_length, content_provider, content_type);
>   }
1078,1081c1207,1213
<     std::shared_ptr<Response> Patch(const char *path, const Headers &headers, size_t content_length,
<                                     ContentProvider content_provider, const char *content_type) {
<       return cli_->Patch(path, headers, content_length, content_provider, content_type);
<     }
---
>   std::shared_ptr<Response> Patch(const char *path, const Headers &headers,
>                                   size_t content_length,
>                                   ContentProvider content_provider,
>                                   const char *content_type) {
>     return cli_->Patch(path, headers, content_length, content_provider,
>                        content_type);
>   }
1083c1215,1217
<     std::shared_ptr<Response> Delete(const char *path) { return cli_->Delete(path); }
---
>   std::shared_ptr<Response> Delete(const char *path) {
>     return cli_->Delete(path);
>   }
1085,1087c1219,1222
<     std::shared_ptr<Response> Delete(const char *path, const std::string &body, const char *content_type) {
<       return cli_->Delete(path, body, content_type);
<     }
---
>   std::shared_ptr<Response> Delete(const char *path, const std::string &body,
>                                    const char *content_type) {
>     return cli_->Delete(path, body, content_type);
>   }
1089c1224,1226
<     std::shared_ptr<Response> Delete(const char *path, const Headers &headers) { return cli_->Delete(path, headers); }
---
>   std::shared_ptr<Response> Delete(const char *path, const Headers &headers) {
>     return cli_->Delete(path, headers);
>   }
1091,1094c1228,1232
<     std::shared_ptr<Response> Delete(const char *path, const Headers &headers, const std::string &body,
<                                      const char *content_type) {
<       return cli_->Delete(path, headers, body, content_type);
<     }
---
>   std::shared_ptr<Response> Delete(const char *path, const Headers &headers,
>                                    const std::string &body,
>                                    const char *content_type) {
>     return cli_->Delete(path, headers, body, content_type);
>   }
1096c1234,1236
<     std::shared_ptr<Response> Options(const char *path) { return cli_->Options(path); }
---
>   std::shared_ptr<Response> Options(const char *path) {
>     return cli_->Options(path);
>   }
1098c1238,1240
<     std::shared_ptr<Response> Options(const char *path, const Headers &headers) { return cli_->Options(path, headers); }
---
>   std::shared_ptr<Response> Options(const char *path, const Headers &headers) {
>     return cli_->Options(path, headers);
>   }
1100c1242
<     bool send(const Request &req, Response &res) { return cli_->send(req, res); }
---
>   bool send(const Request &req, Response &res) { return cli_->send(req, res); }
1102c1244,1247
<     bool send(const std::vector<Request> &requests, std::vector<Response> &responses) { return cli_->send(requests, responses); }
---
>   bool send(const std::vector<Request> &requests,
>             std::vector<Response> &responses) {
>     return cli_->send(requests, responses);
>   }
1104c1249
<     void stop() { cli_->stop(); }
---
>   void stop() { cli_->stop(); }
1106,1109c1251,1254
<     Client2 &set_connection_timeout(time_t sec, time_t usec) {
<       cli_->set_connection_timeout(sec, usec);
<       return *this;
<     }
---
>   Client2 &set_connection_timeout(time_t sec, time_t usec) {
>     cli_->set_connection_timeout(sec, usec);
>     return *this;
>   }
1111,1114c1256,1259
<     Client2 &set_read_timeout(time_t sec, time_t usec) {
<       cli_->set_read_timeout(sec, usec);
<       return *this;
<     }
---
>   Client2 &set_read_timeout(time_t sec, time_t usec) {
>     cli_->set_read_timeout(sec, usec);
>     return *this;
>   }
1116,1119c1261,1264
<     Client2 &set_keep_alive_max_count(size_t count) {
<       cli_->set_keep_alive_max_count(count);
<       return *this;
<     }
---
>   Client2 &set_keep_alive_max_count(size_t count) {
>     cli_->set_keep_alive_max_count(count);
>     return *this;
>   }
1121,1124c1266,1269
<     Client2 &set_basic_auth(const char *username, const char *password) {
<       cli_->set_basic_auth(username, password);
<       return *this;
<     }
---
>   Client2 &set_basic_auth(const char *username, const char *password) {
>     cli_->set_basic_auth(username, password);
>     return *this;
>   }
1127,1130c1272,1275
<     Client2 &set_digest_auth(const char *username, const char *password) {
<       cli_->set_digest_auth(username, password);
<       return *this;
<     }
---
>   Client2 &set_digest_auth(const char *username, const char *password) {
>     cli_->set_digest_auth(username, password);
>     return *this;
>   }
1133,1136c1278,1281
<     Client2 &set_follow_location(bool on) {
<       cli_->set_follow_location(on);
<       return *this;
<     }
---
>   Client2 &set_follow_location(bool on) {
>     cli_->set_follow_location(on);
>     return *this;
>   }
1138,1141c1283,1286
<     Client2 &set_compress(bool on) {
<       cli_->set_compress(on);
<       return *this;
<     }
---
>   Client2 &set_compress(bool on) {
>     cli_->set_compress(on);
>     return *this;
>   }
1143,1146c1288,1291
<     Client2 &set_interface(const char *intf) {
<       cli_->set_interface(intf);
<       return *this;
<     }
---
>   Client2 &set_decompress(bool on) {
>     cli_->set_decompress(on);
>     return *this;
>   }
1148,1151c1293,1296
<     Client2 &set_proxy(const char *host, int port) {
<       cli_->set_proxy(host, port);
<       return *this;
<     }
---
>   Client2 &set_interface(const char *intf) {
>     cli_->set_interface(intf);
>     return *this;
>   }
1153,1156c1298,1306
<     Client2 &set_proxy_basic_auth(const char *username, const char *password) {
<       cli_->set_proxy_basic_auth(username, password);
<       return *this;
<     }
---
>   Client2 &set_proxy(const char *host, int port) {
>     cli_->set_proxy(host, port);
>     return *this;
>   }
> 
>   Client2 &set_proxy_basic_auth(const char *username, const char *password) {
>     cli_->set_proxy_basic_auth(username, password);
>     return *this;
>   }
1159,1162c1309,1312
<     Client2 &set_proxy_digest_auth(const char *username, const char *password) {
<       cli_->set_proxy_digest_auth(username, password);
<       return *this;
<     }
---
>   Client2 &set_proxy_digest_auth(const char *username, const char *password) {
>     cli_->set_proxy_digest_auth(username, password);
>     return *this;
>   }
1165,1168c1315,1318
<     Client2 &set_logger(Logger logger) {
<       cli_->set_logger(logger);
<       return *this;
<     }
---
>   Client2 &set_logger(Logger logger) {
>     cli_->set_logger(logger);
>     return *this;
>   }
1170c1320
<     // SSL
---
>   // SSL
1172,1175c1322,1327
<     Client2 &set_ca_cert_path(const char *ca_cert_file_path, const char *ca_cert_dir_path = nullptr) {
<       dynamic_cast<SSLClient &>(*cli_).set_ca_cert_path(ca_cert_file_path, ca_cert_dir_path);
<       return *this;
<     }
---
>   Client2 &set_ca_cert_path(const char *ca_cert_file_path,
>                             const char *ca_cert_dir_path = nullptr) {
>     dynamic_cast<SSLClient &>(*cli_).set_ca_cert_path(ca_cert_file_path,
>                                                       ca_cert_dir_path);
>     return *this;
>   }
1177,1180c1329,1332
<     Client2 &set_ca_cert_store(X509_STORE *ca_cert_store) {
<       dynamic_cast<SSLClient &>(*cli_).set_ca_cert_store(ca_cert_store);
<       return *this;
<     }
---
>   Client2 &set_ca_cert_store(X509_STORE *ca_cert_store) {
>     dynamic_cast<SSLClient &>(*cli_).set_ca_cert_store(ca_cert_store);
>     return *this;
>   }
1182,1185c1334,1338
<     Client2 &enable_server_certificate_verification(bool enabled) {
<       dynamic_cast<SSLClient &>(*cli_).enable_server_certificate_verification(enabled);
<       return *this;
<     }
---
>   Client2 &enable_server_certificate_verification(bool enabled) {
>     dynamic_cast<SSLClient &>(*cli_).enable_server_certificate_verification(
>         enabled);
>     return *this;
>   }
1187c1340,1342
<     long get_openssl_verify_result() const { return dynamic_cast<SSLClient &>(*cli_).get_openssl_verify_result(); }
---
>   long get_openssl_verify_result() const {
>     return dynamic_cast<SSLClient &>(*cli_).get_openssl_verify_result();
>   }
1189c1344,1346
<     SSL_CTX *ssl_context() const { return dynamic_cast<SSLClient &>(*cli_).ssl_context(); }
---
>   SSL_CTX *ssl_context() const {
>     return dynamic_cast<SSLClient &>(*cli_).ssl_context();
>   }
1192,1195c1349,1352
<    private:
<     bool is_ssl_ = false;
<     std::shared_ptr<Client> cli_;
<   };
---
> private:
>   bool is_ssl_ = false;
>   std::shared_ptr<Client> cli_;
> };
1197c1354
<   // ----------------------------------------------------------------------------
---
> // ----------------------------------------------------------------------------
1199,1201c1356,1358
<   /*
<    * Implementation
<    */
---
> /*
>  * Implementation
>  */
1203c1360
<   namespace detail {
---
> namespace detail {
1205,1215c1362,1386
<     inline bool is_hex(char c, int &v) {
<       if (0x20 <= c && isdigit(c)) {
<         v = c - '0';
<         return true;
<       } else if ('A' <= c && c <= 'F') {
<         v = c - 'A' + 10;
<         return true;
<       } else if ('a' <= c && c <= 'f') {
<         v = c - 'a' + 10;
<         return true;
<       }
---
> inline bool is_hex(char c, int &v) {
>   if (0x20 <= c && isdigit(c)) {
>     v = c - '0';
>     return true;
>   } else if ('A' <= c && c <= 'F') {
>     v = c - 'A' + 10;
>     return true;
>   } else if ('a' <= c && c <= 'f') {
>     v = c - 'a' + 10;
>     return true;
>   }
>   return false;
> }
> 
> inline bool from_hex_to_i(const std::string &s, size_t i, size_t cnt,
>                           int &val) {
>   if (i >= s.size()) { return false; }
> 
>   val = 0;
>   for (; cnt; i++, cnt--) {
>     if (!s[i]) { return false; }
>     int v = 0;
>     if (is_hex(s[i], v)) {
>       val = val * 16 + v;
>     } else {
1217a1389,1391
>   }
>   return true;
> }
1219,1237c1393,1401
<     inline bool from_hex_to_i(const std::string &s, size_t i, size_t cnt, int &val) {
<       if (i >= s.size()) {
<         return false;
<       }
< 
<       val = 0;
<       for (; cnt; i++, cnt--) {
<         if (!s[i]) {
<           return false;
<         }
<         int v = 0;
<         if (is_hex(s[i], v)) {
<           val = val * 16 + v;
<         } else {
<           return false;
<         }
<       }
<       return true;
<     }
---
> inline std::string from_i_to_hex(size_t n) {
>   const char *charset = "0123456789abcdef";
>   std::string ret;
>   do {
>     ret = charset[n & 15] + ret;
>     n >>= 4;
>   } while (n > 0);
>   return ret;
> }
1239,1299c1403,1429
<     inline std::string from_i_to_hex(size_t n) {
<       const char *charset = "0123456789abcdef";
<       std::string ret;
<       do {
<         ret = charset[n & 15] + ret;
<         n >>= 4;
<       } while (n > 0);
<       return ret;
<     }
< 
<     inline size_t to_utf8(int code, char *buff) {
<       if (code < 0x0080) {
<         buff[0] = (code & 0x7F);
<         return 1;
<       } else if (code < 0x0800) {
<         buff[0] = static_cast<char>(0xC0 | ((code >> 6) & 0x1F));
<         buff[1] = static_cast<char>(0x80 | (code & 0x3F));
<         return 2;
<       } else if (code < 0xD800) {
<         buff[0] = static_cast<char>(0xE0 | ((code >> 12) & 0xF));
<         buff[1] = static_cast<char>(0x80 | ((code >> 6) & 0x3F));
<         buff[2] = static_cast<char>(0x80 | (code & 0x3F));
<         return 3;
<       } else if (code < 0xE000) {  // D800 - DFFF is invalid...
<         return 0;
<       } else if (code < 0x10000) {
<         buff[0] = static_cast<char>(0xE0 | ((code >> 12) & 0xF));
<         buff[1] = static_cast<char>(0x80 | ((code >> 6) & 0x3F));
<         buff[2] = static_cast<char>(0x80 | (code & 0x3F));
<         return 3;
<       } else if (code < 0x110000) {
<         buff[0] = static_cast<char>(0xF0 | ((code >> 18) & 0x7));
<         buff[1] = static_cast<char>(0x80 | ((code >> 12) & 0x3F));
<         buff[2] = static_cast<char>(0x80 | ((code >> 6) & 0x3F));
<         buff[3] = static_cast<char>(0x80 | (code & 0x3F));
<         return 4;
<       }
< 
<       // NOTREACHED
<       return 0;
<     }
< 
<     // NOTE: This code came up with the following stackoverflow post:
<     // https://stackoverflow.com/questions/180947/base64-decode-snippet-in-c
<     inline std::string base64_encode(const std::string &in) {
<       static const auto lookup = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
< 
<       std::string out;
<       out.reserve(in.size());
< 
<       int val = 0;
<       int valb = -6;
< 
<       for (auto c : in) {
<         val = (val << 8) + static_cast<uint8_t>(c);
<         valb += 8;
<         while (valb >= 0) {
<           out.push_back(lookup[(val >> valb) & 0x3F]);
<           valb -= 6;
<         }
<       }
---
> inline size_t to_utf8(int code, char *buff) {
>   if (code < 0x0080) {
>     buff[0] = (code & 0x7F);
>     return 1;
>   } else if (code < 0x0800) {
>     buff[0] = static_cast<char>(0xC0 | ((code >> 6) & 0x1F));
>     buff[1] = static_cast<char>(0x80 | (code & 0x3F));
>     return 2;
>   } else if (code < 0xD800) {
>     buff[0] = static_cast<char>(0xE0 | ((code >> 12) & 0xF));
>     buff[1] = static_cast<char>(0x80 | ((code >> 6) & 0x3F));
>     buff[2] = static_cast<char>(0x80 | (code & 0x3F));
>     return 3;
>   } else if (code < 0xE000) { // D800 - DFFF is invalid...
>     return 0;
>   } else if (code < 0x10000) {
>     buff[0] = static_cast<char>(0xE0 | ((code >> 12) & 0xF));
>     buff[1] = static_cast<char>(0x80 | ((code >> 6) & 0x3F));
>     buff[2] = static_cast<char>(0x80 | (code & 0x3F));
>     return 3;
>   } else if (code < 0x110000) {
>     buff[0] = static_cast<char>(0xF0 | ((code >> 18) & 0x7));
>     buff[1] = static_cast<char>(0x80 | ((code >> 12) & 0x3F));
>     buff[2] = static_cast<char>(0x80 | ((code >> 6) & 0x3F));
>     buff[3] = static_cast<char>(0x80 | (code & 0x3F));
>     return 4;
>   }
1301,1303c1431,1433
<       if (valb > -6) {
<         out.push_back(lookup[((val << 8) >> (valb + 8)) & 0x3F]);
<       }
---
>   // NOTREACHED
>   return 0;
> }
1305,1307c1435,1439
<       while (out.size() % 4) {
<         out.push_back('=');
<       }
---
> // NOTE: This code came up with the following stackoverflow post:
> // https://stackoverflow.com/questions/180947/base64-decode-snippet-in-c
> inline std::string base64_encode(const std::string &in) {
>   static const auto lookup =
>       "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
1309,1310c1441,1442
<       return out;
<     }
---
>   std::string out;
>   out.reserve(in.size());
1312,1315c1444,1445
<     inline bool is_file(const std::string &path) {
<       struct stat st;
<       return stat(path.c_str(), &st) >= 0 && S_ISREG(st.st_mode);
<     }
---
>   int val = 0;
>   int valb = -6;
1317,1319c1447,1452
<     inline bool is_dir(const std::string &path) {
<       struct stat st;
<       return stat(path.c_str(), &st) >= 0 && S_ISDIR(st.st_mode);
---
>   for (auto c : in) {
>     val = (val << 8) + static_cast<uint8_t>(c);
>     valb += 8;
>     while (valb >= 0) {
>       out.push_back(lookup[(val >> valb) & 0x3F]);
>       valb -= 6;
1320a1454
>   }
1322,1324c1456
<     inline bool is_valid_path(const std::string &path) {
<       size_t level = 0;
<       size_t i = 0;
---
>   if (valb > -6) { out.push_back(lookup[((val << 8) >> (valb + 8)) & 0x3F]); }
1326,1329c1458,1460
<       // Skip slash
<       while (i < path.size() && path[i] == '/') {
<         i++;
<       }
---
>   while (out.size() % 4) {
>     out.push_back('=');
>   }
1331,1336c1462,1463
<       while (i < path.size()) {
<         // Read component
<         auto beg = i;
<         while (i < path.size() && path[i] != '/') {
<           i++;
<         }
---
>   return out;
> }
1338,1339c1465,1468
<         auto len = i - beg;
<         assert(len > 0);
---
> inline bool is_file(const std::string &path) {
>   struct stat st;
>   return stat(path.c_str(), &st) >= 0 && S_ISREG(st.st_mode);
> }
1341,1350c1470,1473
<         if (!path.compare(beg, len, ".")) {
<           ;
<         } else if (!path.compare(beg, len, "..")) {
<           if (level == 0) {
<             return false;
<           }
<           level--;
<         } else {
<           level++;
<         }
---
> inline bool is_dir(const std::string &path) {
>   struct stat st;
>   return stat(path.c_str(), &st) >= 0 && S_ISDIR(st.st_mode);
> }
1352,1356c1475,1482
<         // Skip slash
<         while (i < path.size() && path[i] == '/') {
<           i++;
<         }
<       }
---
> inline bool is_valid_path(const std::string &path) {
>   size_t level = 0;
>   size_t i = 0;
> 
>   // Skip slash
>   while (i < path.size() && path[i] == '/') {
>     i++;
>   }
1358c1484,1488
<       return true;
---
>   while (i < path.size()) {
>     // Read component
>     auto beg = i;
>     while (i < path.size() && path[i] != '/') {
>       i++;
1361,1390c1491,1492
<     inline void read_file(const std::string &path, std::string &out) {
<       std::ifstream fs(path, std::ios_base::binary);
<       fs.seekg(0, std::ios_base::end);
<       auto size = fs.tellg();
<       fs.seekg(0);
<       out.resize(static_cast<size_t>(size));
<       fs.read(&out[0], size);
<     }
< 
<     inline std::string file_extension(const std::string &path) {
<       std::smatch m;
<       static auto re = std::regex("\\.([a-zA-Z0-9]+)$");
<       if (std::regex_search(path, m, re)) {
<         return m[1].str();
<       }
<       return std::string();
<     }
< 
<     template <class Fn>
<     void split(const char *b, const char *e, char d, Fn fn) {
<       int i = 0;
<       int beg = 0;
< 
<       while (e ? (b + i != e) : (b[i] != '\0')) {
<         if (b[i] == d) {
<           fn(&b[beg], &b[i]);
<           beg = i + 1;
<         }
<         i++;
<       }
---
>     auto len = i - beg;
>     assert(len > 0);
1392,1394c1494,1500
<       if (i) {
<         fn(&b[beg], &b[i]);
<       }
---
>     if (!path.compare(beg, len, ".")) {
>       ;
>     } else if (!path.compare(beg, len, "..")) {
>       if (level == 0) { return false; }
>       level--;
>     } else {
>       level++;
1397,1402c1503,1507
<     // NOTE: until the read size reaches `fixed_buffer_size`, use `fixed_buffer`
<     // to store data. The call can set memory on stack for performance.
<     class stream_line_reader {
<      public:
<       stream_line_reader(Stream &strm, char *fixed_buffer, size_t fixed_buffer_size) :
<           strm_(strm), fixed_buffer_(fixed_buffer), fixed_buffer_size_(fixed_buffer_size) {}
---
>     // Skip slash
>     while (i < path.size() && path[i] == '/') {
>       i++;
>     }
>   }
1404,1410c1509,1510
<       const char *ptr() const {
<         if (glowable_buffer_.empty()) {
<           return fixed_buffer_;
<         } else {
<           return glowable_buffer_.data();
<         }
<       }
---
>   return true;
> }
1412,1418c1512,1519
<       size_t size() const {
<         if (glowable_buffer_.empty()) {
<           return fixed_buffer_used_size_;
<         } else {
<           return glowable_buffer_.size();
<         }
<       }
---
> inline void read_file(const std::string &path, std::string &out) {
>   std::ifstream fs(path, std::ios_base::binary);
>   fs.seekg(0, std::ios_base::end);
>   auto size = fs.tellg();
>   fs.seekg(0);
>   out.resize(static_cast<size_t>(size));
>   fs.read(&out[0], size);
> }
1420,1423c1521,1526
<       bool end_with_crlf() const {
<         auto end = ptr() + size();
<         return size() >= 2 && end[-2] == '\r' && end[-1] == '\n';
<       }
---
> inline std::string file_extension(const std::string &path) {
>   std::smatch m;
>   static auto re = std::regex("\\.([a-zA-Z0-9]+)$");
>   if (std::regex_search(path, m, re)) { return m[1].str(); }
>   return std::string();
> }
1425,1427c1528,1530
<       bool getline() {
<         fixed_buffer_used_size_ = 0;
<         glowable_buffer_.clear();
---
> template <class Fn> void split(const char *b, const char *e, char d, Fn fn) {
>   int i = 0;
>   int beg = 0;
1429,1431c1532,1538
<         for (size_t i = 0;; i++) {
<           char byte;
<           auto n = strm_.read(&byte, 1);
---
>   while (e ? (b + i != e) : (b[i] != '\0')) {
>     if (b[i] == d) {
>       fn(&b[beg], &b[i]);
>       beg = i + 1;
>     }
>     i++;
>   }
1433,1441c1540,1541
<           if (n < 0) {
<             return false;
<           } else if (n == 0) {
<             if (i == 0) {
<               return false;
<             } else {
<               break;
<             }
<           }
---
>   if (i) { fn(&b[beg], &b[i]); }
> }
1443c1543,1557
<           append(byte);
---
> // NOTE: until the read size reaches `fixed_buffer_size`, use `fixed_buffer`
> // to store data. The call can set memory on stack for performance.
> class stream_line_reader {
> public:
>   stream_line_reader(Stream &strm, char *fixed_buffer, size_t fixed_buffer_size)
>       : strm_(strm), fixed_buffer_(fixed_buffer),
>         fixed_buffer_size_(fixed_buffer_size) {}
> 
>   const char *ptr() const {
>     if (glowable_buffer_.empty()) {
>       return fixed_buffer_;
>     } else {
>       return glowable_buffer_.data();
>     }
>   }
1445,1448c1559,1565
<           if (byte == '\n') {
<             break;
<           }
<         }
---
>   size_t size() const {
>     if (glowable_buffer_.empty()) {
>       return fixed_buffer_used_size_;
>     } else {
>       return glowable_buffer_.size();
>     }
>   }
1450,1451c1567,1574
<         return true;
<       }
---
>   bool end_with_crlf() const {
>     auto end = ptr() + size();
>     return size() >= 2 && end[-2] == '\r' && end[-1] == '\n';
>   }
> 
>   bool getline() {
>     fixed_buffer_used_size_ = 0;
>     glowable_buffer_.clear();
1453,1457c1576,1584
<      private:
<       void append(char c) {
<         if (fixed_buffer_used_size_ < fixed_buffer_size_ - 1) {
<           fixed_buffer_[fixed_buffer_used_size_++] = c;
<           fixed_buffer_[fixed_buffer_used_size_] = '\0';
---
>     for (size_t i = 0;; i++) {
>       char byte;
>       auto n = strm_.read(&byte, 1);
> 
>       if (n < 0) {
>         return false;
>       } else if (n == 0) {
>         if (i == 0) {
>           return false;
1459,1463c1586
<           if (glowable_buffer_.empty()) {
<             assert(fixed_buffer_[fixed_buffer_used_size_] == '\0');
<             glowable_buffer_.assign(fixed_buffer_, fixed_buffer_used_size_);
<           }
<           glowable_buffer_ += c;
---
>           break;
1467,1472c1590
<       Stream &strm_;
<       char *fixed_buffer_;
<       const size_t fixed_buffer_size_;
<       size_t fixed_buffer_used_size_ = 0;
<       std::string glowable_buffer_;
<     };
---
>       append(byte);
1474,1479c1592
<     inline int close_socket(socket_t sock) {
< #ifdef _WIN32
<       return closesocket(sock);
< #else
<       return close(sock);
< #endif
---
>       if (byte == '\n') { break; }
1482,1490c1595,1606
<     template <typename T>
<     inline ssize_t handle_EINTR(T fn) {
<       ssize_t res = false;
<       while (true) {
<         res = fn();
<         if (res < 0 && errno == EINTR) {
<           continue;
<         }
<         break;
---
>     return true;
>   }
> 
> private:
>   void append(char c) {
>     if (fixed_buffer_used_size_ < fixed_buffer_size_ - 1) {
>       fixed_buffer_[fixed_buffer_used_size_++] = c;
>       fixed_buffer_[fixed_buffer_used_size_] = '\0';
>     } else {
>       if (glowable_buffer_.empty()) {
>         assert(fixed_buffer_[fixed_buffer_used_size_] == '\0');
>         glowable_buffer_.assign(fixed_buffer_, fixed_buffer_used_size_);
1492c1608
<       return res;
---
>       glowable_buffer_ += c;
1493a1610,1617
>   }
> 
>   Stream &strm_;
>   char *fixed_buffer_;
>   const size_t fixed_buffer_size_;
>   size_t fixed_buffer_used_size_ = 0;
>   std::string glowable_buffer_;
> };
1495c1619,1625
< #define HANDLE_EINTR(method, ...) (handle_EINTR([&]() { return method(__VA_ARGS__); }))
---
> inline int close_socket(socket_t sock) {
> #ifdef _WIN32
>   return closesocket(sock);
> #else
>   return close(sock);
> #endif
> }
1497c1627,1640
<     inline ssize_t select_read(socket_t sock, time_t sec, time_t usec) {
---
> template <typename T> inline ssize_t handle_EINTR(T fn) {
>   ssize_t res = false;
>   while (true) {
>     res = fn();
>     if (res < 0 && errno == EINTR) { continue; }
>     break;
>   }
>   return res;
> }
> 
> #define HANDLE_EINTR(method, ...)                                              \
>   (handle_EINTR([&]() { return method(__VA_ARGS__); }))
> 
> inline ssize_t select_read(socket_t sock, time_t sec, time_t usec) {
1499,1501c1642,1644
<       struct pollfd pfd_read;
<       pfd_read.fd = sock;
<       pfd_read.events = POLLIN;
---
>   struct pollfd pfd_read;
>   pfd_read.fd = sock;
>   pfd_read.events = POLLIN;
1503c1646
<       auto timeout = static_cast<int>(sec * 1000 + usec / 1000);
---
>   auto timeout = static_cast<int>(sec * 1000 + usec / 1000);
1505c1648
<       return HANDLE_EINTR(poll, &pfd_read, 1, timeout);
---
>   return HANDLE_EINTR(poll, &pfd_read, 1, timeout);
1507,1513c1650,1656
<       fd_set fds;
<       FD_ZERO(&fds);
<       FD_SET(sock, &fds);
< 
<       timeval tv;
<       tv.tv_sec = static_cast<long>(sec);
<       tv.tv_usec = static_cast<decltype(tv.tv_usec)>(usec);
---
>   fd_set fds;
>   FD_ZERO(&fds);
>   FD_SET(sock, &fds);
> 
>   timeval tv;
>   tv.tv_sec = static_cast<long>(sec);
>   tv.tv_usec = static_cast<decltype(tv.tv_usec)>(usec);
1515c1658,1659
<       return HANDLE_EINTR(select, static_cast<int>(sock + 1), &fds, nullptr, nullptr, &tv);
---
>   return HANDLE_EINTR(select, static_cast<int>(sock + 1), &fds, nullptr,
>                       nullptr, &tv);
1517c1661
<     }
---
> }
1519c1663
<     inline ssize_t select_write(socket_t sock, time_t sec, time_t usec) {
---
> inline ssize_t select_write(socket_t sock, time_t sec, time_t usec) {
1521,1523c1665,1667
<       struct pollfd pfd_read;
<       pfd_read.fd = sock;
<       pfd_read.events = POLLOUT;
---
>   struct pollfd pfd_read;
>   pfd_read.fd = sock;
>   pfd_read.events = POLLOUT;
1525c1669
<       auto timeout = static_cast<int>(sec * 1000 + usec / 1000);
---
>   auto timeout = static_cast<int>(sec * 1000 + usec / 1000);
1527c1671
<       return HANDLE_EINTR(poll, &pfd_read, 1, timeout);
---
>   return HANDLE_EINTR(poll, &pfd_read, 1, timeout);
1529,1535c1673,1679
<       fd_set fds;
<       FD_ZERO(&fds);
<       FD_SET(sock, &fds);
< 
<       timeval tv;
<       tv.tv_sec = static_cast<long>(sec);
<       tv.tv_usec = static_cast<decltype(tv.tv_usec)>(usec);
---
>   fd_set fds;
>   FD_ZERO(&fds);
>   FD_SET(sock, &fds);
> 
>   timeval tv;
>   tv.tv_sec = static_cast<long>(sec);
>   tv.tv_usec = static_cast<decltype(tv.tv_usec)>(usec);
1537c1681,1682
<       return HANDLE_EINTR(select, static_cast<int>(sock + 1), nullptr, &fds, nullptr, &tv);
---
>   return HANDLE_EINTR(select, static_cast<int>(sock + 1), nullptr, &fds,
>                       nullptr, &tv);
1539c1684
<     }
---
> }
1541c1686
<     inline bool wait_until_socket_is_ready(socket_t sock, time_t sec, time_t usec) {
---
> inline bool wait_until_socket_is_ready(socket_t sock, time_t sec, time_t usec) {
1543,1556c1688,1702
<       struct pollfd pfd_read;
<       pfd_read.fd = sock;
<       pfd_read.events = POLLIN | POLLOUT;
< 
<       auto timeout = static_cast<int>(sec * 1000 + usec / 1000);
< 
<       auto poll_res = HANDLE_EINTR(poll, &pfd_read, 1, timeout);
<       if (poll_res > 0 && pfd_read.revents & (POLLIN | POLLOUT)) {
<         int error = 0;
<         socklen_t len = sizeof(error);
<         auto res = getsockopt(sock, SOL_SOCKET, SO_ERROR, reinterpret_cast<char *>(&error), &len);
<         return res >= 0 && !error;
<       }
<       return false;
---
>   struct pollfd pfd_read;
>   pfd_read.fd = sock;
>   pfd_read.events = POLLIN | POLLOUT;
> 
>   auto timeout = static_cast<int>(sec * 1000 + usec / 1000);
> 
>   auto poll_res = HANDLE_EINTR(poll, &pfd_read, 1, timeout);
>   if (poll_res > 0 && pfd_read.revents & (POLLIN | POLLOUT)) {
>     int error = 0;
>     socklen_t len = sizeof(error);
>     auto res = getsockopt(sock, SOL_SOCKET, SO_ERROR,
>                           reinterpret_cast<char *>(&error), &len);
>     return res >= 0 && !error;
>   }
>   return false;
1558,1575c1704,1724
<       fd_set fdsr;
<       FD_ZERO(&fdsr);
<       FD_SET(sock, &fdsr);
< 
<       auto fdsw = fdsr;
<       auto fdse = fdsr;
< 
<       timeval tv;
<       tv.tv_sec = static_cast<long>(sec);
<       tv.tv_usec = static_cast<decltype(tv.tv_usec)>(usec);
< 
<       if (HANDLE_EINTR(select, static_cast<int>(sock + 1), &fdsr, &fdsw, &fdse, &tv) > 0
<           && (FD_ISSET(sock, &fdsr) || FD_ISSET(sock, &fdsw))) {
<         int error = 0;
<         socklen_t len = sizeof(error);
<         return getsockopt(sock, SOL_SOCKET, SO_ERROR, reinterpret_cast<char *>(&error), &len) >= 0 && !error;
<       }
<       return false;
---
>   fd_set fdsr;
>   FD_ZERO(&fdsr);
>   FD_SET(sock, &fdsr);
> 
>   auto fdsw = fdsr;
>   auto fdse = fdsr;
> 
>   timeval tv;
>   tv.tv_sec = static_cast<long>(sec);
>   tv.tv_usec = static_cast<decltype(tv.tv_usec)>(usec);
> 
>   if (HANDLE_EINTR(select, static_cast<int>(sock + 1), &fdsr, &fdsw, &fdse,
>                    &tv) > 0 &&
>       (FD_ISSET(sock, &fdsr) || FD_ISSET(sock, &fdsw))) {
>     int error = 0;
>     socklen_t len = sizeof(error);
>     return getsockopt(sock, SOL_SOCKET, SO_ERROR,
>                       reinterpret_cast<char *>(&error), &len) >= 0 &&
>            !error;
>   }
>   return false;
1577c1726
<     }
---
> }
1579,1597c1728,1746
<     class SocketStream : public Stream {
<      public:
<       SocketStream(socket_t sock, time_t read_timeout_sec, time_t read_timeout_usec, time_t write_timeout_sec,
<                    time_t write_timeout_usec);
<       ~SocketStream() override;
< 
<       bool is_readable() const override;
<       bool is_writable() const override;
<       ssize_t read(char *ptr, size_t size) override;
<       ssize_t write(const char *ptr, size_t size) override;
<       void get_remote_ip_and_port(std::string &ip, int &port) const override;
< 
<      private:
<       socket_t sock_;
<       time_t read_timeout_sec_;
<       time_t read_timeout_usec_;
<       time_t write_timeout_sec_;
<       time_t write_timeout_usec_;
<     };
---
> class SocketStream : public Stream {
> public:
>   SocketStream(socket_t sock, time_t read_timeout_sec, time_t read_timeout_usec,
>                time_t write_timeout_sec, time_t write_timeout_usec);
>   ~SocketStream() override;
> 
>   bool is_readable() const override;
>   bool is_writable() const override;
>   ssize_t read(char *ptr, size_t size) override;
>   ssize_t write(const char *ptr, size_t size) override;
>   void get_remote_ip_and_port(std::string &ip, int &port) const override;
> 
> private:
>   socket_t sock_;
>   time_t read_timeout_sec_;
>   time_t read_timeout_usec_;
>   time_t write_timeout_sec_;
>   time_t write_timeout_usec_;
> };
1600,1667c1749,1820
<     class SSLSocketStream : public Stream {
<      public:
<       SSLSocketStream(socket_t sock, SSL *ssl, time_t read_timeout_sec, time_t read_timeout_usec, time_t write_timeout_sec,
<                       time_t write_timeout_usec);
<       ~SSLSocketStream() override;
< 
<       bool is_readable() const override;
<       bool is_writable() const override;
<       ssize_t read(char *ptr, size_t size) override;
<       ssize_t write(const char *ptr, size_t size) override;
<       void get_remote_ip_and_port(std::string &ip, int &port) const override;
< 
<      private:
<       socket_t sock_;
<       SSL *ssl_;
<       time_t read_timeout_sec_;
<       time_t read_timeout_usec_;
<       time_t write_timeout_sec_;
<       time_t write_timeout_usec_;
<     };
< #endif
< 
<     class BufferStream : public Stream {
<      public:
<       BufferStream() = default;
<       ~BufferStream() override = default;
< 
<       bool is_readable() const override;
<       bool is_writable() const override;
<       ssize_t read(char *ptr, size_t size) override;
<       ssize_t write(const char *ptr, size_t size) override;
<       void get_remote_ip_and_port(std::string &ip, int &port) const override;
< 
<       const std::string &get_buffer() const;
< 
<      private:
<       std::string buffer;
<       size_t position = 0;
<     };
< 
<     template <typename T>
<     inline bool process_socket(bool is_client_request, socket_t sock, size_t keep_alive_max_count, time_t read_timeout_sec,
<                                time_t read_timeout_usec, time_t write_timeout_sec, time_t write_timeout_usec, T callback) {
<       assert(keep_alive_max_count > 0);
< 
<       auto ret = false;
< 
<       if (keep_alive_max_count > 1) {
<         auto count = keep_alive_max_count;
<         while (count > 0
<                && (is_client_request
<                    || select_read(sock, CPPHTTPLIB_KEEPALIVE_TIMEOUT_SECOND, CPPHTTPLIB_KEEPALIVE_TIMEOUT_USECOND) > 0)) {
<           SocketStream strm(sock, read_timeout_sec, read_timeout_usec, write_timeout_sec, write_timeout_usec);
<           auto last_connection = count == 1;
<           auto connection_close = false;
< 
<           ret = callback(strm, last_connection, connection_close);
<           if (!ret || connection_close) {
<             break;
<           }
< 
<           count--;
<         }
<       } else {  // keep_alive_max_count  is 0 or 1
<         SocketStream strm(sock, read_timeout_sec, read_timeout_usec, write_timeout_sec, write_timeout_usec);
<         auto dummy_connection_close = false;
<         ret = callback(strm, true, dummy_connection_close);
<       }
---
> class SSLSocketStream : public Stream {
> public:
>   SSLSocketStream(socket_t sock, SSL *ssl, time_t read_timeout_sec,
>                   time_t read_timeout_usec, time_t write_timeout_sec,
>                   time_t write_timeout_usec);
>   ~SSLSocketStream() override;
> 
>   bool is_readable() const override;
>   bool is_writable() const override;
>   ssize_t read(char *ptr, size_t size) override;
>   ssize_t write(const char *ptr, size_t size) override;
>   void get_remote_ip_and_port(std::string &ip, int &port) const override;
> 
> private:
>   socket_t sock_;
>   SSL *ssl_;
>   time_t read_timeout_sec_;
>   time_t read_timeout_usec_;
>   time_t write_timeout_sec_;
>   time_t write_timeout_usec_;
> };
> #endif
> 
> class BufferStream : public Stream {
> public:
>   BufferStream() = default;
>   ~BufferStream() override = default;
> 
>   bool is_readable() const override;
>   bool is_writable() const override;
>   ssize_t read(char *ptr, size_t size) override;
>   ssize_t write(const char *ptr, size_t size) override;
>   void get_remote_ip_and_port(std::string &ip, int &port) const override;
> 
>   const std::string &get_buffer() const;
> 
> private:
>   std::string buffer;
>   size_t position = 0;
> };
> 
> template <typename T>
> inline bool process_socket(bool is_client_request, socket_t sock,
>                            size_t keep_alive_max_count, time_t read_timeout_sec,
>                            time_t read_timeout_usec, time_t write_timeout_sec,
>                            time_t write_timeout_usec, T callback) {
>   assert(keep_alive_max_count > 0);
> 
>   auto ret = false;
> 
>   if (keep_alive_max_count > 1) {
>     auto count = keep_alive_max_count;
>     while (count > 0 &&
>            (is_client_request ||
>             select_read(sock, CPPHTTPLIB_KEEPALIVE_TIMEOUT_SECOND,
>                         CPPHTTPLIB_KEEPALIVE_TIMEOUT_USECOND) > 0)) {
>       SocketStream strm(sock, read_timeout_sec, read_timeout_usec,
>                         write_timeout_sec, write_timeout_usec);
>       auto last_connection = count == 1;
>       auto connection_close = false;
> 
>       ret = callback(strm, last_connection, connection_close);
>       if (!ret || connection_close) { break; }
> 
>       count--;
>     }
>   } else { // keep_alive_max_count  is 0 or 1
>     SocketStream strm(sock, read_timeout_sec, read_timeout_usec,
>                       write_timeout_sec, write_timeout_usec);
>     auto dummy_connection_close = false;
>     ret = callback(strm, true, dummy_connection_close);
>   }
1669,1670c1822,1823
<       return ret;
<     }
---
>   return ret;
> }
1672,1680c1825,1836
<     template <typename T>
<     inline bool process_and_close_socket(bool is_client_request, socket_t sock, size_t keep_alive_max_count,
<                                          time_t read_timeout_sec, time_t read_timeout_usec, time_t write_timeout_sec,
<                                          time_t write_timeout_usec, T callback) {
<       auto ret = process_socket(is_client_request, sock, keep_alive_max_count, read_timeout_sec, read_timeout_usec,
<                                 write_timeout_sec, write_timeout_usec, callback);
<       close_socket(sock);
<       return ret;
<     }
---
> template <typename T>
> inline bool
> process_and_close_socket(bool is_client_request, socket_t sock,
>                          size_t keep_alive_max_count, time_t read_timeout_sec,
>                          time_t read_timeout_usec, time_t write_timeout_sec,
>                          time_t write_timeout_usec, T callback) {
>   auto ret = process_socket(is_client_request, sock, keep_alive_max_count,
>                             read_timeout_sec, read_timeout_usec,
>                             write_timeout_sec, write_timeout_usec, callback);
>   close_socket(sock);
>   return ret;
> }
1682c1838
<     inline int shutdown_socket(socket_t sock) {
---
> inline int shutdown_socket(socket_t sock) {
1684c1840
<       return shutdown(sock, SD_BOTH);
---
>   return shutdown(sock, SD_BOTH);
1686c1842
<       return shutdown(sock, SHUT_RDWR);
---
>   return shutdown(sock, SHUT_RDWR);
1688,1694c1844
<     }
< 
<     template <typename Fn>
<     socket_t create_socket(const char *host, int port, Fn fn, int socket_flags = 0) {
<       // Get address info
<       struct addrinfo hints;
<       struct addrinfo *result;
---
> }
1696,1700c1846,1857
<       memset(&hints, 0, sizeof(struct addrinfo));
<       hints.ai_family = AF_UNSPEC;
<       hints.ai_socktype = SOCK_STREAM;
<       hints.ai_flags = socket_flags;
<       hints.ai_protocol = 0;
---
> template <typename Fn>
> socket_t create_socket(const char *host, int port, Fn fn,
>                        int socket_flags = 0) {
>   // Get address info
>   struct addrinfo hints;
>   struct addrinfo *result;
> 
>   memset(&hints, 0, sizeof(struct addrinfo));
>   hints.ai_family = AF_UNSPEC;
>   hints.ai_socktype = SOCK_STREAM;
>   hints.ai_flags = socket_flags;
>   hints.ai_protocol = 0;
1702c1859
<       auto service = std::to_string(port);
---
>   auto service = std::to_string(port);
1704,1706c1861,1863
<       if (getaddrinfo(host, service.c_str(), &hints, &result)) {
<         return INVALID_SOCKET;
<       }
---
>   if (getaddrinfo(host, service.c_str(), &hints, &result)) {
>     return INVALID_SOCKET;
>   }
1708,1709c1865,1866
<       for (auto rp = result; rp; rp = rp->ai_next) {
<         // Create a socket
---
>   for (auto rp = result; rp; rp = rp->ai_next) {
>     // Create a socket
1711,1728c1868,1886
<         auto sock = WSASocketW(rp->ai_family, rp->ai_socktype, rp->ai_protocol, nullptr, 0, WSA_FLAG_NO_HANDLE_INHERIT);
<         /**
<          * Since the WSA_FLAG_NO_HANDLE_INHERIT is only supported on Windows 7 SP1
<          * and above the socket creation fails on older Windows Systems.
<          *
<          * Let's try to create a socket the old way in this case.
<          *
<          * Reference:
<          * https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasocketa
<          *
<          * WSA_FLAG_NO_HANDLE_INHERIT:
<          * This flag is supported on Windows 7 with SP1, Windows Server 2008 R2 with
<          * SP1, and later
<          *
<          */
<         if (sock == INVALID_SOCKET) {
<           sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
<         }
---
>     auto sock = WSASocketW(rp->ai_family, rp->ai_socktype, rp->ai_protocol,
>                            nullptr, 0, WSA_FLAG_NO_HANDLE_INHERIT);
>     /**
>      * Since the WSA_FLAG_NO_HANDLE_INHERIT is only supported on Windows 7 SP1
>      * and above the socket creation fails on older Windows Systems.
>      *
>      * Let's try to create a socket the old way in this case.
>      *
>      * Reference:
>      * https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasocketa
>      *
>      * WSA_FLAG_NO_HANDLE_INHERIT:
>      * This flag is supported on Windows 7 with SP1, Windows Server 2008 R2 with
>      * SP1, and later
>      *
>      */
>     if (sock == INVALID_SOCKET) {
>       sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
>     }
1730c1888
<         auto sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
---
>     auto sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
1732,1734c1890
<         if (sock == INVALID_SOCKET) {
<           continue;
<         }
---
>     if (sock == INVALID_SOCKET) { continue; }
1737,1739c1893
<         if (fcntl(sock, F_SETFD, FD_CLOEXEC) == -1) {
<           continue;
<         }
---
>     if (fcntl(sock, F_SETFD, FD_CLOEXEC) == -1) { continue; }
1742,1744c1896,1899
<         // Make 'reuse address' option available
<         int yes = 1;
<         setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<char *>(&yes), sizeof(yes));
---
>     // Make 'reuse address' option available
>     int yes = 1;
>     setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<char *>(&yes),
>                sizeof(yes));
1747c1902,1903
<         setsockopt(sock, SOL_SOCKET, SO_REUSEPORT, reinterpret_cast<char *>(&yes), sizeof(yes));
---
>     setsockopt(sock, SOL_SOCKET, SO_REUSEPORT, reinterpret_cast<char *>(&yes),
>                sizeof(yes));
1750,1762c1906,1910
<         if (rp->ai_family == AF_INET6) {
<           int no = 0;
<           setsockopt(sock, IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<char *>(&no), sizeof(no));
<         }
< 
<         // bind or connect
<         if (fn(sock, *rp)) {
<           freeaddrinfo(result);
<           return sock;
<         }
< 
<         close_socket(sock);
<       }
---
>     if (rp->ai_family == AF_INET6) {
>       int no = 0;
>       setsockopt(sock, IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<char *>(&no),
>                  sizeof(no));
>     }
1763a1912,1913
>     // bind or connect
>     if (fn(sock, *rp)) {
1765c1915
<       return INVALID_SOCKET;
---
>       return sock;
1768c1918,1925
<     inline void set_nonblocking(socket_t sock, bool nonblocking) {
---
>     close_socket(sock);
>   }
> 
>   freeaddrinfo(result);
>   return INVALID_SOCKET;
> }
> 
> inline void set_nonblocking(socket_t sock, bool nonblocking) {
1770,1771c1927,1928
<       auto flags = nonblocking ? 1UL : 0UL;
<       ioctlsocket(sock, FIONBIO, &flags);
---
>   auto flags = nonblocking ? 1UL : 0UL;
>   ioctlsocket(sock, FIONBIO, &flags);
1773,1774c1930,1932
<       auto flags = fcntl(sock, F_GETFL, 0);
<       fcntl(sock, F_SETFL, nonblocking ? (flags | O_NONBLOCK) : (flags & (~O_NONBLOCK)));
---
>   auto flags = fcntl(sock, F_GETFL, 0);
>   fcntl(sock, F_SETFL,
>         nonblocking ? (flags | O_NONBLOCK) : (flags & (~O_NONBLOCK)));
1776c1934
<     }
---
> }
1778c1936
<     inline bool is_connection_error() {
---
> inline bool is_connection_error() {
1780c1938
<       return WSAGetLastError() != WSAEWOULDBLOCK;
---
>   return WSAGetLastError() != WSAEWOULDBLOCK;
1782c1940
<       return errno != EINPROGRESS;
---
>   return errno != EINPROGRESS;
1784,1788c1942
<     }
< 
<     inline bool bind_ip_address(socket_t sock, const char *host) {
<       struct addrinfo hints;
<       struct addrinfo *result;
---
> }
1790,1793c1944,1946
<       memset(&hints, 0, sizeof(struct addrinfo));
<       hints.ai_family = AF_UNSPEC;
<       hints.ai_socktype = SOCK_STREAM;
<       hints.ai_protocol = 0;
---
> inline bool bind_ip_address(socket_t sock, const char *host) {
>   struct addrinfo hints;
>   struct addrinfo *result;
1795,1797c1948,1951
<       if (getaddrinfo(host, "0", &hints, &result)) {
<         return false;
<       }
---
>   memset(&hints, 0, sizeof(struct addrinfo));
>   hints.ai_family = AF_UNSPEC;
>   hints.ai_socktype = SOCK_STREAM;
>   hints.ai_protocol = 0;
1799,1806c1953
<       auto ret = false;
<       for (auto rp = result; rp; rp = rp->ai_next) {
<         const auto &ai = *rp;
<         if (!::bind(sock, ai.ai_addr, static_cast<socklen_t>(ai.ai_addrlen))) {
<           ret = true;
<           break;
<         }
<       }
---
>   if (getaddrinfo(host, "0", &hints, &result)) { return false; }
1808,1809c1955,1960
<       freeaddrinfo(result);
<       return ret;
---
>   auto ret = false;
>   for (auto rp = result; rp; rp = rp->ai_next) {
>     const auto &ai = *rp;
>     if (!::bind(sock, ai.ai_addr, static_cast<socklen_t>(ai.ai_addrlen))) {
>       ret = true;
>       break;
1810a1962
>   }
1812,1825c1964,1979
< #if !defined(_WIN32) && !defined(__SWITCH__)
<     inline std::string if2ip(const std::string &ifn) {
<       struct ifaddrs *ifap;
<       getifaddrs(&ifap);
<       for (auto ifa = ifap; ifa; ifa = ifa->ifa_next) {
<         if (ifa->ifa_addr && ifn == ifa->ifa_name) {
<           if (ifa->ifa_addr->sa_family == AF_INET) {
<             auto sa = reinterpret_cast<struct sockaddr_in *>(ifa->ifa_addr);
<             char buf[INET_ADDRSTRLEN];
<             if (inet_ntop(AF_INET, &sa->sin_addr, buf, INET_ADDRSTRLEN)) {
<               freeifaddrs(ifap);
<               return std::string(buf, INET_ADDRSTRLEN);
<             }
<           }
---
>   freeaddrinfo(result);
>   return ret;
> }
> 
> #ifndef _WIN32
> inline std::string if2ip(const std::string &ifn) {
>   struct ifaddrs *ifap;
>   getifaddrs(&ifap);
>   for (auto ifa = ifap; ifa; ifa = ifa->ifa_next) {
>     if (ifa->ifa_addr && ifn == ifa->ifa_name) {
>       if (ifa->ifa_addr->sa_family == AF_INET) {
>         auto sa = reinterpret_cast<struct sockaddr_in *>(ifa->ifa_addr);
>         char buf[INET_ADDRSTRLEN];
>         if (inet_ntop(AF_INET, &sa->sin_addr, buf, INET_ADDRSTRLEN)) {
>           freeifaddrs(ifap);
>           return std::string(buf, INET_ADDRSTRLEN);
1828,1829d1981
<       freeifaddrs(ifap);
<       return std::string();
1830a1983,1986
>   }
>   freeifaddrs(ifap);
>   return std::string();
> }
1833,1835c1989,1993
<     inline socket_t create_client_socket(const char *host, int port, time_t timeout_sec, time_t timeout_usec,
<                                          const std::string &intf) {
<       return create_socket(host, port, [&](socket_t sock, struct addrinfo &ai) -> bool {
---
> inline socket_t create_client_socket(const char *host, int port,
>                                      time_t timeout_sec, time_t timeout_usec,
>                                      const std::string &intf) {
>   return create_socket(
>       host, port, [&](socket_t sock, struct addrinfo &ai) -> bool {
1837c1995
< #if !defined(_WIN32) && !defined(__SWITCH__)
---
> #ifndef _WIN32
1839,1844c1997,1998
<           if (ip.empty()) {
<             ip = intf;
<           }
<           if (!bind_ip_address(sock, ip.c_str())) {
<             return false;
<           }
---
>           if (ip.empty()) { ip = intf; }
>           if (!bind_ip_address(sock, ip.c_str())) { return false; }
1850c2004,2005
<         auto ret = ::connect(sock, ai.ai_addr, static_cast<socklen_t>(ai.ai_addrlen));
---
>         auto ret =
>             ::connect(sock, ai.ai_addr, static_cast<socklen_t>(ai.ai_addrlen));
1852c2007,2008
<           if (is_connection_error() || !wait_until_socket_is_ready(sock, timeout_sec, timeout_usec)) {
---
>           if (is_connection_error() ||
>               !wait_until_socket_is_ready(sock, timeout_sec, timeout_usec)) {
1861,2057c2017
<     }
< 
<     inline void get_remote_ip_and_port(const struct sockaddr_storage &addr, socklen_t addr_len, std::string &ip, int &port) {
<       if (addr.ss_family == AF_INET) {
<         port = ntohs(reinterpret_cast<const struct sockaddr_in *>(&addr)->sin_port);
<       } else if (addr.ss_family == AF_INET6) {
<         port = ntohs(reinterpret_cast<const struct sockaddr_in6 *>(&addr)->sin6_port);
<       }
< 
<       std::array<char, NI_MAXHOST> ipstr {};
<       if (!getnameinfo(reinterpret_cast<const struct sockaddr *>(&addr), addr_len, ipstr.data(),
<                        static_cast<socklen_t>(ipstr.size()), nullptr, 0, NI_NUMERICHOST)) {
<         ip = ipstr.data();
<       }
<     }
< 
<     inline void get_remote_ip_and_port(socket_t sock, std::string &ip, int &port) {
<       struct sockaddr_storage addr;
<       socklen_t addr_len = sizeof(addr);
< 
<       if (!getpeername(sock, reinterpret_cast<struct sockaddr *>(&addr), &addr_len)) {
<         get_remote_ip_and_port(addr, addr_len, ip, port);
<       }
<     }
< 
<     inline const char *find_content_type(const std::string &path, const std::map<std::string, std::string> &user_data) {
<       auto ext = file_extension(path);
< 
<       auto it = user_data.find(ext);
<       if (it != user_data.end()) {
<         return it->second.c_str();
<       }
< 
<       if (ext == "txt") {
<         return "text/plain";
<       } else if (ext == "html" || ext == "htm") {
<         return "text/html";
<       } else if (ext == "css") {
<         return "text/css";
<       } else if (ext == "jpeg" || ext == "jpg") {
<         return "image/jpg";
<       } else if (ext == "png") {
<         return "image/png";
<       } else if (ext == "gif") {
<         return "image/gif";
<       } else if (ext == "svg") {
<         return "image/svg+xml";
<       } else if (ext == "ico") {
<         return "image/x-icon";
<       } else if (ext == "json") {
<         return "application/json";
<       } else if (ext == "pdf") {
<         return "application/pdf";
<       } else if (ext == "js") {
<         return "application/javascript";
<       } else if (ext == "wasm") {
<         return "application/wasm";
<       } else if (ext == "xml") {
<         return "application/xml";
<       } else if (ext == "xhtml") {
<         return "application/xhtml+xml";
<       }
<       return nullptr;
<     }
< 
<     inline const char *status_message(int status) {
<       switch (status) {
<         case 100:
<           return "Continue";
<         case 101:
<           return "Switching Protocol";
<         case 102:
<           return "Processing";
<         case 103:
<           return "Early Hints";
<         case 200:
<           return "OK";
<         case 201:
<           return "Created";
<         case 202:
<           return "Accepted";
<         case 203:
<           return "Non-Authoritative Information";
<         case 204:
<           return "No Content";
<         case 205:
<           return "Reset Content";
<         case 206:
<           return "Partial Content";
<         case 207:
<           return "Multi-Status";
<         case 208:
<           return "Already Reported";
<         case 226:
<           return "IM Used";
<         case 300:
<           return "Multiple Choice";
<         case 301:
<           return "Moved Permanently";
<         case 302:
<           return "Found";
<         case 303:
<           return "See Other";
<         case 304:
<           return "Not Modified";
<         case 305:
<           return "Use Proxy";
<         case 306:
<           return "unused";
<         case 307:
<           return "Temporary Redirect";
<         case 308:
<           return "Permanent Redirect";
<         case 400:
<           return "Bad Request";
<         case 401:
<           return "Unauthorized";
<         case 402:
<           return "Payment Required";
<         case 403:
<           return "Forbidden";
<         case 404:
<           return "Not Found";
<         case 405:
<           return "Method Not Allowed";
<         case 406:
<           return "Not Acceptable";
<         case 407:
<           return "Proxy Authentication Required";
<         case 408:
<           return "Request Timeout";
<         case 409:
<           return "Conflict";
<         case 410:
<           return "Gone";
<         case 411:
<           return "Length Required";
<         case 412:
<           return "Precondition Failed";
<         case 413:
<           return "Payload Too Large";
<         case 414:
<           return "URI Too Long";
<         case 415:
<           return "Unsupported Media Type";
<         case 416:
<           return "Range Not Satisfiable";
<         case 417:
<           return "Expectation Failed";
<         case 418:
<           return "I'm a teapot";
<         case 421:
<           return "Misdirected Request";
<         case 422:
<           return "Unprocessable Entity";
<         case 423:
<           return "Locked";
<         case 424:
<           return "Failed Dependency";
<         case 425:
<           return "Too Early";
<         case 426:
<           return "Upgrade Required";
<         case 428:
<           return "Precondition Required";
<         case 429:
<           return "Too Many Requests";
<         case 431:
<           return "Request Header Fields Too Large";
<         case 451:
<           return "Unavailable For Legal Reasons";
<         case 501:
<           return "Not Implemented";
<         case 502:
<           return "Bad Gateway";
<         case 503:
<           return "Service Unavailable";
<         case 504:
<           return "Gateway Timeout";
<         case 505:
<           return "HTTP Version Not Supported";
<         case 506:
<           return "Variant Also Negotiates";
<         case 507:
<           return "Insufficient Storage";
<         case 508:
<           return "Loop Detected";
<         case 510:
<           return "Not Extended";
<         case 511:
<           return "Network Authentication Required";
< 
<         default:
<         case 500:
<           return "Internal Server Error";
<       }
<     }
---
> }
2059,2063c2019,2027
< #ifdef CPPHTTPLIB_ZLIB_SUPPORT
<     inline bool can_compress(const std::string &content_type) {
<       return !content_type.find("text/") || content_type == "image/svg+xml" || content_type == "application/javascript"
<           || content_type == "application/json" || content_type == "application/xml" || content_type == "application/xhtml+xml";
<     }
---
> inline void get_remote_ip_and_port(const struct sockaddr_storage &addr,
>                                    socklen_t addr_len, std::string &ip,
>                                    int &port) {
>   if (addr.ss_family == AF_INET) {
>     port = ntohs(reinterpret_cast<const struct sockaddr_in *>(&addr)->sin_port);
>   } else if (addr.ss_family == AF_INET6) {
>     port =
>         ntohs(reinterpret_cast<const struct sockaddr_in6 *>(&addr)->sin6_port);
>   }
2065,2069c2029,2035
<     inline bool compress(std::string &content) {
<       z_stream strm;
<       strm.zalloc = Z_NULL;
<       strm.zfree = Z_NULL;
<       strm.opaque = Z_NULL;
---
>   std::array<char, NI_MAXHOST> ipstr{};
>   if (!getnameinfo(reinterpret_cast<const struct sockaddr *>(&addr), addr_len,
>                    ipstr.data(), static_cast<socklen_t>(ipstr.size()), nullptr,
>                    0, NI_NUMERICHOST)) {
>     ip = ipstr.data();
>   }
> }
2071,2074c2037,2045
<       auto ret = deflateInit2(&strm, Z_DEFAULT_COMPRESSION, Z_DEFLATED, 31, 8, Z_DEFAULT_STRATEGY);
<       if (ret != Z_OK) {
<         return false;
<       }
---
> inline void get_remote_ip_and_port(socket_t sock, std::string &ip, int &port) {
>   struct sockaddr_storage addr;
>   socklen_t addr_len = sizeof(addr);
> 
>   if (!getpeername(sock, reinterpret_cast<struct sockaddr *>(&addr),
>                    &addr_len)) {
>     get_remote_ip_and_port(addr, addr_len, ip, port);
>   }
> }
2076,2077c2047,2085
<       strm.avail_in = static_cast<decltype(strm.avail_in)>(content.size());
<       strm.next_in = const_cast<Bytef *>(reinterpret_cast<const Bytef *>(content.data()));
---
> inline const char *
> find_content_type(const std::string &path,
>                   const std::map<std::string, std::string> &user_data) {
>   auto ext = file_extension(path);
> 
>   auto it = user_data.find(ext);
>   if (it != user_data.end()) { return it->second.c_str(); }
> 
>   if (ext == "txt") {
>     return "text/plain";
>   } else if (ext == "html" || ext == "htm") {
>     return "text/html";
>   } else if (ext == "css") {
>     return "text/css";
>   } else if (ext == "jpeg" || ext == "jpg") {
>     return "image/jpg";
>   } else if (ext == "png") {
>     return "image/png";
>   } else if (ext == "gif") {
>     return "image/gif";
>   } else if (ext == "svg") {
>     return "image/svg+xml";
>   } else if (ext == "ico") {
>     return "image/x-icon";
>   } else if (ext == "json") {
>     return "application/json";
>   } else if (ext == "pdf") {
>     return "application/pdf";
>   } else if (ext == "js") {
>     return "application/javascript";
>   } else if (ext == "wasm") {
>     return "application/wasm";
>   } else if (ext == "xml") {
>     return "application/xml";
>   } else if (ext == "xhtml") {
>     return "application/xhtml+xml";
>   }
>   return nullptr;
> }
2079c2087,2150
<       std::string compressed;
---
> inline const char *status_message(int status) {
>   switch (status) {
>   case 100: return "Continue";
>   case 101: return "Switching Protocol";
>   case 102: return "Processing";
>   case 103: return "Early Hints";
>   case 200: return "OK";
>   case 201: return "Created";
>   case 202: return "Accepted";
>   case 203: return "Non-Authoritative Information";
>   case 204: return "No Content";
>   case 205: return "Reset Content";
>   case 206: return "Partial Content";
>   case 207: return "Multi-Status";
>   case 208: return "Already Reported";
>   case 226: return "IM Used";
>   case 300: return "Multiple Choice";
>   case 301: return "Moved Permanently";
>   case 302: return "Found";
>   case 303: return "See Other";
>   case 304: return "Not Modified";
>   case 305: return "Use Proxy";
>   case 306: return "unused";
>   case 307: return "Temporary Redirect";
>   case 308: return "Permanent Redirect";
>   case 400: return "Bad Request";
>   case 401: return "Unauthorized";
>   case 402: return "Payment Required";
>   case 403: return "Forbidden";
>   case 404: return "Not Found";
>   case 405: return "Method Not Allowed";
>   case 406: return "Not Acceptable";
>   case 407: return "Proxy Authentication Required";
>   case 408: return "Request Timeout";
>   case 409: return "Conflict";
>   case 410: return "Gone";
>   case 411: return "Length Required";
>   case 412: return "Precondition Failed";
>   case 413: return "Payload Too Large";
>   case 414: return "URI Too Long";
>   case 415: return "Unsupported Media Type";
>   case 416: return "Range Not Satisfiable";
>   case 417: return "Expectation Failed";
>   case 418: return "I'm a teapot";
>   case 421: return "Misdirected Request";
>   case 422: return "Unprocessable Entity";
>   case 423: return "Locked";
>   case 424: return "Failed Dependency";
>   case 425: return "Too Early";
>   case 426: return "Upgrade Required";
>   case 428: return "Precondition Required";
>   case 429: return "Too Many Requests";
>   case 431: return "Request Header Fields Too Large";
>   case 451: return "Unavailable For Legal Reasons";
>   case 501: return "Not Implemented";
>   case 502: return "Bad Gateway";
>   case 503: return "Service Unavailable";
>   case 504: return "Gateway Timeout";
>   case 505: return "HTTP Version Not Supported";
>   case 506: return "Variant Also Negotiates";
>   case 507: return "Insufficient Storage";
>   case 508: return "Loop Detected";
>   case 510: return "Not Extended";
>   case 511: return "Network Authentication Required";
2081,2088c2152,2155
<       std::array<char, 16384> buff {};
<       do {
<         strm.avail_out = buff.size();
<         strm.next_out = reinterpret_cast<Bytef *>(buff.data());
<         ret = deflate(&strm, Z_FINISH);
<         assert(ret != Z_STREAM_ERROR);
<         compressed.append(buff.data(), buff.size() - strm.avail_out);
<       } while (strm.avail_out == 0);
---
>   default:
>   case 500: return "Internal Server Error";
>   }
> }
2090,2091c2157,2164
<       assert(ret == Z_STREAM_END);
<       assert(strm.avail_in == 0);
---
> #ifdef CPPHTTPLIB_ZLIB_SUPPORT
> inline bool can_compress(const std::string &content_type) {
>   return !content_type.find("text/") || content_type == "image/svg+xml" ||
>          content_type == "application/javascript" ||
>          content_type == "application/json" ||
>          content_type == "application/xml" ||
>          content_type == "application/xhtml+xml";
> }
2093c2166,2189
<       content.swap(compressed);
---
> inline bool compress(std::string &content) {
>   z_stream strm;
>   strm.zalloc = Z_NULL;
>   strm.zfree = Z_NULL;
>   strm.opaque = Z_NULL;
> 
>   auto ret = deflateInit2(&strm, Z_DEFAULT_COMPRESSION, Z_DEFLATED, 31, 8,
>                           Z_DEFAULT_STRATEGY);
>   if (ret != Z_OK) { return false; }
> 
>   strm.avail_in = static_cast<decltype(strm.avail_in)>(content.size());
>   strm.next_in =
>       const_cast<Bytef *>(reinterpret_cast<const Bytef *>(content.data()));
> 
>   std::string compressed;
> 
>   std::array<char, 16384> buff{};
>   do {
>     strm.avail_out = buff.size();
>     strm.next_out = reinterpret_cast<Bytef *>(buff.data());
>     ret = deflate(&strm, Z_FINISH);
>     assert(ret != Z_STREAM_ERROR);
>     compressed.append(buff.data(), buff.size() - strm.avail_out);
>   } while (strm.avail_out == 0);
2095,2097c2191,2192
<       deflateEnd(&strm);
<       return true;
<     }
---
>   assert(ret == Z_STREAM_END);
>   assert(strm.avail_in == 0);
2099,2138c2194
<     class decompressor {
<      public:
<       decompressor() {
<         std::memset(&strm, 0, sizeof(strm));
<         strm.zalloc = Z_NULL;
<         strm.zfree = Z_NULL;
<         strm.opaque = Z_NULL;
< 
<         // 15 is the value of wbits, which should be at the maximum possible value
<         // to ensure that any gzip stream can be decoded. The offset of 32 specifies
<         // that the stream type should be automatically detected either gzip or
<         // deflate.
<         is_valid_ = inflateInit2(&strm, 32 + 15) == Z_OK;
<       }
< 
<       ~decompressor() { inflateEnd(&strm); }
< 
<       bool is_valid() const { return is_valid_; }
< 
<       template <typename T>
<       bool decompress(const char *data, size_t data_length, T callback) {
<         int ret = Z_OK;
< 
<         strm.avail_in = static_cast<decltype(strm.avail_in)>(data_length);
<         strm.next_in = const_cast<Bytef *>(reinterpret_cast<const Bytef *>(data));
< 
<         std::array<char, 16384> buff {};
<         do {
<           strm.avail_out = buff.size();
<           strm.next_out = reinterpret_cast<Bytef *>(buff.data());
< 
<           ret = inflate(&strm, Z_NO_FLUSH);
<           assert(ret != Z_STREAM_ERROR);
<           switch (ret) {
<             case Z_NEED_DICT:
<             case Z_DATA_ERROR:
<             case Z_MEM_ERROR:
<               inflateEnd(&strm);
<               return false;
<           }
---
>   content.swap(compressed);
2140,2143c2196,2198
<           if (!callback(buff.data(), buff.size() - strm.avail_out)) {
<             return false;
<           }
<         } while (strm.avail_out == 0);
---
>   deflateEnd(&strm);
>   return true;
> }
2145c2200,2236
<         return ret == Z_OK || ret == Z_STREAM_END;
---
> class decompressor {
> public:
>   decompressor() {
>     std::memset(&strm, 0, sizeof(strm));
>     strm.zalloc = Z_NULL;
>     strm.zfree = Z_NULL;
>     strm.opaque = Z_NULL;
> 
>     // 15 is the value of wbits, which should be at the maximum possible value
>     // to ensure that any gzip stream can be decoded. The offset of 32 specifies
>     // that the stream type should be automatically detected either gzip or
>     // deflate.
>     is_valid_ = inflateInit2(&strm, 32 + 15) == Z_OK;
>   }
> 
>   ~decompressor() { inflateEnd(&strm); }
> 
>   bool is_valid() const { return is_valid_; }
> 
>   template <typename T>
>   bool decompress(const char *data, size_t data_length, T callback) {
>     int ret = Z_OK;
> 
>     strm.avail_in = static_cast<decltype(strm.avail_in)>(data_length);
>     strm.next_in = const_cast<Bytef *>(reinterpret_cast<const Bytef *>(data));
> 
>     std::array<char, 16384> buff{};
>     do {
>       strm.avail_out = buff.size();
>       strm.next_out = reinterpret_cast<Bytef *>(buff.data());
> 
>       ret = inflate(&strm, Z_NO_FLUSH);
>       assert(ret != Z_STREAM_ERROR);
>       switch (ret) {
>       case Z_NEED_DICT:
>       case Z_DATA_ERROR:
>       case Z_MEM_ERROR: inflateEnd(&strm); return false;
2148,2152c2239,2242
<      private:
<       bool is_valid_;
<       z_stream strm;
<     };
< #endif
---
>       if (!callback(buff.data(), buff.size() - strm.avail_out)) {
>         return false;
>       }
>     } while (strm.avail_out == 0);
2154c2244,2245
<     inline bool has_header(const Headers &headers, const char *key) { return headers.find(key) != headers.end(); }
---
>     return ret == Z_OK || ret == Z_STREAM_END;
>   }
2156,2163c2247,2251
<     inline const char *get_header_value(const Headers &headers, const char *key, size_t id = 0, const char *def = nullptr) {
<       auto it = headers.find(key);
<       std::advance(it, static_cast<int>(id));
<       if (it != headers.end()) {
<         return it->second.c_str();
<       }
<       return def;
<     }
---
> private:
>   bool is_valid_;
>   z_stream strm;
> };
> #endif
2165,2171c2253,2255
<     inline uint64_t get_header_value_uint64(const Headers &headers, const char *key, uint64_t def = 0) {
<       auto it = headers.find(key);
<       if (it != headers.end()) {
<         return std::strtoull(it->second.data(), nullptr, 10);
<       }
<       return def;
<     }
---
> inline bool has_header(const Headers &headers, const char *key) {
>   return headers.find(key) != headers.end();
> }
2173,2176c2257,2263
<     inline bool read_headers(Stream &strm, Headers &headers) {
<       const auto bufsiz = 2048;
<       char buf[bufsiz];
<       stream_line_reader line_reader(strm, buf, bufsiz);
---
> inline const char *get_header_value(const Headers &headers, const char *key,
>                                     size_t id = 0, const char *def = nullptr) {
>   auto it = headers.find(key);
>   std::advance(it, static_cast<int>(id));
>   if (it != headers.end()) { return it->second.c_str(); }
>   return def;
> }
2178,2181c2265,2272
<       for (;;) {
<         if (!line_reader.getline()) {
<           return false;
<         }
---
> inline uint64_t get_header_value_uint64(const Headers &headers, const char *key,
>                                         uint64_t def = 0) {
>   auto it = headers.find(key);
>   if (it != headers.end()) {
>     return std::strtoull(it->second.data(), nullptr, 10);
>   }
>   return def;
> }
2183,2191c2274,2288
<         // Check if the line ends with CRLF.
<         if (line_reader.end_with_crlf()) {
<           // Blank line indicates end of headers.
<           if (line_reader.size() == 2) {
<             break;
<           }
<         } else {
<           continue;  // Skip invalid line.
<         }
---
> inline bool read_headers(Stream &strm, Headers &headers) {
>   const auto bufsiz = 2048;
>   char buf[bufsiz];
>   stream_line_reader line_reader(strm, buf, bufsiz);
> 
>   for (;;) {
>     if (!line_reader.getline()) { return false; }
> 
>     // Check if the line ends with CRLF.
>     if (line_reader.end_with_crlf()) {
>       // Blank line indicates end of headers.
>       if (line_reader.size() == 2) { break; }
>     } else {
>       continue; // Skip invalid line.
>     }
2193,2197c2290,2294
<         // Skip trailing spaces and tabs.
<         auto end = line_reader.ptr() + line_reader.size() - 2;
<         while (line_reader.ptr() < end && (end[-1] == ' ' || end[-1] == '\t')) {
<           end--;
<         }
---
>     // Skip trailing spaces and tabs.
>     auto end = line_reader.ptr() + line_reader.size() - 2;
>     while (line_reader.ptr() < end && (end[-1] == ' ' || end[-1] == '\t')) {
>       end--;
>     }
2199,2211c2296,2300
<         // Horizontal tab and ' ' are considered whitespace and are ignored when on
<         // the left or right side of the header value:
<         //  - https://stackoverflow.com/questions/50179659/
<         //  - https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html
<         static const std::regex re(R"(([^:]+):[\t ]*([^\t ].*))");
< 
<         std::cmatch m;
<         if (std::regex_match(line_reader.ptr(), end, m, re)) {
<           auto key = std::string(m[1]);
<           auto val = std::string(m[2]);
<           headers.emplace(key, val);
<         }
<       }
---
>     // Horizontal tab and ' ' are considered whitespace and are ignored when on
>     // the left or right side of the header value:
>     //  - https://stackoverflow.com/questions/50179659/
>     //  - https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html
>     static const std::regex re(R"(([^:]+):[\t ]*([^\t ].*))");
2213c2302,2306
<       return true;
---
>     std::cmatch m;
>     if (std::regex_match(line_reader.ptr(), end, m, re)) {
>       auto key = std::string(m[1]);
>       auto val = std::string(m[2]);
>       headers.emplace(key, val);
2214a2308
>   }
2216,2217c2310,2311
<     inline bool read_content_with_length(Stream &strm, uint64_t len, Progress progress, ContentReceiver out) {
<       char buf[CPPHTTPLIB_RECV_BUFSIZ];
---
>   return true;
> }
2219,2225c2313,2315
<       uint64_t r = 0;
<       while (r < len) {
<         auto read_len = static_cast<size_t>(len - r);
<         auto n = strm.read(buf, (std::min)(read_len, CPPHTTPLIB_RECV_BUFSIZ));
<         if (n <= 0) {
<           return false;
<         }
---
> inline bool read_content_with_length(Stream &strm, uint64_t len,
>                                      Progress progress, ContentReceiver out) {
>   char buf[CPPHTTPLIB_RECV_BUFSIZ];
2227,2229c2317,2321
<         if (!out(buf, static_cast<size_t>(n))) {
<           return false;
<         }
---
>   uint64_t r = 0;
>   while (r < len) {
>     auto read_len = static_cast<size_t>(len - r);
>     auto n = strm.read(buf, (std::min)(read_len, CPPHTTPLIB_RECV_BUFSIZ));
>     if (n <= 0) { return false; }
2231c2323
<         r += static_cast<uint64_t>(n);
---
>     if (!out(buf, static_cast<size_t>(n))) { return false; }
2233,2238c2325
<         if (progress) {
<           if (!progress(r, len)) {
<             return false;
<           }
<         }
<       }
---
>     r += static_cast<uint64_t>(n);
2240c2327,2328
<       return true;
---
>     if (progress) {
>       if (!progress(r, len)) { return false; }
2241a2330
>   }
2243,2254c2332,2333
<     inline void skip_content_with_length(Stream &strm, uint64_t len) {
<       char buf[CPPHTTPLIB_RECV_BUFSIZ];
<       uint64_t r = 0;
<       while (r < len) {
<         auto read_len = static_cast<size_t>(len - r);
<         auto n = strm.read(buf, (std::min)(read_len, CPPHTTPLIB_RECV_BUFSIZ));
<         if (n <= 0) {
<           return;
<         }
<         r += static_cast<uint64_t>(n);
<       }
<     }
---
>   return true;
> }
2256,2268c2335,2344
<     inline bool read_content_without_length(Stream &strm, ContentReceiver out) {
<       char buf[CPPHTTPLIB_RECV_BUFSIZ];
<       for (;;) {
<         auto n = strm.read(buf, CPPHTTPLIB_RECV_BUFSIZ);
<         if (n < 0) {
<           return false;
<         } else if (n == 0) {
<           return true;
<         }
<         if (!out(buf, static_cast<size_t>(n))) {
<           return false;
<         }
<       }
---
> inline void skip_content_with_length(Stream &strm, uint64_t len) {
>   char buf[CPPHTTPLIB_RECV_BUFSIZ];
>   uint64_t r = 0;
>   while (r < len) {
>     auto read_len = static_cast<size_t>(len - r);
>     auto n = strm.read(buf, (std::min)(read_len, CPPHTTPLIB_RECV_BUFSIZ));
>     if (n <= 0) { return; }
>     r += static_cast<uint64_t>(n);
>   }
> }
2269a2346,2352
> inline bool read_content_without_length(Stream &strm, ContentReceiver out) {
>   char buf[CPPHTTPLIB_RECV_BUFSIZ];
>   for (;;) {
>     auto n = strm.read(buf, CPPHTTPLIB_RECV_BUFSIZ);
>     if (n < 0) {
>       return false;
>     } else if (n == 0) {
2271a2355,2356
>     if (!out(buf, static_cast<size_t>(n))) { return false; }
>   }
2273,2275c2358,2359
<     inline bool read_content_chunked(Stream &strm, ContentReceiver out) {
<       const auto bufsiz = 16;
<       char buf[bufsiz];
---
>   return true;
> }
2277c2361,2363
<       stream_line_reader line_reader(strm, buf, bufsiz);
---
> inline bool read_content_chunked(Stream &strm, ContentReceiver out) {
>   const auto bufsiz = 16;
>   char buf[bufsiz];
2279,2281c2365
<       if (!line_reader.getline()) {
<         return false;
<       }
---
>   stream_line_reader line_reader(strm, buf, bufsiz);
2283,2285c2367
<       unsigned long chunk_len;
<       while (true) {
<         char *end_ptr;
---
>   if (!line_reader.getline()) { return false; }
2287c2369,2371
<         chunk_len = std::strtoul(line_reader.ptr(), &end_ptr, 16);
---
>   unsigned long chunk_len;
>   while (true) {
>     char *end_ptr;
2289,2294c2373
<         if (end_ptr == line_reader.ptr()) {
<           return false;
<         }
<         if (chunk_len == ULONG_MAX) {
<           return false;
<         }
---
>     chunk_len = std::strtoul(line_reader.ptr(), &end_ptr, 16);
2296,2298c2375,2376
<         if (chunk_len == 0) {
<           break;
<         }
---
>     if (end_ptr == line_reader.ptr()) { return false; }
>     if (chunk_len == ULONG_MAX) { return false; }
2300,2302c2378
<         if (!read_content_with_length(strm, chunk_len, nullptr, out)) {
<           return false;
<         }
---
>     if (chunk_len == 0) { break; }
2304,2306c2380,2382
<         if (!line_reader.getline()) {
<           return false;
<         }
---
>     if (!read_content_with_length(strm, chunk_len, nullptr, out)) {
>       return false;
>     }
2308,2310c2384
<         if (strcmp(line_reader.ptr(), "\r\n")) {
<           break;
<         }
---
>     if (!line_reader.getline()) { return false; }
2312,2315c2386
<         if (!line_reader.getline()) {
<           return false;
<         }
<       }
---
>     if (strcmp(line_reader.ptr(), "\r\n")) { break; }
2317,2321c2388,2389
<       if (chunk_len == 0) {
<         // Reader terminator after chunks
<         if (!line_reader.getline() || strcmp(line_reader.ptr(), "\r\n"))
<           return false;
<       }
---
>     if (!line_reader.getline()) { return false; }
>   }
2323,2324c2391,2395
<       return true;
<     }
---
>   if (chunk_len == 0) {
>     // Reader terminator after chunks
>     if (!line_reader.getline() || strcmp(line_reader.ptr(), "\r\n"))
>       return false;
>   }
2326,2328c2397,2398
<     inline bool is_chunked_transfer_encoding(const Headers &headers) {
<       return !strcasecmp(get_header_value(headers, "Transfer-Encoding", 0, ""), "chunked");
<     }
---
>   return true;
> }
2330,2331c2400,2403
<     template <typename T>
<     bool read_content(Stream &strm, T &x, size_t payload_max_length, int &status, Progress progress, ContentReceiver receiver) {
---
> inline bool is_chunked_transfer_encoding(const Headers &headers) {
>   return !strcasecmp(get_header_value(headers, "Transfer-Encoding", 0, ""),
>                      "chunked");
> }
2333c2405,2407
<       ContentReceiver out = [&](const char *buf, size_t n) { return receiver(buf, n); };
---
> template <typename T>
> bool read_content(Stream &strm, T &x, size_t payload_max_length, int &status,
>                   Progress progress, ContentReceiver receiver, bool decompress) {
2335,2336c2409,2411
< #ifdef CPPHTTPLIB_ZLIB_SUPPORT
<       decompressor decompressor;
---
>   ContentReceiver out = [&](const char *buf, size_t n) {
>     return receiver(buf, n);
>   };
2338,2343c2413,2415
<       std::string content_encoding = x.get_header_value("Content-Encoding");
<       if (content_encoding.find("gzip") != std::string::npos || content_encoding.find("deflate") != std::string::npos) {
<         if (!decompressor.is_valid()) {
<           status = 500;
<           return false;
<         }
---
> #ifdef CPPHTTPLIB_ZLIB_SUPPORT
>   decompressor decompressor;
> #endif
2345,2351c2417,2423
<         out = [&](const char *buf, size_t n) {
<           return decompressor.decompress(buf, n, [&](const char *buf, size_t n) { return receiver(buf, n); });
<         };
<       }
< #else
<       if (x.get_header_value("Content-Encoding") == "gzip") {
<         status = 415;
---
>   if (decompress) {
> #ifdef CPPHTTPLIB_ZLIB_SUPPORT
>     std::string content_encoding = x.get_header_value("Content-Encoding");
>     if (content_encoding.find("gzip") != std::string::npos ||
>         content_encoding.find("deflate") != std::string::npos) {
>       if (!decompressor.is_valid()) {
>         status = 500;
2353a2426,2437
> 
>       out = [&](const char *buf, size_t n) {
>         return decompressor.decompress(buf, n, [&](const char *buf, size_t n) {
>           return receiver(buf, n);
>         });
>       };
>     }
> #else
>     if (x.get_header_value("Content-Encoding") == "gzip") {
>       status = 415;
>       return false;
>     }
2354a2439
>   }
2356,2357c2441,2442
<       auto ret = true;
<       auto exceed_payload_max_length = false;
---
>   auto ret = true;
>   auto exceed_payload_max_length = false;
2359,2372c2444,2457
<       if (is_chunked_transfer_encoding(x.headers)) {
<         ret = read_content_chunked(strm, out);
<       } else if (!has_header(x.headers, "Content-Length")) {
<         ret = read_content_without_length(strm, out);
<       } else {
<         auto len = get_header_value_uint64(x.headers, "Content-Length", 0);
<         if (len > payload_max_length) {
<           exceed_payload_max_length = true;
<           skip_content_with_length(strm, len);
<           ret = false;
<         } else if (len > 0) {
<           ret = read_content_with_length(strm, len, progress, out);
<         }
<       }
---
>   if (is_chunked_transfer_encoding(x.headers)) {
>     ret = read_content_chunked(strm, out);
>   } else if (!has_header(x.headers, "Content-Length")) {
>     ret = read_content_without_length(strm, out);
>   } else {
>     auto len = get_header_value_uint64(x.headers, "Content-Length", 0);
>     if (len > payload_max_length) {
>       exceed_payload_max_length = true;
>       skip_content_with_length(strm, len);
>       ret = false;
>     } else if (len > 0) {
>       ret = read_content_with_length(strm, len, progress, out);
>     }
>   }
2374,2376c2459,2495
<       if (!ret) {
<         status = exceed_payload_max_length ? 413 : 400;
<       }
---
>   if (!ret) { status = exceed_payload_max_length ? 413 : 400; }
> 
>   return ret;
> }
> 
> template <typename T>
> inline ssize_t write_headers(Stream &strm, const T &info,
>                              const Headers &headers) {
>   ssize_t write_len = 0;
>   for (const auto &x : info.headers) {
>     if (x.first == "EXCEPTION_WHAT") { continue; }
>     auto len =
>         strm.write_format("%s: %s\r\n", x.first.c_str(), x.second.c_str());
>     if (len < 0) { return len; }
>     write_len += len;
>   }
>   for (const auto &x : headers) {
>     auto len =
>         strm.write_format("%s: %s\r\n", x.first.c_str(), x.second.c_str());
>     if (len < 0) { return len; }
>     write_len += len;
>   }
>   auto len = strm.write("\r\n");
>   if (len < 0) { return len; }
>   write_len += len;
>   return write_len;
> }
> 
> inline bool write_data(Stream &strm, const char *d, size_t l) {
>   size_t offset = 0;
>   while (offset < l) {
>     auto length = strm.write(d + offset, l - offset);
>     if (length < 0) { return false; }
>     offset += static_cast<size_t>(length);
>   }
>   return true;
> }
2378c2497,2508
<       return ret;
---
> inline ssize_t write_content(Stream &strm, ContentProvider content_provider,
>                              size_t offset, size_t length) {
>   size_t begin_offset = offset;
>   size_t end_offset = offset + length;
> 
>   auto ok = true;
> 
>   DataSink data_sink;
>   data_sink.write = [&](const char *d, size_t l) {
>     if (ok) {
>       offset += l;
>       if (!write_data(strm, d, l)) { ok = false; }
2379a2510,2511
>   };
>   data_sink.is_writable = [&](void) { return ok && strm.is_writable(); };
2381,2406c2513,2515
<     template <typename T>
<     inline ssize_t write_headers(Stream &strm, const T &info, const Headers &headers) {
<       ssize_t write_len = 0;
<       for (const auto &x : info.headers) {
<         if (x.first == "EXCEPTION_WHAT") {
<           continue;
<         }
<         auto len = strm.write_format("%s: %s\r\n", x.first.c_str(), x.second.c_str());
<         if (len < 0) {
<           return len;
<         }
<         write_len += len;
<       }
<       for (const auto &x : headers) {
<         auto len = strm.write_format("%s: %s\r\n", x.first.c_str(), x.second.c_str());
<         if (len < 0) {
<           return len;
<         }
<         write_len += len;
<       }
<       auto len = strm.write("\r\n");
<       if (len < 0) {
<         return len;
<       }
<       write_len += len;
<       return write_len;
---
>   while (ok && offset < end_offset) {
>     if (!content_provider(offset, end_offset - offset, data_sink)) {
>       return -1;
2407a2517,2518
>     if (!ok) { return -1; }
>   }
2409,2416c2520,2544
<     inline bool write_data(Stream &strm, const char *d, size_t l) {
<       size_t offset = 0;
<       while (offset < l) {
<         auto length = strm.write(d + offset, l - offset);
<         if (length < 0) {
<           return false;
<         }
<         offset += static_cast<size_t>(length);
---
>   return static_cast<ssize_t>(offset - begin_offset);
> }
> 
> template <typename T>
> inline ssize_t write_content_chunked(Stream &strm,
>                                      ContentProvider content_provider,
>                                      T is_shutting_down) {
>   size_t offset = 0;
>   auto data_available = true;
>   ssize_t total_written_length = 0;
> 
>   auto ok = true;
> 
>   DataSink data_sink;
>   data_sink.write = [&](const char *d, size_t l) {
>     if (ok) {
>       data_available = l > 0;
>       offset += l;
> 
>       // Emit chunked response header and footer for each chunk
>       auto chunk = from_i_to_hex(l) + "\r\n" + std::string(d, l) + "\r\n";
>       if (write_data(strm, chunk.data(), chunk.size())) {
>         total_written_length += chunk.size();
>       } else {
>         ok = false;
2418d2545
<       return true;
2419a2547,2559
>   };
>   data_sink.done = [&](void) {
>     data_available = false;
>     if (ok) {
>       static const std::string done_marker("0\r\n\r\n");
>       if (write_data(strm, done_marker.data(), done_marker.size())) {
>         total_written_length += done_marker.size();
>       } else {
>         ok = false;
>       }
>     }
>   };
>   data_sink.is_writable = [&](void) { return ok && strm.is_writable(); };
2421,2423c2561,2564
<     inline ssize_t write_content(Stream &strm, ContentProvider content_provider, size_t offset, size_t length) {
<       size_t begin_offset = offset;
<       size_t end_offset = offset + length;
---
>   while (data_available && !is_shutting_down()) {
>     if (!content_provider(offset, 0, data_sink)) { return -1; }
>     if (!ok) { return -1; }
>   }
2425c2566,2567
<       auto ok = true;
---
>   return total_written_length;
> }
2427,2436c2569,2587
<       DataSink data_sink;
<       data_sink.write = [&](const char *d, size_t l) {
<         if (ok) {
<           offset += l;
<           if (!write_data(strm, d, l)) {
<             ok = false;
<           }
<         }
<       };
<       data_sink.is_writable = [&](void) { return ok && strm.is_writable(); };
---
> template <typename T>
> inline bool redirect(T &cli, const Request &req, Response &res,
>                      const std::string &path) {
>   Request new_req = req;
>   new_req.path = path;
>   new_req.redirect_count -= 1;
> 
>   if (res.status == 303 && (req.method != "GET" && req.method != "HEAD")) {
>     new_req.method = "GET";
>     new_req.body.clear();
>     new_req.headers.clear();
>   }
> 
>   Response new_res;
> 
>   auto ret = cli.send(new_req, new_res);
>   if (ret) { res = new_res; }
>   return ret;
> }
2438,2445c2589,2590
<       while (ok && offset < end_offset) {
<         if (!content_provider(offset, end_offset - offset, data_sink)) {
<           return -1;
<         }
<         if (!ok) {
<           return -1;
<         }
<       }
---
> inline std::string encode_url(const std::string &s) {
>   std::string result;
2447c2592,2613
<       return static_cast<ssize_t>(offset - begin_offset);
---
>   for (size_t i = 0; s[i]; i++) {
>     switch (s[i]) {
>     case ' ': result += "%20"; break;
>     case '+': result += "%2B"; break;
>     case '\r': result += "%0D"; break;
>     case '\n': result += "%0A"; break;
>     case '\'': result += "%27"; break;
>     case ',': result += "%2C"; break;
>     // case ':': result += "%3A"; break; // ok? probably...
>     case ';': result += "%3B"; break;
>     default:
>       auto c = static_cast<uint8_t>(s[i]);
>       if (c >= 0x80) {
>         result += '%';
>         char hex[4];
>         auto len = snprintf(hex, sizeof(hex) - 1, "%02X", c);
>         assert(len == 2);
>         result.append(hex, static_cast<size_t>(len));
>       } else {
>         result += s[i];
>       }
>       break;
2448a2615
>   }
2450,2484c2617,2618
<     template <typename T>
<     inline ssize_t write_content_chunked(Stream &strm, ContentProvider content_provider, T is_shutting_down) {
<       size_t offset = 0;
<       auto data_available = true;
<       ssize_t total_written_length = 0;
< 
<       auto ok = true;
< 
<       DataSink data_sink;
<       data_sink.write = [&](const char *d, size_t l) {
<         if (ok) {
<           data_available = l > 0;
<           offset += l;
< 
<           // Emit chunked response header and footer for each chunk
<           auto chunk = from_i_to_hex(l) + "\r\n" + std::string(d, l) + "\r\n";
<           if (write_data(strm, chunk.data(), chunk.size())) {
<             total_written_length += chunk.size();
<           } else {
<             ok = false;
<           }
<         }
<       };
<       data_sink.done = [&](void) {
<         data_available = false;
<         if (ok) {
<           static const std::string done_marker("0\r\n\r\n");
<           if (write_data(strm, done_marker.data(), done_marker.size())) {
<             total_written_length += done_marker.size();
<           } else {
<             ok = false;
<           }
<         }
<       };
<       data_sink.is_writable = [&](void) { return ok && strm.is_writable(); };
---
>   return result;
> }
2486,2488c2620,2635
<       while (data_available && !is_shutting_down()) {
<         if (!content_provider(offset, 0, data_sink)) {
<           return -1;
---
> inline std::string decode_url(const std::string &s,
>                               bool convert_plus_to_space) {
>   std::string result;
> 
>   for (size_t i = 0; i < s.size(); i++) {
>     if (s[i] == '%' && i + 1 < s.size()) {
>       if (s[i + 1] == 'u') {
>         int val = 0;
>         if (from_hex_to_i(s, i + 2, 4, val)) {
>           // 4 digits Unicode codes
>           char buff[4];
>           size_t len = to_utf8(val, buff);
>           if (len > 0) { result.append(buff, len); }
>           i += 5; // 'u0000'
>         } else {
>           result += s[i];
2490,2491c2637,2644
<         if (!ok) {
<           return -1;
---
>       } else {
>         int val = 0;
>         if (from_hex_to_i(s, i + 1, 2, val)) {
>           // 2 digits hex codes
>           result += static_cast<char>(val);
>           i += 2; // '00'
>         } else {
>           result += s[i];
2494,2495c2647,2650
< 
<       return total_written_length;
---
>     } else if (convert_plus_to_space && s[i] == '+') {
>       result += ' ';
>     } else {
>       result += s[i];
2496a2652
>   }
2498,2508c2654,2655
<     template <typename T>
<     inline bool redirect(T &cli, const Request &req, Response &res, const std::string &path) {
<       Request new_req = req;
<       new_req.path = path;
<       new_req.redirect_count -= 1;
< 
<       if (res.status == 303 && (req.method != "GET" && req.method != "HEAD")) {
<         new_req.method = "GET";
<         new_req.body.clear();
<         new_req.headers.clear();
<       }
---
>   return result;
> }
2510c2657,2658
<       Response new_res;
---
> inline std::string params_to_query_str(const Params &params) {
>   std::string query;
2512,2517c2660,2665
<       auto ret = cli.send(new_req, new_res);
<       if (ret) {
<         res = new_res;
<       }
<       return ret;
<     }
---
>   for (auto it = params.begin(); it != params.end(); ++it) {
>     if (it != params.begin()) { query += "&"; }
>     query += it->first;
>     query += "=";
>     query += detail::encode_url(it->second);
>   }
2519,2520c2667,2668
<     inline std::string encode_url(const std::string &s) {
<       std::string result;
---
>   return query;
> }
2522,2558c2670,2678
<       for (size_t i = 0; s[i]; i++) {
<         switch (s[i]) {
<           case ' ':
<             result += "%20";
<             break;
<           case '+':
<             result += "%2B";
<             break;
<           case '\r':
<             result += "%0D";
<             break;
<           case '\n':
<             result += "%0A";
<             break;
<           case '\'':
<             result += "%27";
<             break;
<           case ',':
<             result += "%2C";
<             break;
<           // case ':': result += "%3A"; break; // ok? probably...
<           case ';':
<             result += "%3B";
<             break;
<           default:
<             auto c = static_cast<uint8_t>(s[i]);
<             if (c >= 0x80) {
<               result += '%';
<               char hex[4];
<               auto len = snprintf(hex, sizeof(hex) - 1, "%02X", c);
<               assert(len == 2);
<               result.append(hex, static_cast<size_t>(len));
<             } else {
<               result += s[i];
<             }
<             break;
<         }
---
> inline void parse_query_text(const std::string &s, Params &params) {
>   split(&s[0], &s[s.size()], '&', [&](const char *b, const char *e) {
>     std::string key;
>     std::string val;
>     split(b, e, '=', [&](const char *b2, const char *e2) {
>       if (key.empty()) {
>         key.assign(b2, e2);
>       } else {
>         val.assign(b2, e2);
2559a2680,2683
>     });
>     params.emplace(decode_url(key, true), decode_url(val, true));
>   });
> }
2561,2562c2685,2688
<       return result;
<     }
---
> inline bool parse_multipart_boundary(const std::string &content_type,
>                                      std::string &boundary) {
>   auto pos = content_type.find("boundary=");
>   if (pos == std::string::npos) { return false; }
2564,2565c2690,2692
<     inline std::string decode_url(const std::string &s, bool convert_plus_to_space) {
<       std::string result;
---
>   boundary = content_type.substr(pos + 9);
>   return true;
> }
2567,2595c2694,2713
<       for (size_t i = 0; i < s.size(); i++) {
<         if (s[i] == '%' && i + 1 < s.size()) {
<           if (s[i + 1] == 'u') {
<             int val = 0;
<             if (from_hex_to_i(s, i + 2, 4, val)) {
<               // 4 digits Unicode codes
<               char buff[4];
<               size_t len = to_utf8(val, buff);
<               if (len > 0) {
<                 result.append(buff, len);
<               }
<               i += 5;  // 'u0000'
<             } else {
<               result += s[i];
<             }
<           } else {
<             int val = 0;
<             if (from_hex_to_i(s, i + 1, 2, val)) {
<               // 2 digits hex codes
<               result += static_cast<char>(val);
<               i += 2;  // '00'
<             } else {
<               result += s[i];
<             }
<           }
<         } else if (convert_plus_to_space && s[i] == '+') {
<           result += ' ';
<         } else {
<           result += s[i];
---
> inline bool parse_range_header(const std::string &s, Ranges &ranges) {
>   static auto re_first_range = std::regex(R"(bytes=(\d*-\d*(?:,\s*\d*-\d*)*))");
>   std::smatch m;
>   if (std::regex_match(s, m, re_first_range)) {
>     auto pos = static_cast<size_t>(m.position(1));
>     auto len = static_cast<size_t>(m.length(1));
>     bool all_valid_ranges = true;
>     split(&s[pos], &s[pos + len], ',', [&](const char *b, const char *e) {
>       if (!all_valid_ranges) return;
>       static auto re_another_range = std::regex(R"(\s*(\d*)-(\d*))");
>       std::cmatch cm;
>       if (std::regex_match(b, e, cm, re_another_range)) {
>         ssize_t first = -1;
>         if (!cm.str(1).empty()) {
>           first = static_cast<ssize_t>(std::stoll(cm.str(1)));
>         }
> 
>         ssize_t last = -1;
>         if (!cm.str(2).empty()) {
>           last = static_cast<ssize_t>(std::stoll(cm.str(2)));
2597,2603d2714
<       }
< 
<       return result;
<     }
< 
<     inline std::string params_to_query_str(const Params &params) {
<       std::string query;
2605,2607c2716,2718
<       for (auto it = params.begin(); it != params.end(); ++it) {
<         if (it != params.begin()) {
<           query += "&";
---
>         if (first != -1 && last != -1 && first > last) {
>           all_valid_ranges = false;
>           return;
2609,2611c2720
<         query += it->first;
<         query += "=";
<         query += detail::encode_url(it->second);
---
>         ranges.emplace_back(std::make_pair(first, last));
2612a2722,2726
>     });
>     return all_valid_ranges;
>   }
>   return false;
> }
2614,2615c2728,2784
<       return query;
<     }
---
> class MultipartFormDataParser {
> public:
>   MultipartFormDataParser() = default;
> 
>   void set_boundary(std::string boundary) { boundary_ = std::move(boundary); }
> 
>   bool is_valid() const { return is_valid_; }
> 
>   template <typename T, typename U>
>   bool parse(const char *buf, size_t n, T content_callback, U header_callback) {
>     static const std::regex re_content_type(R"(^Content-Type:\s*(.*?)\s*$)",
>                                             std::regex_constants::icase);
> 
>     static const std::regex re_content_disposition(
>         "^Content-Disposition:\\s*form-data;\\s*name=\"(.*?)\"(?:;\\s*filename="
>         "\"(.*?)\")?\\s*$",
>         std::regex_constants::icase);
>     static const std::string dash_ = "--";
>     static const std::string crlf_ = "\r\n";
> 
>     buf_.append(buf, n); // TODO: performance improvement
> 
>     while (!buf_.empty()) {
>       switch (state_) {
>       case 0: { // Initial boundary
>         auto pattern = dash_ + boundary_ + crlf_;
>         if (pattern.size() > buf_.size()) { return true; }
>         auto pos = buf_.find(pattern);
>         if (pos != 0) {
>           is_done_ = true;
>           return false;
>         }
>         buf_.erase(0, pattern.size());
>         off_ += pattern.size();
>         state_ = 1;
>         break;
>       }
>       case 1: { // New entry
>         clear_file_info();
>         state_ = 2;
>         break;
>       }
>       case 2: { // Headers
>         auto pos = buf_.find(crlf_);
>         while (pos != std::string::npos) {
>           // Empty line
>           if (pos == 0) {
>             if (!header_callback(file_)) {
>               is_valid_ = false;
>               is_done_ = false;
>               return false;
>             }
>             buf_.erase(0, crlf_.size());
>             off_ += crlf_.size();
>             state_ = 3;
>             break;
>           }
2617,2625c2786,2794
<     inline void parse_query_text(const std::string &s, Params &params) {
<       split(&s[0], &s[s.size()], '&', [&](const char *b, const char *e) {
<         std::string key;
<         std::string val;
<         split(b, e, '=', [&](const char *b2, const char *e2) {
<           if (key.empty()) {
<             key.assign(b2, e2);
<           } else {
<             val.assign(b2, e2);
---
>           auto header = buf_.substr(0, pos);
>           {
>             std::smatch m;
>             if (std::regex_match(header, m, re_content_type)) {
>               file_.content_type = m[1];
>             } else if (std::regex_match(header, m, re_content_disposition)) {
>               file_.name = m[1];
>               file_.filename = m[2];
>             }
2627,2630d2795
<         });
<         params.emplace(decode_url(key, true), decode_url(val, true));
<       });
<     }
2632,2635c2797,2801
<     inline bool parse_multipart_boundary(const std::string &content_type, std::string &boundary) {
<       auto pos = content_type.find("boundary=");
<       if (pos == std::string::npos) {
<         return false;
---
>           buf_.erase(0, pos + crlf_.size());
>           off_ += pos + crlf_.size();
>           pos = buf_.find(crlf_);
>         }
>         break;
2636a2803,2806
>       case 3: { // Body
>         {
>           auto pattern = crlf_ + dash_;
>           if (pattern.size() > buf_.size()) { return true; }
2638,2640c2808,2814
<       boundary = content_type.substr(pos + 9);
<       return true;
<     }
---
>           auto pos = buf_.find(pattern);
>           if (pos == std::string::npos) { pos = buf_.size(); }
>           if (!content_callback(buf_.data(), pos)) {
>             is_valid_ = false;
>             is_done_ = false;
>             return false;
>           }
2642,2658c2816,2818
<     inline bool parse_range_header(const std::string &s, Ranges &ranges) {
<       static auto re_first_range = std::regex(R"(bytes=(\d*-\d*(?:,\s*\d*-\d*)*))");
<       std::smatch m;
<       if (std::regex_match(s, m, re_first_range)) {
<         auto pos = static_cast<size_t>(m.position(1));
<         auto len = static_cast<size_t>(m.length(1));
<         bool all_valid_ranges = true;
<         split(&s[pos], &s[pos + len], ',', [&](const char *b, const char *e) {
<           if (!all_valid_ranges)
<             return;
<           static auto re_another_range = std::regex(R"(\s*(\d*)-(\d*))");
<           std::cmatch cm;
<           if (std::regex_match(b, e, cm, re_another_range)) {
<             ssize_t first = -1;
<             if (!cm.str(1).empty()) {
<               first = static_cast<ssize_t>(std::stoll(cm.str(1)));
<             }
---
>           off_ += pos;
>           buf_.erase(0, pos);
>         }
2660,2663c2820,2822
<             ssize_t last = -1;
<             if (!cm.str(2).empty()) {
<               last = static_cast<ssize_t>(std::stoll(cm.str(2)));
<             }
---
>         {
>           auto pattern = crlf_ + dash_ + boundary_;
>           if (pattern.size() > buf_.size()) { return true; }
2665,2667c2824,2829
<             if (first != -1 && last != -1 && first > last) {
<               all_valid_ranges = false;
<               return;
---
>           auto pos = buf_.find(pattern);
>           if (pos != std::string::npos) {
>             if (!content_callback(buf_.data(), pos)) {
>               is_valid_ = false;
>               is_done_ = false;
>               return false;
2669,2675d2830
<             ranges.emplace_back(std::make_pair(first, last));
<           }
<         });
<         return all_valid_ranges;
<       }
<       return false;
<     }
2677,2828c2832,2836
<     class MultipartFormDataParser {
<      public:
<       MultipartFormDataParser() = default;
< 
<       void set_boundary(std::string boundary) { boundary_ = std::move(boundary); }
< 
<       bool is_valid() const { return is_valid_; }
< 
<       template <typename T, typename U>
<       bool parse(const char *buf, size_t n, T content_callback, U header_callback) {
<         static const std::regex re_content_type(R"(^Content-Type:\s*(.*?)\s*$)", std::regex_constants::icase);
< 
<         static const std::regex re_content_disposition("^Content-Disposition:\\s*form-data;\\s*name=\"(.*?)\"(?:;\\s*filename="
<                                                        "\"(.*?)\")?\\s*$",
<                                                        std::regex_constants::icase);
<         static const std::string dash_ = "--";
<         static const std::string crlf_ = "\r\n";
< 
<         buf_.append(buf, n);  // TODO: performance improvement
< 
<         while (!buf_.empty()) {
<           switch (state_) {
<             case 0: {  // Initial boundary
<               auto pattern = dash_ + boundary_ + crlf_;
<               if (pattern.size() > buf_.size()) {
<                 return true;
<               }
<               auto pos = buf_.find(pattern);
<               if (pos != 0) {
<                 is_done_ = true;
<                 return false;
<               }
<               buf_.erase(0, pattern.size());
<               off_ += pattern.size();
<               state_ = 1;
<               break;
<             }
<             case 1: {  // New entry
<               clear_file_info();
<               state_ = 2;
<               break;
<             }
<             case 2: {  // Headers
<               auto pos = buf_.find(crlf_);
<               while (pos != std::string::npos) {
<                 // Empty line
<                 if (pos == 0) {
<                   if (!header_callback(file_)) {
<                     is_valid_ = false;
<                     is_done_ = false;
<                     return false;
<                   }
<                   buf_.erase(0, crlf_.size());
<                   off_ += crlf_.size();
<                   state_ = 3;
<                   break;
<                 }
< 
<                 auto header = buf_.substr(0, pos);
<                 {
<                   std::smatch m;
<                   if (std::regex_match(header, m, re_content_type)) {
<                     file_.content_type = m[1];
<                   } else if (std::regex_match(header, m, re_content_disposition)) {
<                     file_.name = m[1];
<                     file_.filename = m[2];
<                   }
<                 }
< 
<                 buf_.erase(0, pos + crlf_.size());
<                 off_ += pos + crlf_.size();
<                 pos = buf_.find(crlf_);
<               }
<               break;
<             }
<             case 3: {  // Body
<               {
<                 auto pattern = crlf_ + dash_;
<                 if (pattern.size() > buf_.size()) {
<                   return true;
<                 }
< 
<                 auto pos = buf_.find(pattern);
<                 if (pos == std::string::npos) {
<                   pos = buf_.size();
<                 }
<                 if (!content_callback(buf_.data(), pos)) {
<                   is_valid_ = false;
<                   is_done_ = false;
<                   return false;
<                 }
< 
<                 off_ += pos;
<                 buf_.erase(0, pos);
<               }
< 
<               {
<                 auto pattern = crlf_ + dash_ + boundary_;
<                 if (pattern.size() > buf_.size()) {
<                   return true;
<                 }
< 
<                 auto pos = buf_.find(pattern);
<                 if (pos != std::string::npos) {
<                   if (!content_callback(buf_.data(), pos)) {
<                     is_valid_ = false;
<                     is_done_ = false;
<                     return false;
<                   }
< 
<                   off_ += pos + pattern.size();
<                   buf_.erase(0, pos + pattern.size());
<                   state_ = 4;
<                 } else {
<                   if (!content_callback(buf_.data(), pattern.size())) {
<                     is_valid_ = false;
<                     is_done_ = false;
<                     return false;
<                   }
< 
<                   off_ += pattern.size();
<                   buf_.erase(0, pattern.size());
<                 }
<               }
<               break;
<             }
<             case 4: {  // Boundary
<               if (crlf_.size() > buf_.size()) {
<                 return true;
<               }
<               if (buf_.find(crlf_) == 0) {
<                 buf_.erase(0, crlf_.size());
<                 off_ += crlf_.size();
<                 state_ = 1;
<               } else {
<                 auto pattern = dash_ + crlf_;
<                 if (pattern.size() > buf_.size()) {
<                   return true;
<                 }
<                 if (buf_.find(pattern) == 0) {
<                   buf_.erase(0, pattern.size());
<                   off_ += pattern.size();
<                   is_valid_ = true;
<                   state_ = 5;
<                 } else {
<                   is_done_ = true;
<                   return true;
<                 }
<               }
<               break;
<             }
<             case 5: {  // Done
---
>             off_ += pos + pattern.size();
>             buf_.erase(0, pos + pattern.size());
>             state_ = 4;
>           } else {
>             if (!content_callback(buf_.data(), pattern.size())) {
2829a2838
>               is_done_ = false;
2831a2841,2843
> 
>             off_ += pattern.size();
>             buf_.erase(0, pattern.size());
2834,2835c2846
< 
<         return true;
---
>         break;
2837,2842c2848,2871
< 
<      private:
<       void clear_file_info() {
<         file_.name.clear();
<         file_.filename.clear();
<         file_.content_type.clear();
---
>       case 4: { // Boundary
>         if (crlf_.size() > buf_.size()) { return true; }
>         if (buf_.find(crlf_) == 0) {
>           buf_.erase(0, crlf_.size());
>           off_ += crlf_.size();
>           state_ = 1;
>         } else {
>           auto pattern = dash_ + crlf_;
>           if (pattern.size() > buf_.size()) { return true; }
>           if (buf_.find(pattern) == 0) {
>             buf_.erase(0, pattern.size());
>             off_ += pattern.size();
>             is_valid_ = true;
>             state_ = 5;
>           } else {
>             is_done_ = true;
>             return true;
>           }
>         }
>         break;
>       }
>       case 5: { // Done
>         is_valid_ = false;
>         return false;
2844,2860d2872
< 
<       std::string boundary_;
< 
<       std::string buf_;
<       size_t state_ = 0;
<       size_t is_valid_ = false;
<       size_t is_done_ = false;
<       size_t off_ = 0;
<       MultipartFormData file_;
<     };
< 
<     inline std::string to_lower(const char *beg, const char *end) {
<       std::string out;
<       auto it = beg;
<       while (it != end) {
<         out += static_cast<char>(::tolower(*it));
<         it++;
2862d2873
<       return out;
2865,2866c2876,2877
<     inline std::string make_multipart_data_boundary() {
<       static const char data[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
---
>     return true;
>   }
2868,2869c2879,2904
<       std::random_device seed_gen;
<       std::mt19937 engine(seed_gen());
---
> private:
>   void clear_file_info() {
>     file_.name.clear();
>     file_.filename.clear();
>     file_.content_type.clear();
>   }
> 
>   std::string boundary_;
> 
>   std::string buf_;
>   size_t state_ = 0;
>   size_t is_valid_ = false;
>   size_t is_done_ = false;
>   size_t off_ = 0;
>   MultipartFormData file_;
> };
> 
> inline std::string to_lower(const char *beg, const char *end) {
>   std::string out;
>   auto it = beg;
>   while (it != end) {
>     out += static_cast<char>(::tolower(*it));
>     it++;
>   }
>   return out;
> }
2871c2906,2908
<       std::string result = "--cpp-httplib-multipart-data-";
---
> inline std::string make_multipart_data_boundary() {
>   static const char data[] =
>       "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
2873,2875c2910,2911
<       for (auto i = 0; i < 16; i++) {
<         result += data[engine() % (sizeof(data) - 1)];
<       }
---
>   std::random_device seed_gen;
>   std::mt19937 engine(seed_gen());
2877,2881c2913
<       return result;
<     }
< 
<     inline std::pair<size_t, size_t> get_range_offset_and_length(const Request &req, size_t content_length, size_t index) {
<       auto r = req.ranges[index];
---
>   std::string result = "--cpp-httplib-multipart-data-";
2883,2885c2915,2917
<       if (r.first == -1 && r.second == -1) {
<         return std::make_pair(0, content_length);
<       }
---
>   for (auto i = 0; i < 16; i++) {
>     result += data[engine() % (sizeof(data) - 1)];
>   }
2887c2919,2920
<       auto slen = static_cast<ssize_t>(content_length);
---
>   return result;
> }
2889,2892c2922,2925
<       if (r.first == -1) {
<         r.first = slen - r.second;
<         r.second = slen - 1;
<       }
---
> inline std::pair<size_t, size_t>
> get_range_offset_and_length(const Request &req, size_t content_length,
>                             size_t index) {
>   auto r = req.ranges[index];
2894,2896c2927,2929
<       if (r.second == -1) {
<         r.second = slen - 1;
<       }
---
>   if (r.first == -1 && r.second == -1) {
>     return std::make_pair(0, content_length);
>   }
2898,2899c2931
<       return std::make_pair(r.first, r.second - r.first + 1);
<     }
---
>   auto slen = static_cast<ssize_t>(content_length);
2901,2909c2933,2936
<     inline std::string make_content_range_header_field(size_t offset, size_t length, size_t content_length) {
<       std::string field = "bytes ";
<       field += std::to_string(offset);
<       field += "-";
<       field += std::to_string(offset + length - 1);
<       field += "/";
<       field += std::to_string(content_length);
<       return field;
<     }
---
>   if (r.first == -1) {
>     r.first = slen - r.second;
>     r.second = slen - 1;
>   }
2911,2922c2938
<     template <typename SToken, typename CToken, typename Content>
<     bool process_multipart_ranges_data(const Request &req, Response &res, const std::string &boundary,
<                                        const std::string &content_type, SToken stoken, CToken ctoken, Content content) {
<       for (size_t i = 0; i < req.ranges.size(); i++) {
<         ctoken("--");
<         stoken(boundary);
<         ctoken("\r\n");
<         if (!content_type.empty()) {
<           ctoken("Content-Type: ");
<           stoken(content_type);
<           ctoken("\r\n");
<         }
---
>   if (r.second == -1) { r.second = slen - 1; }
2924,2926c2940,2941
<         auto offsets = get_range_offset_and_length(req, res.body.size(), i);
<         auto offset = offsets.first;
<         auto length = offsets.second;
---
>   return std::make_pair(r.first, r.second - r.first + 1);
> }
2928,2936c2943,2952
<         ctoken("Content-Range: ");
<         stoken(make_content_range_header_field(offset, length, res.body.size()));
<         ctoken("\r\n");
<         ctoken("\r\n");
<         if (!content(offset, length)) {
<           return false;
<         }
<         ctoken("\r\n");
<       }
---
> inline std::string make_content_range_header_field(size_t offset, size_t length,
>                                                    size_t content_length) {
>   std::string field = "bytes ";
>   field += std::to_string(offset);
>   field += "-";
>   field += std::to_string(offset + length - 1);
>   field += "/";
>   field += std::to_string(content_length);
>   return field;
> }
2938,2940c2954,2984
<       ctoken("--");
<       stoken(boundary);
<       ctoken("--\r\n");
---
> template <typename SToken, typename CToken, typename Content>
> bool process_multipart_ranges_data(const Request &req, Response &res,
>                                    const std::string &boundary,
>                                    const std::string &content_type,
>                                    SToken stoken, CToken ctoken,
>                                    Content content) {
>   for (size_t i = 0; i < req.ranges.size(); i++) {
>     ctoken("--");
>     stoken(boundary);
>     ctoken("\r\n");
>     if (!content_type.empty()) {
>       ctoken("Content-Type: ");
>       stoken(content_type);
>       ctoken("\r\n");
>     }
> 
>     auto offsets = get_range_offset_and_length(req, res.body.size(), i);
>     auto offset = offsets.first;
>     auto length = offsets.second;
> 
>     ctoken("Content-Range: ");
>     stoken(make_content_range_header_field(offset, length, res.body.size()));
>     ctoken("\r\n");
>     ctoken("\r\n");
>     if (!content(offset, length)) { return false; }
>     ctoken("\r\n");
>   }
> 
>   ctoken("--");
>   stoken(boundary);
>   ctoken("--\r\n");
2942,2943c2986,2987
<       return true;
<     }
---
>   return true;
> }
2945,2955c2989,3001
<     inline std::string make_multipart_ranges_data(const Request &req, Response &res, const std::string &boundary,
<                                                   const std::string &content_type) {
<       std::string data;
< 
<       process_multipart_ranges_data(
<           req, res, boundary, content_type, [&](const std::string &token) { data += token; },
<           [&](const char *token) { data += token; },
<           [&](size_t offset, size_t length) {
<             data += res.body.substr(offset, length);
<             return true;
<           });
---
> inline std::string make_multipart_ranges_data(const Request &req, Response &res,
>                                               const std::string &boundary,
>                                               const std::string &content_type) {
>   std::string data;
> 
>   process_multipart_ranges_data(
>       req, res, boundary, content_type,
>       [&](const std::string &token) { data += token; },
>       [&](const char *token) { data += token; },
>       [&](size_t offset, size_t length) {
>         data += res.body.substr(offset, length);
>         return true;
>       });
2957,2958c3003,3004
<       return data;
<     }
---
>   return data;
> }
2960,2970c3006,3019
<     inline size_t get_multipart_ranges_data_length(const Request &req, Response &res, const std::string &boundary,
<                                                    const std::string &content_type) {
<       size_t data_length = 0;
< 
<       process_multipart_ranges_data(
<           req, res, boundary, content_type, [&](const std::string &token) { data_length += token.size(); },
<           [&](const char *token) { data_length += strlen(token); },
<           [&](size_t /*offset*/, size_t length) {
<             data_length += length;
<             return true;
<           });
---
> inline size_t
> get_multipart_ranges_data_length(const Request &req, Response &res,
>                                  const std::string &boundary,
>                                  const std::string &content_type) {
>   size_t data_length = 0;
> 
>   process_multipart_ranges_data(
>       req, res, boundary, content_type,
>       [&](const std::string &token) { data_length += token.size(); },
>       [&](const char *token) { data_length += strlen(token); },
>       [&](size_t /*offset*/, size_t length) {
>         data_length += length;
>         return true;
>       });
2972,2973c3021,3022
<       return data_length;
<     }
---
>   return data_length;
> }
2975,2981c3024,3035
<     inline bool write_multipart_ranges_data(Stream &strm, const Request &req, Response &res, const std::string &boundary,
<                                             const std::string &content_type) {
<       return process_multipart_ranges_data(
<           req, res, boundary, content_type, [&](const std::string &token) { strm.write(token); },
<           [&](const char *token) { strm.write(token); },
<           [&](size_t offset, size_t length) { return write_content(strm, res.content_provider_, offset, length) >= 0; });
<     }
---
> inline bool write_multipart_ranges_data(Stream &strm, const Request &req,
>                                         Response &res,
>                                         const std::string &boundary,
>                                         const std::string &content_type) {
>   return process_multipart_ranges_data(
>       req, res, boundary, content_type,
>       [&](const std::string &token) { strm.write(token); },
>       [&](const char *token) { strm.write(token); },
>       [&](size_t offset, size_t length) {
>         return write_content(strm, res.content_provider_, offset, length) >= 0;
>       });
> }
2983,2984c3037,3040
<     inline std::pair<size_t, size_t> get_range_offset_and_length(const Request &req, const Response &res, size_t index) {
<       auto r = req.ranges[index];
---
> inline std::pair<size_t, size_t>
> get_range_offset_and_length(const Request &req, const Response &res,
>                             size_t index) {
>   auto r = req.ranges[index];
2986,2988c3042,3044
<       if (r.second == -1) {
<         r.second = static_cast<ssize_t>(res.content_length_) - 1;
<       }
---
>   if (r.second == -1) {
>     r.second = static_cast<ssize_t>(res.content_length_) - 1;
>   }
2990,2991c3046,3047
<       return std::make_pair(r.first, r.second - r.first + 1);
<     }
---
>   return std::make_pair(r.first, r.second - r.first + 1);
> }
2993,3000c3049,3057
<     inline bool expect_content(const Request &req) {
<       if (req.method == "POST" || req.method == "PUT" || req.method == "PATCH" || req.method == "PRI"
<           || (req.method == "DELETE" && req.has_header("Content-Length"))) {
<         return true;
<       }
<       // TODO: check if Content-Length is set
<       return false;
<     }
---
> inline bool expect_content(const Request &req) {
>   if (req.method == "POST" || req.method == "PUT" || req.method == "PATCH" ||
>       req.method == "PRI" ||
>       (req.method == "DELETE" && req.has_header("Content-Length"))) {
>     return true;
>   }
>   // TODO: check if Content-Length is set
>   return false;
> }
3002,3011c3059,3066
<     inline bool has_crlf(const char *s) {
<       auto p = s;
<       while (*p) {
<         if (*p == '\r' || *p == '\n') {
<           return true;
<         }
<         p++;
<       }
<       return false;
<     }
---
> inline bool has_crlf(const char *s) {
>   auto p = s;
>   while (*p) {
>     if (*p == '\r' || *p == '\n') { return true; }
>     p++;
>   }
>   return false;
> }
3014,3029c3069,3086
<     template <typename CTX, typename Init, typename Update, typename Final>
<     inline std::string message_digest(const std::string &s, Init init, Update update, Final final, size_t digest_length) {
<       using namespace std;
< 
<       std::vector<unsigned char> md(digest_length, 0);
<       CTX ctx;
<       init(&ctx);
<       update(&ctx, s.data(), s.size());
<       final(md.data(), &ctx);
< 
<       stringstream ss;
<       for (auto c : md) {
<         ss << setfill('0') << setw(2) << hex << (unsigned int)c;
<       }
<       return ss.str();
<     }
---
> template <typename CTX, typename Init, typename Update, typename Final>
> inline std::string message_digest(const std::string &s, Init init,
>                                   Update update, Final final,
>                                   size_t digest_length) {
>   using namespace std;
> 
>   std::vector<unsigned char> md(digest_length, 0);
>   CTX ctx;
>   init(&ctx);
>   update(&ctx, s.data(), s.size());
>   final(md.data(), &ctx);
> 
>   stringstream ss;
>   for (auto c : md) {
>     ss << setfill('0') << setw(2) << hex << (unsigned int)c;
>   }
>   return ss.str();
> }
3031,3033c3088,3091
<     inline std::string MD5(const std::string &s) {
<       return message_digest<MD5_CTX>(s, MD5_Init, MD5_Update, MD5_Final, MD5_DIGEST_LENGTH);
<     }
---
> inline std::string MD5(const std::string &s) {
>   return message_digest<MD5_CTX>(s, MD5_Init, MD5_Update, MD5_Final,
>                                  MD5_DIGEST_LENGTH);
> }
3035,3037c3093,3096
<     inline std::string SHA_256(const std::string &s) {
<       return message_digest<SHA256_CTX>(s, SHA256_Init, SHA256_Update, SHA256_Final, SHA256_DIGEST_LENGTH);
<     }
---
> inline std::string SHA_256(const std::string &s) {
>   return message_digest<SHA256_CTX>(s, SHA256_Init, SHA256_Update, SHA256_Final,
>                                     SHA256_DIGEST_LENGTH);
> }
3039,3041c3098,3101
<     inline std::string SHA_512(const std::string &s) {
<       return message_digest<SHA512_CTX>(s, SHA512_Init, SHA512_Update, SHA512_Final, SHA512_DIGEST_LENGTH);
<     }
---
> inline std::string SHA_512(const std::string &s) {
>   return message_digest<SHA512_CTX>(s, SHA512_Init, SHA512_Update, SHA512_Final,
>                                     SHA512_DIGEST_LENGTH);
> }
3045,3050c3105,3110
<     class WSInit {
<      public:
<       WSInit() {
<         WSADATA wsaData;
<         WSAStartup(0x0002, &wsaData);
<       }
---
> class WSInit {
> public:
>   WSInit() {
>     WSADATA wsaData;
>     WSAStartup(0x0002, &wsaData);
>   }
3052,3053c3112,3113
<       ~WSInit() { WSACleanup(); }
<     };
---
>   ~WSInit() { WSACleanup(); }
> };
3055c3115
<     static WSInit wsinit_;
---
> static WSInit wsinit_;
3058c3118
<   }  // namespace detail
---
> } // namespace detail
3060,3077c3120,3129
<   // Header utilities
<   inline std::pair<std::string, std::string> make_range_header(Ranges ranges) {
<     std::string field = "bytes=";
<     auto i = 0;
<     for (auto r : ranges) {
<       if (i != 0) {
<         field += ", ";
<       }
<       if (r.first != -1) {
<         field += std::to_string(r.first);
<       }
<       field += '-';
<       if (r.second != -1) {
<         field += std::to_string(r.second);
<       }
<       i++;
<     }
<     return std::make_pair("Range", field);
---
> // Header utilities
> inline std::pair<std::string, std::string> make_range_header(Ranges ranges) {
>   std::string field = "bytes=";
>   auto i = 0;
>   for (auto r : ranges) {
>     if (i != 0) { field += ", "; }
>     if (r.first != -1) { field += std::to_string(r.first); }
>     field += '-';
>     if (r.second != -1) { field += std::to_string(r.second); }
>     i++;
3078a3131,3132
>   return std::make_pair("Range", field);
> }
3080,3085c3134,3141
<   inline std::pair<std::string, std::string>
<   make_basic_authentication_header(const std::string &username, const std::string &password, bool is_proxy = false) {
<     auto field = "Basic " + detail::base64_encode(username + ":" + password);
<     auto key = is_proxy ? "Proxy-Authorization" : "Authorization";
<     return std::make_pair(key, field);
<   }
---
> inline std::pair<std::string, std::string>
> make_basic_authentication_header(const std::string &username,
>                                  const std::string &password,
>                                  bool is_proxy = false) {
>   auto field = "Basic " + detail::base64_encode(username + ":" + password);
>   auto key = is_proxy ? "Proxy-Authorization" : "Authorization";
>   return std::make_pair(key, field);
> }
3088,3092c3144,3148
<   inline std::pair<std::string, std::string>
<   make_digest_authentication_header(const Request &req, const std::map<std::string, std::string> &auth, size_t cnonce_count,
<                                     const std::string &cnonce, const std::string &username, const std::string &password,
<                                     bool is_proxy = false) {
<     using namespace std;
---
> inline std::pair<std::string, std::string> make_digest_authentication_header(
>     const Request &req, const std::map<std::string, std::string> &auth,
>     size_t cnonce_count, const std::string &cnonce, const std::string &username,
>     const std::string &password, bool is_proxy = false) {
>   using namespace std;
3094,3099c3150,3155
<     string nc;
<     {
<       stringstream ss;
<       ss << setfill('0') << setw(8) << hex << cnonce_count;
<       nc = ss.str();
<     }
---
>   string nc;
>   {
>     stringstream ss;
>     ss << setfill('0') << setw(8) << hex << cnonce_count;
>     nc = ss.str();
>   }
3101,3106c3157,3162
<     auto qop = auth.at("qop");
<     if (qop.find("auth-int") != std::string::npos) {
<       qop = "auth-int";
<     } else {
<       qop = "auth";
<     }
---
>   auto qop = auth.at("qop");
>   if (qop.find("auth-int") != std::string::npos) {
>     qop = "auth-int";
>   } else {
>     qop = "auth";
>   }
3108,3111c3164,3165
<     std::string algo = "MD5";
<     if (auth.find("algorithm") != auth.end()) {
<       algo = auth.at("algorithm");
<     }
---
>   std::string algo = "MD5";
>   if (auth.find("algorithm") != auth.end()) { algo = auth.at("algorithm"); }
3113,3115c3167,3171
<     string response;
<     {
<       auto H = algo == "SHA-256" ? detail::SHA_256 : algo == "SHA-512" ? detail::SHA_512 : detail::MD5;
---
>   string response;
>   {
>     auto H = algo == "SHA-256"
>                  ? detail::SHA_256
>                  : algo == "SHA-512" ? detail::SHA_512 : detail::MD5;
3117c3173
<       auto A1 = username + ":" + auth.at("realm") + ":" + password;
---
>     auto A1 = username + ":" + auth.at("realm") + ":" + password;
3119,3122c3175,3176
<       auto A2 = req.method + ":" + req.path;
<       if (qop == "auth-int") {
<         A2 += ":" + H(req.body);
<       }
---
>     auto A2 = req.method + ":" + req.path;
>     if (qop == "auth-int") { A2 += ":" + H(req.body); }
3124,3125c3178,3180
<       response = H(H(A1) + ":" + auth.at("nonce") + ":" + nc + ":" + cnonce + ":" + qop + ":" + H(A2));
<     }
---
>     response = H(H(A1) + ":" + auth.at("nonce") + ":" + nc + ":" + cnonce +
>                  ":" + qop + ":" + H(A2));
>   }
3127,3129c3182,3186
<     auto field = "Digest username=\"" + username + "\", realm=\"" + auth.at("realm") + "\", nonce=\"" + auth.at("nonce")
<         + "\", uri=\"" + req.path + "\", algorithm=" + algo + ", qop=" + qop + ", nc=\"" + nc + "\", cnonce=\"" + cnonce
<         + "\", response=\"" + response + "\"";
---
>   auto field = "Digest username=\"" + username + "\", realm=\"" +
>                auth.at("realm") + "\", nonce=\"" + auth.at("nonce") +
>                "\", uri=\"" + req.path + "\", algorithm=" + algo +
>                ", qop=" + qop + ", nc=\"" + nc + "\", cnonce=\"" + cnonce +
>                "\", response=\"" + response + "\"";
3131,3133c3188,3190
<     auto key = is_proxy ? "Proxy-Authorization" : "Authorization";
<     return std::make_pair(key, field);
<   }
---
>   auto key = is_proxy ? "Proxy-Authorization" : "Authorization";
>   return std::make_pair(key, field);
> }
3136,3156c3193,3217
<   inline bool parse_www_authenticate(const httplib::Response &res, std::map<std::string, std::string> &auth, bool is_proxy) {
<     auto auth_key = is_proxy ? "Proxy-Authenticate" : "WWW-Authenticate";
<     if (res.has_header(auth_key)) {
<       static auto re = std::regex(R"~((?:(?:,\s*)?(.+?)=(?:"(.*?)"|([^,]*))))~");
<       auto s = res.get_header_value(auth_key);
<       auto pos = s.find(' ');
<       if (pos != std::string::npos) {
<         auto type = s.substr(0, pos);
<         if (type == "Basic") {
<           return false;
<         } else if (type == "Digest") {
<           s = s.substr(pos + 1);
<           auto beg = std::sregex_iterator(s.begin(), s.end(), re);
<           for (auto i = beg; i != std::sregex_iterator(); ++i) {
<             auto m = *i;
<             auto key = s.substr(static_cast<size_t>(m.position(1)), static_cast<size_t>(m.length(1)));
<             auto val = m.length(2) > 0 ? s.substr(static_cast<size_t>(m.position(2)), static_cast<size_t>(m.length(2)))
<                                        : s.substr(static_cast<size_t>(m.position(3)), static_cast<size_t>(m.length(3)));
<             auth[key] = val;
<           }
<           return true;
---
> inline bool parse_www_authenticate(const httplib::Response &res,
>                                    std::map<std::string, std::string> &auth,
>                                    bool is_proxy) {
>   auto auth_key = is_proxy ? "Proxy-Authenticate" : "WWW-Authenticate";
>   if (res.has_header(auth_key)) {
>     static auto re = std::regex(R"~((?:(?:,\s*)?(.+?)=(?:"(.*?)"|([^,]*))))~");
>     auto s = res.get_header_value(auth_key);
>     auto pos = s.find(' ');
>     if (pos != std::string::npos) {
>       auto type = s.substr(0, pos);
>       if (type == "Basic") {
>         return false;
>       } else if (type == "Digest") {
>         s = s.substr(pos + 1);
>         auto beg = std::sregex_iterator(s.begin(), s.end(), re);
>         for (auto i = beg; i != std::sregex_iterator(); ++i) {
>           auto m = *i;
>           auto key = s.substr(static_cast<size_t>(m.position(1)),
>                               static_cast<size_t>(m.length(1)));
>           auto val = m.length(2) > 0
>                          ? s.substr(static_cast<size_t>(m.position(2)),
>                                     static_cast<size_t>(m.length(2)))
>                          : s.substr(static_cast<size_t>(m.position(3)),
>                                     static_cast<size_t>(m.length(3)));
>           auth[key] = val;
3157a3219
>         return true;
3160d3221
<     return false;
3161a3223,3224
>   return false;
> }
3163,3175c3226,3238
<   // https://stackoverflow.com/questions/440133/how-do-i-create-a-random-alpha-numeric-string-in-c/440240#answer-440240
<   inline std::string random_string(size_t length) {
<     auto randchar = []() -> char {
<       const char charset[] = "0123456789"
<                              "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
<                              "abcdefghijklmnopqrstuvwxyz";
<       const size_t max_index = (sizeof(charset) - 1);
<       return charset[static_cast<size_t>(rand()) % max_index];
<     };
<     std::string str(length, 0);
<     std::generate_n(str.begin(), length, randchar);
<     return str;
<   }
---
> // https://stackoverflow.com/questions/440133/how-do-i-create-a-random-alpha-numeric-string-in-c/440240#answer-440240
> inline std::string random_string(size_t length) {
>   auto randchar = []() -> char {
>     const char charset[] = "0123456789"
>                            "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
>                            "abcdefghijklmnopqrstuvwxyz";
>     const size_t max_index = (sizeof(charset) - 1);
>     return charset[static_cast<size_t>(rand()) % max_index];
>   };
>   std::string str(length, 0);
>   std::generate_n(str.begin(), length, randchar);
>   return str;
> }
3177,3178c3240,3243
<   // Request implementation
<   inline bool Request::has_header(const char *key) const { return detail::has_header(headers, key); }
---
> // Request implementation
> inline bool Request::has_header(const char *key) const {
>   return detail::has_header(headers, key);
> }
3180,3182c3245,3247
<   inline std::string Request::get_header_value(const char *key, size_t id) const {
<     return detail::get_header_value(headers, key, id, "");
<   }
---
> inline std::string Request::get_header_value(const char *key, size_t id) const {
>   return detail::get_header_value(headers, key, id, "");
> }
3184,3187c3249,3252
<   inline size_t Request::get_header_value_count(const char *key) const {
<     auto r = headers.equal_range(key);
<     return static_cast<size_t>(std::distance(r.first, r.second));
<   }
---
> inline size_t Request::get_header_value_count(const char *key) const {
>   auto r = headers.equal_range(key);
>   return static_cast<size_t>(std::distance(r.first, r.second));
> }
3189,3192c3254,3256
<   inline void Request::set_header(const char *key, const char *val) {
<     if (!detail::has_crlf(key) && !detail::has_crlf(val)) {
<       headers.emplace(key, val);
<     }
---
> inline void Request::set_header(const char *key, const char *val) {
>   if (!detail::has_crlf(key) && !detail::has_crlf(val)) {
>     headers.emplace(key, val);
3193a3258
> }
3195,3198c3260,3262
<   inline void Request::set_header(const char *key, const std::string &val) {
<     if (!detail::has_crlf(key) && !detail::has_crlf(val.c_str())) {
<       headers.emplace(key, val);
<     }
---
> inline void Request::set_header(const char *key, const std::string &val) {
>   if (!detail::has_crlf(key) && !detail::has_crlf(val.c_str())) {
>     headers.emplace(key, val);
3199a3264
> }
3201c3266,3268
<   inline bool Request::has_param(const char *key) const { return params.find(key) != params.end(); }
---
> inline bool Request::has_param(const char *key) const {
>   return params.find(key) != params.end();
> }
3203,3210c3270,3275
<   inline std::string Request::get_param_value(const char *key, size_t id) const {
<     auto it = params.find(key);
<     std::advance(it, static_cast<ssize_t>(id));
<     if (it != params.end()) {
<       return it->second;
<     }
<     return std::string();
<   }
---
> inline std::string Request::get_param_value(const char *key, size_t id) const {
>   auto it = params.find(key);
>   std::advance(it, static_cast<ssize_t>(id));
>   if (it != params.end()) { return it->second; }
>   return std::string();
> }
3212,3215c3277,3280
<   inline size_t Request::get_param_value_count(const char *key) const {
<     auto r = params.equal_range(key);
<     return static_cast<size_t>(std::distance(r.first, r.second));
<   }
---
> inline size_t Request::get_param_value_count(const char *key) const {
>   auto r = params.equal_range(key);
>   return static_cast<size_t>(std::distance(r.first, r.second));
> }
3217,3220c3282,3285
<   inline bool Request::is_multipart_form_data() const {
<     const auto &content_type = get_header_value("Content-Type");
<     return !content_type.find("multipart/form-data");
<   }
---
> inline bool Request::is_multipart_form_data() const {
>   const auto &content_type = get_header_value("Content-Type");
>   return !content_type.find("multipart/form-data");
> }
3222c3287,3289
<   inline bool Request::has_file(const char *key) const { return files.find(key) != files.end(); }
---
> inline bool Request::has_file(const char *key) const {
>   return files.find(key) != files.end();
> }
3224,3230c3291,3295
<   inline MultipartFormData Request::get_file_value(const char *key) const {
<     auto it = files.find(key);
<     if (it != files.end()) {
<       return it->second;
<     }
<     return MultipartFormData();
<   }
---
> inline MultipartFormData Request::get_file_value(const char *key) const {
>   auto it = files.find(key);
>   if (it != files.end()) { return it->second; }
>   return MultipartFormData();
> }
3232,3233c3297,3300
<   // Response implementation
<   inline bool Response::has_header(const char *key) const { return headers.find(key) != headers.end(); }
---
> // Response implementation
> inline bool Response::has_header(const char *key) const {
>   return headers.find(key) != headers.end();
> }
3235,3237c3302,3305
<   inline std::string Response::get_header_value(const char *key, size_t id) const {
<     return detail::get_header_value(headers, key, id, "");
<   }
---
> inline std::string Response::get_header_value(const char *key,
>                                               size_t id) const {
>   return detail::get_header_value(headers, key, id, "");
> }
3239,3242c3307,3310
<   inline size_t Response::get_header_value_count(const char *key) const {
<     auto r = headers.equal_range(key);
<     return static_cast<size_t>(std::distance(r.first, r.second));
<   }
---
> inline size_t Response::get_header_value_count(const char *key) const {
>   auto r = headers.equal_range(key);
>   return static_cast<size_t>(std::distance(r.first, r.second));
> }
3244,3247c3312,3314
<   inline void Response::set_header(const char *key, const char *val) {
<     if (!detail::has_crlf(key) && !detail::has_crlf(val)) {
<       headers.emplace(key, val);
<     }
---
> inline void Response::set_header(const char *key, const char *val) {
>   if (!detail::has_crlf(key) && !detail::has_crlf(val)) {
>     headers.emplace(key, val);
3248a3316
> }
3250,3253c3318,3320
<   inline void Response::set_header(const char *key, const std::string &val) {
<     if (!detail::has_crlf(key) && !detail::has_crlf(val.c_str())) {
<       headers.emplace(key, val);
<     }
---
> inline void Response::set_header(const char *key, const std::string &val) {
>   if (!detail::has_crlf(key) && !detail::has_crlf(val.c_str())) {
>     headers.emplace(key, val);
3254a3322
> }
3256,3263c3324,3330
<   inline void Response::set_redirect(const char *url, int stat) {
<     if (!detail::has_crlf(url)) {
<       set_header("Location", url);
<       if (300 <= stat && stat < 400) {
<         this->status = stat;
<       } else {
<         this->status = 302;
<       }
---
> inline void Response::set_redirect(const char *url, int stat) {
>   if (!detail::has_crlf(url)) {
>     set_header("Location", url);
>     if (300 <= stat && stat < 400) {
>       this->status = stat;
>     } else {
>       this->status = 302;
3265a3333
> }
3267,3270c3335,3339
<   inline void Response::set_content(const char *s, size_t n, const char *content_type) {
<     body.assign(s, n);
<     set_header("Content-Type", content_type);
<   }
---
> inline void Response::set_content(const char *s, size_t n,
>                                   const char *content_type) {
>   body.assign(s, n);
>   set_header("Content-Type", content_type);
> }
3272,3275c3341,3344
<   inline void Response::set_content(std::string s, const char *content_type) {
<     body = std::move(s);
<     set_header("Content-Type", content_type);
<   }
---
> inline void Response::set_content(std::string s, const char *content_type) {
>   body = std::move(s);
>   set_header("Content-Type", content_type);
> }
3277,3283c3346,3355
<   inline void Response::set_content_provider(size_t in_length, ContentProvider provider,
<                                              std::function<void()> resource_releaser) {
<     assert(in_length > 0);
<     content_length_ = in_length;
<     content_provider_ = [provider](size_t offset, size_t length, DataSink &sink) { return provider(offset, length, sink); };
<     content_provider_resource_releaser_ = resource_releaser;
<   }
---
> inline void
> Response::set_content_provider(size_t in_length, ContentProvider provider,
>                                std::function<void()> resource_releaser) {
>   assert(in_length > 0);
>   content_length_ = in_length;
>   content_provider_ = [provider](size_t offset, size_t length, DataSink &sink) {
>     return provider(offset, length, sink);
>   };
>   content_provider_resource_releaser_ = resource_releaser;
> }
3285,3289c3357,3364
<   inline void Response::set_chunked_content_provider(ChunkedContentProvider provider, std::function<void()> resource_releaser) {
<     content_length_ = 0;
<     content_provider_ = [provider](size_t offset, size_t, DataSink &sink) { return provider(offset, sink); };
<     content_provider_resource_releaser_ = resource_releaser;
<   }
---
> inline void Response::set_chunked_content_provider(
>     ChunkedContentProvider provider, std::function<void()> resource_releaser) {
>   content_length_ = 0;
>   content_provider_ = [provider](size_t offset, size_t, DataSink &sink) {
>     return provider(offset, sink);
>   };
>   content_provider_resource_releaser_ = resource_releaser;
> }
3291,3292c3366,3369
<   // Rstream implementation
<   inline ssize_t Stream::write(const char *ptr) { return write(ptr, strlen(ptr)); }
---
> // Rstream implementation
> inline ssize_t Stream::write(const char *ptr) {
>   return write(ptr, strlen(ptr));
> }
3294c3371,3373
<   inline ssize_t Stream::write(const std::string &s) { return write(s.data(), s.size()); }
---
> inline ssize_t Stream::write(const std::string &s) {
>   return write(s.data(), s.size());
> }
3296,3298c3375,3377
<   template <typename... Args>
<   inline ssize_t Stream::write_format(const char *fmt, const Args &... args) {
<     std::array<char, 2048> buf;
---
> template <typename... Args>
> inline ssize_t Stream::write_format(const char *fmt, const Args &... args) {
>   std::array<char, 2048> buf;
3301c3380
<     auto sn = _snprintf_s(buf, bufsiz, buf.size() - 1, fmt, args...);
---
>   auto sn = _snprintf_s(buf, bufsiz, buf.size() - 1, fmt, args...);
3303c3382
<     auto sn = snprintf(buf.data(), buf.size() - 1, fmt, args...);
---
>   auto sn = snprintf(buf.data(), buf.size() - 1, fmt, args...);
3305,3307c3384
<     if (sn <= 0) {
<       return sn;
<     }
---
>   if (sn <= 0) { return sn; }
3309c3386
<     auto n = static_cast<size_t>(sn);
---
>   auto n = static_cast<size_t>(sn);
3311,3312c3388,3389
<     if (n >= buf.size() - 1) {
<       std::vector<char> glowable_buf(buf.size());
---
>   if (n >= buf.size() - 1) {
>     std::vector<char> glowable_buf(buf.size());
3314,3315c3391,3392
<       while (n >= glowable_buf.size() - 1) {
<         glowable_buf.resize(glowable_buf.size() * 2);
---
>     while (n >= glowable_buf.size() - 1) {
>       glowable_buf.resize(glowable_buf.size() * 2);
3317c3394,3396
<         n = static_cast<size_t>(_snprintf_s(&glowable_buf[0], glowable_buf.size(), glowable_buf.size() - 1, fmt, args...));
---
>       n = static_cast<size_t>(_snprintf_s(&glowable_buf[0], glowable_buf.size(),
>                                           glowable_buf.size() - 1, fmt,
>                                           args...));
3319c3398,3399
<         n = static_cast<size_t>(snprintf(&glowable_buf[0], glowable_buf.size() - 1, fmt, args...));
---
>       n = static_cast<size_t>(
>           snprintf(&glowable_buf[0], glowable_buf.size() - 1, fmt, args...));
3321,3324d3400
<       }
<       return write(&glowable_buf[0], n);
<     } else {
<       return write(buf.data(), n);
3325a3402,3404
>     return write(&glowable_buf[0], n);
>   } else {
>     return write(buf.data(), n);
3326a3406
> }
3328c3408
<   namespace detail {
---
> namespace detail {
3330,3337c3410,3418
<     // Socket stream implementation
<     inline SocketStream::SocketStream(socket_t sock, time_t read_timeout_sec, time_t read_timeout_usec, time_t write_timeout_sec,
<                                       time_t write_timeout_usec) :
<         sock_(sock),
<         read_timeout_sec_(read_timeout_sec),
<         read_timeout_usec_(read_timeout_usec),
<         write_timeout_sec_(write_timeout_sec),
<         write_timeout_usec_(write_timeout_usec) {}
---
> // Socket stream implementation
> inline SocketStream::SocketStream(socket_t sock, time_t read_timeout_sec,
>                                   time_t read_timeout_usec,
>                                   time_t write_timeout_sec,
>                                   time_t write_timeout_usec)
>     : sock_(sock), read_timeout_sec_(read_timeout_sec),
>       read_timeout_usec_(read_timeout_usec),
>       write_timeout_sec_(write_timeout_sec),
>       write_timeout_usec_(write_timeout_usec) {}
3339c3420
<     inline SocketStream::~SocketStream() {}
---
> inline SocketStream::~SocketStream() {}
3341c3422,3424
<     inline bool SocketStream::is_readable() const { return select_read(sock_, read_timeout_sec_, read_timeout_usec_) > 0; }
---
> inline bool SocketStream::is_readable() const {
>   return select_read(sock_, read_timeout_sec_, read_timeout_usec_) > 0;
> }
3343c3426,3428
<     inline bool SocketStream::is_writable() const { return select_write(sock_, write_timeout_sec_, write_timeout_usec_) > 0; }
---
> inline bool SocketStream::is_writable() const {
>   return select_write(sock_, write_timeout_sec_, write_timeout_usec_) > 0;
> }
3345,3348c3430,3431
<     inline ssize_t SocketStream::read(char *ptr, size_t size) {
<       if (!is_readable()) {
<         return -1;
<       }
---
> inline ssize_t SocketStream::read(char *ptr, size_t size) {
>   if (!is_readable()) { return -1; }
3351,3354c3434,3437
<       if (size > static_cast<size_t>((std::numeric_limits<int>::max)())) {
<         return -1;
<       }
<       return recv(sock_, ptr, static_cast<int>(size), 0);
---
>   if (size > static_cast<size_t>((std::numeric_limits<int>::max)())) {
>     return -1;
>   }
>   return recv(sock_, ptr, static_cast<int>(size), 0);
3356c3439
<       return HANDLE_EINTR(recv, sock_, ptr, size, 0);
---
>   return HANDLE_EINTR(recv, sock_, ptr, size, 0);
3358c3441
<     }
---
> }
3360,3363c3443,3444
<     inline ssize_t SocketStream::write(const char *ptr, size_t size) {
<       if (!is_writable()) {
<         return -1;
<       }
---
> inline ssize_t SocketStream::write(const char *ptr, size_t size) {
>   if (!is_writable()) { return -1; }
3366,3369c3447,3450
<       if (size > static_cast<size_t>((std::numeric_limits<int>::max)())) {
<         return -1;
<       }
<       return send(sock_, ptr, static_cast<int>(size), 0);
---
>   if (size > static_cast<size_t>((std::numeric_limits<int>::max)())) {
>     return -1;
>   }
>   return send(sock_, ptr, static_cast<int>(size), 0);
3371c3452
<       return HANDLE_EINTR(send, sock_, ptr, size, 0);
---
>   return HANDLE_EINTR(send, sock_, ptr, size, 0);
3373c3454
<     }
---
> }
3375,3377c3456,3459
<     inline void SocketStream::get_remote_ip_and_port(std::string &ip, int &port) const {
<       return detail::get_remote_ip_and_port(sock_, ip, port);
<     }
---
> inline void SocketStream::get_remote_ip_and_port(std::string &ip,
>                                                  int &port) const {
>   return detail::get_remote_ip_and_port(sock_, ip, port);
> }
3379,3380c3461,3462
<     // Buffer stream implementation
<     inline bool BufferStream::is_readable() const { return true; }
---
> // Buffer stream implementation
> inline bool BufferStream::is_readable() const { return true; }
3382c3464
<     inline bool BufferStream::is_writable() const { return true; }
---
> inline bool BufferStream::is_writable() const { return true; }
3384c3466
<     inline ssize_t BufferStream::read(char *ptr, size_t size) {
---
> inline ssize_t BufferStream::read(char *ptr, size_t size) {
3386c3468
<       auto len_read = buffer._Copy_s(ptr, size, size, position);
---
>   auto len_read = buffer._Copy_s(ptr, size, size, position);
3388c3470
<       auto len_read = buffer.copy(ptr, size, position);
---
>   auto len_read = buffer.copy(ptr, size, position);
3390,3392c3472,3474
<       position += static_cast<size_t>(len_read);
<       return static_cast<ssize_t>(len_read);
<     }
---
>   position += static_cast<size_t>(len_read);
>   return static_cast<ssize_t>(len_read);
> }
3394,3397c3476,3479
<     inline ssize_t BufferStream::write(const char *ptr, size_t size) {
<       buffer.append(ptr, size);
<       return static_cast<ssize_t>(size);
<     }
---
> inline ssize_t BufferStream::write(const char *ptr, size_t size) {
>   buffer.append(ptr, size);
>   return static_cast<ssize_t>(size);
> }
3399c3481,3482
<     inline void BufferStream::get_remote_ip_and_port(std::string & /*ip*/, int & /*port*/) const {}
---
> inline void BufferStream::get_remote_ip_and_port(std::string & /*ip*/,
>                                                  int & /*port*/) const {}
3401c3484
<     inline const std::string &BufferStream::get_buffer() const { return buffer; }
---
> inline const std::string &BufferStream::get_buffer() const { return buffer; }
3403c3486
<   }  // namespace detail
---
> } // namespace detail
3405,3406c3488,3489
<   // HTTP server implementation
<   inline Server::Server() : is_running_(false), svr_sock_(INVALID_SOCKET) {
---
> // HTTP server implementation
> inline Server::Server() : is_running_(false), svr_sock_(INVALID_SOCKET) {
3408c3491
<     signal(SIGPIPE, SIG_IGN);
---
>   signal(SIGPIPE, SIG_IGN);
3410,3411c3493,3494
<     new_task_queue = [] { return new ThreadPool(CPPHTTPLIB_THREAD_POOL_COUNT); };
<   }
---
>   new_task_queue = [] { return new ThreadPool(CPPHTTPLIB_THREAD_POOL_COUNT); };
> }
3413c3496
<   inline Server::~Server() {}
---
> inline Server::~Server() {}
3415,3418c3498,3501
<   inline Server &Server::Get(const char *pattern, Handler handler) {
<     get_handlers_.push_back(std::make_pair(std::regex(pattern), handler));
<     return *this;
<   }
---
> inline Server &Server::Get(const char *pattern, Handler handler) {
>   get_handlers_.push_back(std::make_pair(std::regex(pattern), handler));
>   return *this;
> }
3420,3423c3503,3506
<   inline Server &Server::Post(const char *pattern, Handler handler) {
<     post_handlers_.push_back(std::make_pair(std::regex(pattern), handler));
<     return *this;
<   }
---
> inline Server &Server::Post(const char *pattern, Handler handler) {
>   post_handlers_.push_back(std::make_pair(std::regex(pattern), handler));
>   return *this;
> }
3425,3428c3508,3513
<   inline Server &Server::Post(const char *pattern, HandlerWithContentReader handler) {
<     post_handlers_for_content_reader_.push_back(std::make_pair(std::regex(pattern), handler));
<     return *this;
<   }
---
> inline Server &Server::Post(const char *pattern,
>                             HandlerWithContentReader handler) {
>   post_handlers_for_content_reader_.push_back(
>       std::make_pair(std::regex(pattern), handler));
>   return *this;
> }
3430,3433c3515,3518
<   inline Server &Server::Put(const char *pattern, Handler handler) {
<     put_handlers_.push_back(std::make_pair(std::regex(pattern), handler));
<     return *this;
<   }
---
> inline Server &Server::Put(const char *pattern, Handler handler) {
>   put_handlers_.push_back(std::make_pair(std::regex(pattern), handler));
>   return *this;
> }
3435,3438c3520,3525
<   inline Server &Server::Put(const char *pattern, HandlerWithContentReader handler) {
<     put_handlers_for_content_reader_.push_back(std::make_pair(std::regex(pattern), handler));
<     return *this;
<   }
---
> inline Server &Server::Put(const char *pattern,
>                            HandlerWithContentReader handler) {
>   put_handlers_for_content_reader_.push_back(
>       std::make_pair(std::regex(pattern), handler));
>   return *this;
> }
3440,3443c3527,3530
<   inline Server &Server::Patch(const char *pattern, Handler handler) {
<     patch_handlers_.push_back(std::make_pair(std::regex(pattern), handler));
<     return *this;
<   }
---
> inline Server &Server::Patch(const char *pattern, Handler handler) {
>   patch_handlers_.push_back(std::make_pair(std::regex(pattern), handler));
>   return *this;
> }
3445,3448c3532,3537
<   inline Server &Server::Patch(const char *pattern, HandlerWithContentReader handler) {
<     patch_handlers_for_content_reader_.push_back(std::make_pair(std::regex(pattern), handler));
<     return *this;
<   }
---
> inline Server &Server::Patch(const char *pattern,
>                              HandlerWithContentReader handler) {
>   patch_handlers_for_content_reader_.push_back(
>       std::make_pair(std::regex(pattern), handler));
>   return *this;
> }
3450,3453c3539,3542
<   inline Server &Server::Delete(const char *pattern, Handler handler) {
<     delete_handlers_.push_back(std::make_pair(std::regex(pattern), handler));
<     return *this;
<   }
---
> inline Server &Server::Delete(const char *pattern, Handler handler) {
>   delete_handlers_.push_back(std::make_pair(std::regex(pattern), handler));
>   return *this;
> }
3455,3458c3544,3549
<   inline Server &Server::Delete(const char *pattern, HandlerWithContentReader handler) {
<     delete_handlers_for_content_reader_.push_back(std::make_pair(std::regex(pattern), handler));
<     return *this;
<   }
---
> inline Server &Server::Delete(const char *pattern,
>                               HandlerWithContentReader handler) {
>   delete_handlers_for_content_reader_.push_back(
>       std::make_pair(std::regex(pattern), handler));
>   return *this;
> }
3460,3463c3551,3554
<   inline Server &Server::Options(const char *pattern, Handler handler) {
<     options_handlers_.push_back(std::make_pair(std::regex(pattern), handler));
<     return *this;
<   }
---
> inline Server &Server::Options(const char *pattern, Handler handler) {
>   options_handlers_.push_back(std::make_pair(std::regex(pattern), handler));
>   return *this;
> }
3465c3556,3558
<   inline bool Server::set_base_dir(const char *dir, const char *mount_point) { return set_mount_point(mount_point, dir); }
---
> inline bool Server::set_base_dir(const char *dir, const char *mount_point) {
>   return set_mount_point(mount_point, dir);
> }
3467,3473c3560,3565
<   inline bool Server::set_mount_point(const char *mount_point, const char *dir) {
<     if (detail::is_dir(dir)) {
<       std::string mnt = mount_point ? mount_point : "/";
<       if (!mnt.empty() && mnt[0] == '/') {
<         base_dirs_.emplace_back(mnt, dir);
<         return true;
<       }
---
> inline bool Server::set_mount_point(const char *mount_point, const char *dir) {
>   if (detail::is_dir(dir)) {
>     std::string mnt = mount_point ? mount_point : "/";
>     if (!mnt.empty() && mnt[0] == '/') {
>       base_dirs_.emplace_back(mnt, dir);
>       return true;
3475d3566
<     return false;
3476a3568,3569
>   return false;
> }
3478,3483c3571,3575
<   inline bool Server::remove_mount_point(const char *mount_point) {
<     for (auto it = base_dirs_.begin(); it != base_dirs_.end(); ++it) {
<       if (it->first == mount_point) {
<         base_dirs_.erase(it);
<         return true;
<       }
---
> inline bool Server::remove_mount_point(const char *mount_point) {
>   for (auto it = base_dirs_.begin(); it != base_dirs_.end(); ++it) {
>     if (it->first == mount_point) {
>       base_dirs_.erase(it);
>       return true;
3485d3576
<     return false;
3486a3578,3579
>   return false;
> }
3488,3490c3581,3584
<   inline void Server::set_file_extension_and_mimetype_mapping(const char *ext, const char *mime) {
<     file_extension_and_mimetype_map_[ext] = mime;
<   }
---
> inline void Server::set_file_extension_and_mimetype_mapping(const char *ext,
>                                                             const char *mime) {
>   file_extension_and_mimetype_map_[ext] = mime;
> }
3492c3586,3588
<   inline void Server::set_file_request_handler(Handler handler) { file_request_handler_ = std::move(handler); }
---
> inline void Server::set_file_request_handler(Handler handler) {
>   file_request_handler_ = std::move(handler);
> }
3494c3590,3592
<   inline void Server::set_error_handler(Handler handler) { error_handler_ = std::move(handler); }
---
> inline void Server::set_error_handler(Handler handler) {
>   error_handler_ = std::move(handler);
> }
3496c3594
<   inline void Server::set_logger(Logger logger) { logger_ = std::move(logger); }
---
> inline void Server::set_logger(Logger logger) { logger_ = std::move(logger); }
3498,3500c3596,3599
<   inline void Server::set_expect_100_continue_handler(Expect100ContinueHandler handler) {
<     expect_100_continue_handler_ = std::move(handler);
<   }
---
> inline void
> Server::set_expect_100_continue_handler(Expect100ContinueHandler handler) {
>   expect_100_continue_handler_ = std::move(handler);
> }
3502c3601,3603
<   inline void Server::set_keep_alive_max_count(size_t count) { keep_alive_max_count_ = count; }
---
> inline void Server::set_keep_alive_max_count(size_t count) {
>   keep_alive_max_count_ = count;
> }
3504,3507c3605,3608
<   inline void Server::set_read_timeout(time_t sec, time_t usec) {
<     read_timeout_sec_ = sec;
<     read_timeout_usec_ = usec;
<   }
---
> inline void Server::set_read_timeout(time_t sec, time_t usec) {
>   read_timeout_sec_ = sec;
>   read_timeout_usec_ = usec;
> }
3509,3512c3610,3613
<   inline void Server::set_write_timeout(time_t sec, time_t usec) {
<     write_timeout_sec_ = sec;
<     write_timeout_usec_ = usec;
<   }
---
> inline void Server::set_write_timeout(time_t sec, time_t usec) {
>   write_timeout_sec_ = sec;
>   write_timeout_usec_ = usec;
> }
3514,3517c3615,3618
<   inline void Server::set_idle_interval(time_t sec, time_t usec) {
<     idle_interval_sec_ = sec;
<     idle_interval_usec_ = usec;
<   }
---
> inline void Server::set_idle_interval(time_t sec, time_t usec) {
>   idle_interval_sec_ = sec;
>   idle_interval_usec_ = usec;
> }
3519c3620,3622
<   inline void Server::set_payload_max_length(size_t length) { payload_max_length_ = length; }
---
> inline void Server::set_payload_max_length(size_t length) {
>   payload_max_length_ = length;
> }
3521,3526c3624,3632
<   inline bool Server::bind_to_port(const char *host, int port, int socket_flags) {
<     if (bind_internal(host, port, socket_flags) < 0)
<       return false;
<     return true;
<   }
<   inline int Server::bind_to_any_port(const char *host, int socket_flags) { return bind_internal(host, 0, socket_flags); }
---
> inline bool Server::bind_to_port(const char *host, int port, int socket_flags) {
>   if (bind_internal(host, port, socket_flags) < 0) return false;
>   return true;
> }
> inline int Server::bind_to_any_port(const char *host, int socket_flags) {
>   return bind_internal(host, 0, socket_flags);
> }
> 
> inline bool Server::listen_after_bind() { return listen_internal(); }
3528c3634,3638
<   inline bool Server::listen_after_bind() { return listen_internal(); }
---
> inline bool Server::listen(const char *host, int port, int socket_flags) {
>   return bind_to_port(host, port, socket_flags) && listen_internal();
> }
> 
> inline bool Server::is_running() const { return is_running_; }
3530,3531c3640,3645
<   inline bool Server::listen(const char *host, int port, int socket_flags) {
<     return bind_to_port(host, port, socket_flags) && listen_internal();
---
> inline void Server::stop() {
>   if (is_running_) {
>     assert(svr_sock_ != INVALID_SOCKET);
>     std::atomic<socket_t> sock(svr_sock_.exchange(INVALID_SOCKET));
>     detail::shutdown_socket(sock);
>     detail::close_socket(sock);
3532a3647
> }
3534c3649,3663
<   inline bool Server::is_running() const { return is_running_; }
---
> inline bool Server::parse_request_line(const char *s, Request &req) {
>   const static std::regex re(
>       "(GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|PRI) "
>       "(([^?]+)(?:\\?(.*?))?) (HTTP/1\\.[01])\r\n");
> 
>   std::cmatch m;
>   if (std::regex_match(s, m, re)) {
>     req.version = std::string(m[5]);
>     req.method = std::string(m[1]);
>     req.target = std::string(m[2]);
>     req.path = detail::decode_url(m[3], false);
> 
>     // Parse query text
>     auto len = std::distance(m[4].first, m[4].second);
>     if (len > 0) { detail::parse_query_text(m[4], req.params); }
3536,3542c3665
<   inline void Server::stop() {
<     if (is_running_) {
<       assert(svr_sock_ != INVALID_SOCKET);
<       std::atomic<socket_t> sock(svr_sock_.exchange(INVALID_SOCKET));
<       detail::shutdown_socket(sock);
<       detail::close_socket(sock);
<     }
---
>     return true;
3545,3547c3668,3673
<   inline bool Server::parse_request_line(const char *s, Request &req) {
<     const static std::regex re("(GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|PRI) "
<                                "(([^?]+)(?:\\?(.*?))?) (HTTP/1\\.[01])\r\n");
---
>   return false;
> }
> 
> inline bool Server::write_response(Stream &strm, bool last_connection,
>                                    const Request &req, Response &res) {
>   assert(res.status != -1);
3549,3560c3675
<     std::cmatch m;
<     if (std::regex_match(s, m, re)) {
<       req.version = std::string(m[5]);
<       req.method = std::string(m[1]);
<       req.target = std::string(m[2]);
<       req.path = detail::decode_url(m[3], false);
< 
<       // Parse query text
<       auto len = std::distance(m[4].first, m[4].second);
<       if (len > 0) {
<         detail::parse_query_text(m[4], req.params);
<       }
---
>   if (400 <= res.status && error_handler_) { error_handler_(req, res); }
3562,3563c3677
<       return true;
<     }
---
>   detail::BufferStream bstrm;
3564a3679,3681
>   // Response line
>   if (!bstrm.write_format("HTTP/1.1 %d %s\r\n", res.status,
>                           detail::status_message(res.status))) {
3568,3573c3685,3688
<   inline bool Server::write_response(Stream &strm, bool last_connection, const Request &req, Response &res) {
<     assert(res.status != -1);
< 
<     if (400 <= res.status && error_handler_) {
<       error_handler_(req, res);
<     }
---
>   // Headers
>   if (last_connection || req.get_header_value("Connection") == "close") {
>     res.set_header("Connection", "close");
>   }
3575c3690,3692
<     detail::BufferStream bstrm;
---
>   if (!last_connection && req.get_header_value("Connection") == "Keep-Alive") {
>     res.set_header("Connection", "Keep-Alive");
>   }
3577,3580c3694,3697
<     // Response line
<     if (!bstrm.write_format("HTTP/1.1 %d %s\r\n", res.status, detail::status_message(res.status))) {
<       return false;
<     }
---
>   if (!res.has_header("Content-Type") &&
>       (!res.body.empty() || res.content_length_ > 0)) {
>     res.set_header("Content-Type", "text/plain");
>   }
3582,3585c3699,3701
<     // Headers
<     if (last_connection || req.get_header_value("Connection") == "close") {
<       res.set_header("Connection", "close");
<     }
---
>   if (!res.has_header("Accept-Ranges") && req.method == "HEAD") {
>     res.set_header("Accept-Ranges", "bytes");
>   }
3587,3589c3703,3704
<     if (!last_connection && req.get_header_value("Connection") == "Keep-Alive") {
<       res.set_header("Connection", "Keep-Alive");
<     }
---
>   std::string content_type;
>   std::string boundary;
3591,3593c3706,3707
<     if (!res.has_header("Content-Type") && (!res.body.empty() || res.content_length_ > 0)) {
<       res.set_header("Content-Type", "text/plain");
<     }
---
>   if (req.ranges.size() > 1) {
>     boundary = detail::make_multipart_data_boundary();
3595,3596c3709,3712
<     if (!res.has_header("Accept-Ranges") && req.method == "HEAD") {
<       res.set_header("Accept-Ranges", "bytes");
---
>     auto it = res.headers.find("Content-Type");
>     if (it != res.headers.end()) {
>       content_type = it->second;
>       res.headers.erase(it);
3599,3603c3715,3717
<     std::string content_type;
<     std::string boundary;
< 
<     if (req.ranges.size() > 1) {
<       boundary = detail::make_multipart_data_boundary();
---
>     res.headers.emplace("Content-Type",
>                         "multipart/byteranges; boundary=" + boundary);
>   }
3605,3636c3719,3721
<       auto it = res.headers.find("Content-Type");
<       if (it != res.headers.end()) {
<         content_type = it->second;
<         res.headers.erase(it);
<       }
< 
<       res.headers.emplace("Content-Type", "multipart/byteranges; boundary=" + boundary);
<     }
< 
<     if (res.body.empty()) {
<       if (res.content_length_ > 0) {
<         size_t length = 0;
<         if (req.ranges.empty()) {
<           length = res.content_length_;
<         } else if (req.ranges.size() == 1) {
<           auto offsets = detail::get_range_offset_and_length(req, res.content_length_, 0);
<           auto offset = offsets.first;
<           length = offsets.second;
<           auto content_range = detail::make_content_range_header_field(offset, length, res.content_length_);
<           res.set_header("Content-Range", content_range);
<         } else {
<           length = detail::get_multipart_ranges_data_length(req, res, boundary, content_type);
<         }
<         res.set_header("Content-Length", std::to_string(length));
<       } else {
<         if (res.content_provider_) {
<           res.set_header("Transfer-Encoding", "chunked");
<         } else {
<           res.set_header("Content-Length", "0");
<         }
<       }
<     } else {
---
>   if (res.body.empty()) {
>     if (res.content_length_ > 0) {
>       size_t length = 0;
3638c3723
<         ;
---
>         length = res.content_length_;
3640c3725,3726
<         auto offsets = detail::get_range_offset_and_length(req, res.body.size(), 0);
---
>         auto offsets =
>             detail::get_range_offset_and_length(req, res.content_length_, 0);
3642,3643c3728,3730
<         auto length = offsets.second;
<         auto content_range = detail::make_content_range_header_field(offset, length, res.body.size());
---
>         length = offsets.second;
>         auto content_range = detail::make_content_range_header_field(
>             offset, length, res.content_length_);
3645d3731
<         res.body = res.body.substr(offset, length);
3647c3733,3741
<         res.body = detail::make_multipart_ranges_data(req, res, boundary, content_type);
---
>         length = detail::get_multipart_ranges_data_length(req, res, boundary,
>                                                           content_type);
>       }
>       res.set_header("Content-Length", std::to_string(length));
>     } else {
>       if (res.content_provider_) {
>         res.set_header("Transfer-Encoding", "chunked");
>       } else {
>         res.set_header("Content-Length", "0");
3648a3743,3759
>     }
>   } else {
>     if (req.ranges.empty()) {
>       ;
>     } else if (req.ranges.size() == 1) {
>       auto offsets =
>           detail::get_range_offset_and_length(req, res.body.size(), 0);
>       auto offset = offsets.first;
>       auto length = offsets.second;
>       auto content_range = detail::make_content_range_header_field(
>           offset, length, res.body.size());
>       res.set_header("Content-Range", content_range);
>       res.body = res.body.substr(offset, length);
>     } else {
>       res.body =
>           detail::make_multipart_ranges_data(req, res, boundary, content_type);
>     }
3651,3656c3762,3767
<       // TODO: 'Accept-Encoding' has gzip, not gzip;q=0
<       const auto &encodings = req.get_header_value("Accept-Encoding");
<       if (encodings.find("gzip") != std::string::npos && detail::can_compress(res.get_header_value("Content-Type"))) {
<         if (detail::compress(res.body)) {
<           res.set_header("Content-Encoding", "gzip");
<         }
---
>     // TODO: 'Accept-Encoding' has gzip, not gzip;q=0
>     const auto &encodings = req.get_header_value("Accept-Encoding");
>     if (encodings.find("gzip") != std::string::npos &&
>         detail::can_compress(res.get_header_value("Content-Type"))) {
>       if (detail::compress(res.body)) {
>         res.set_header("Content-Encoding", "gzip");
3657a3769
>     }
3660,3662c3772,3774
<       auto length = std::to_string(res.body.size());
<       res.set_header("Content-Length", length);
<     }
---
>     auto length = std::to_string(res.body.size());
>     res.set_header("Content-Length", length);
>   }
3664,3666c3776
<     if (!detail::write_headers(bstrm, res, Headers())) {
<       return false;
<     }
---
>   if (!detail::write_headers(bstrm, res, Headers())) { return false; }
3668,3681c3778,3789
<     // Flush buffer
<     auto &data = bstrm.get_buffer();
<     strm.write(data.data(), data.size());
< 
<     // Body
<     if (req.method != "HEAD") {
<       if (!res.body.empty()) {
<         if (!strm.write(res.body)) {
<           return false;
<         }
<       } else if (res.content_provider_) {
<         if (!write_content_with_provider(strm, req, res, boundary, content_type)) {
<           return false;
<         }
---
>   // Flush buffer
>   auto &data = bstrm.get_buffer();
>   strm.write(data.data(), data.size());
> 
>   // Body
>   if (req.method != "HEAD") {
>     if (!res.body.empty()) {
>       if (!strm.write(res.body)) { return false; }
>     } else if (res.content_provider_) {
>       if (!write_content_with_provider(strm, req, res, boundary,
>                                        content_type)) {
>         return false;
3683a3792
>   }
3685,3688c3794,3795
<     // Log
<     if (logger_) {
<       logger_(req, res);
<     }
---
>   // Log
>   if (logger_) { logger_(req, res); }
3690,3691c3797,3798
<     return true;
<   }
---
>   return true;
> }
3693,3710c3800,3817
<   inline bool Server::write_content_with_provider(Stream &strm, const Request &req, Response &res, const std::string &boundary,
<                                                   const std::string &content_type) {
<     if (res.content_length_) {
<       if (req.ranges.empty()) {
<         if (detail::write_content(strm, res.content_provider_, 0, res.content_length_) < 0) {
<           return false;
<         }
<       } else if (req.ranges.size() == 1) {
<         auto offsets = detail::get_range_offset_and_length(req, res.content_length_, 0);
<         auto offset = offsets.first;
<         auto length = offsets.second;
<         if (detail::write_content(strm, res.content_provider_, offset, length) < 0) {
<           return false;
<         }
<       } else {
<         if (!detail::write_multipart_ranges_data(strm, req, res, boundary, content_type)) {
<           return false;
<         }
---
> inline bool
> Server::write_content_with_provider(Stream &strm, const Request &req,
>                                     Response &res, const std::string &boundary,
>                                     const std::string &content_type) {
>   if (res.content_length_) {
>     if (req.ranges.empty()) {
>       if (detail::write_content(strm, res.content_provider_, 0,
>                                 res.content_length_) < 0) {
>         return false;
>       }
>     } else if (req.ranges.size() == 1) {
>       auto offsets =
>           detail::get_range_offset_and_length(req, res.content_length_, 0);
>       auto offset = offsets.first;
>       auto length = offsets.second;
>       if (detail::write_content(strm, res.content_provider_, offset, length) <
>           0) {
>         return false;
3713,3714c3820,3821
<       auto is_shutting_down = [this]() { return this->svr_sock_ == INVALID_SOCKET; };
<       if (detail::write_content_chunked(strm, res.content_provider_, is_shutting_down) < 0) {
---
>       if (!detail::write_multipart_ranges_data(strm, req, res, boundary,
>                                                content_type)) {
3718c3825,3832
<     return true;
---
>   } else {
>     auto is_shutting_down = [this]() {
>       return this->svr_sock_ == INVALID_SOCKET;
>     };
>     if (detail::write_content_chunked(strm, res.content_provider_,
>                                       is_shutting_down) < 0) {
>       return false;
>     }
3719a3834,3835
>   return true;
> }
3721,3750c3837,3860
<   inline bool Server::read_content(Stream &strm, Request &req, Response &res) {
<     MultipartFormDataMap::iterator cur;
<     if (read_content_core(
<             strm, req, res,
<             // Regular
<             [&](const char *buf, size_t n) {
<               if (req.body.size() + n > req.body.max_size()) {
<                 return false;
<               }
<               req.body.append(buf, n);
<               return true;
<             },
<             // Multipart
<             [&](const MultipartFormData &file) {
<               cur = req.files.emplace(file.name, file);
<               return true;
<             },
<             [&](const char *buf, size_t n) {
<               auto &content = cur->second.content;
<               if (content.size() + n > content.max_size()) {
<                 return false;
<               }
<               content.append(buf, n);
<               return true;
<             })) {
<       const auto &content_type = req.get_header_value("Content-Type");
<       if (!content_type.find("application/x-www-form-urlencoded")) {
<         detail::parse_query_text(req.body, req.params);
<       }
<       return true;
---
> inline bool Server::read_content(Stream &strm, Request &req, Response &res) {
>   MultipartFormDataMap::iterator cur;
>   if (read_content_core(
>           strm, req, res,
>           // Regular
>           [&](const char *buf, size_t n) {
>             if (req.body.size() + n > req.body.max_size()) { return false; }
>             req.body.append(buf, n);
>             return true;
>           },
>           // Multipart
>           [&](const MultipartFormData &file) {
>             cur = req.files.emplace(file.name, file);
>             return true;
>           },
>           [&](const char *buf, size_t n) {
>             auto &content = cur->second.content;
>             if (content.size() + n > content.max_size()) { return false; }
>             content.append(buf, n);
>             return true;
>           })) {
>     const auto &content_type = req.get_header_value("Content-Type");
>     if (!content_type.find("application/x-www-form-urlencoded")) {
>       detail::parse_query_text(req.body, req.params);
3752c3862
<     return false;
---
>     return true;
3753a3864,3865
>   return false;
> }
3755,3772c3867,3873
<   inline bool Server::read_content_with_content_receiver(Stream &strm, Request &req, Response &res, ContentReceiver receiver,
<                                                          MultipartContentHeader multipart_header,
<                                                          ContentReceiver multipart_receiver) {
<     return read_content_core(strm, req, res, receiver, multipart_header, multipart_receiver);
<   }
< 
<   inline bool Server::read_content_core(Stream &strm, Request &req, Response &res, ContentReceiver receiver,
<                                         MultipartContentHeader mulitpart_header, ContentReceiver multipart_receiver) {
<     detail::MultipartFormDataParser multipart_form_data_parser;
<     ContentReceiver out;
< 
<     if (req.is_multipart_form_data()) {
<       const auto &content_type = req.get_header_value("Content-Type");
<       std::string boundary;
<       if (!detail::parse_multipart_boundary(content_type, boundary)) {
<         res.status = 400;
<         return false;
<       }
---
> inline bool Server::read_content_with_content_receiver(
>     Stream &strm, Request &req, Response &res, ContentReceiver receiver,
>     MultipartContentHeader multipart_header,
>     ContentReceiver multipart_receiver) {
>   return read_content_core(strm, req, res, receiver, multipart_header,
>                            multipart_receiver);
> }
3774,3780c3875,3880
<       multipart_form_data_parser.set_boundary(std::move(boundary));
<       out = [&](const char *buf, size_t n) {
<         return multipart_form_data_parser.parse(buf, n, multipart_receiver, mulitpart_header);
<       };
<     } else {
<       out = receiver;
<     }
---
> inline bool Server::read_content_core(Stream &strm, Request &req, Response &res,
>                                       ContentReceiver receiver,
>                                       MultipartContentHeader mulitpart_header,
>                                       ContentReceiver multipart_receiver) {
>   detail::MultipartFormDataParser multipart_form_data_parser;
>   ContentReceiver out;
3782c3882,3886
<     if (!detail::read_content(strm, req, payload_max_length_, res.status, Progress(), out)) {
---
>   if (req.is_multipart_form_data()) {
>     const auto &content_type = req.get_header_value("Content-Type");
>     std::string boundary;
>     if (!detail::parse_multipart_boundary(content_type, boundary)) {
>       res.status = 400;
3786,3791c3890,3897
<     if (req.is_multipart_form_data()) {
<       if (!multipart_form_data_parser.is_valid()) {
<         res.status = 400;
<         return false;
<       }
<     }
---
>     multipart_form_data_parser.set_boundary(std::move(boundary));
>     out = [&](const char *buf, size_t n) {
>       return multipart_form_data_parser.parse(buf, n, multipart_receiver,
>                                               mulitpart_header);
>     };
>   } else {
>     out = receiver;
>   }
3793c3899,3901
<     return true;
---
>   if (!detail::read_content(strm, req, payload_max_length_, res.status,
>                             Progress(), out, true)) {
>     return false;
3796,3808c3904,3909
<   inline bool Server::handle_file_request(Request &req, Response &res, bool head) {
<     for (const auto &kv : base_dirs_) {
<       const auto &mount_point = kv.first;
<       const auto &base_dir = kv.second;
< 
<       // Prefix match
<       if (!req.path.find(mount_point)) {
<         std::string sub_path = "/" + req.path.substr(mount_point.size());
<         if (detail::is_valid_path(sub_path)) {
<           auto path = base_dir + sub_path;
<           if (path.back() == '/') {
<             path += "index.html";
<           }
---
>   if (req.is_multipart_form_data()) {
>     if (!multipart_form_data_parser.is_valid()) {
>       res.status = 400;
>       return false;
>     }
>   }
3810,3820c3911,3934
<           if (detail::is_file(path)) {
<             detail::read_file(path, res.body);
<             auto type = detail::find_content_type(path, file_extension_and_mimetype_map_);
<             if (type) {
<               res.set_header("Content-Type", type);
<             }
<             res.status = 200;
<             if (!head && file_request_handler_) {
<               file_request_handler_(req, res);
<             }
<             return true;
---
>   return true;
> }
> 
> inline bool Server::handle_file_request(Request &req, Response &res,
>                                         bool head) {
>   for (const auto &kv : base_dirs_) {
>     const auto &mount_point = kv.first;
>     const auto &base_dir = kv.second;
> 
>     // Prefix match
>     if (!req.path.find(mount_point)) {
>       std::string sub_path = "/" + req.path.substr(mount_point.size());
>       if (detail::is_valid_path(sub_path)) {
>         auto path = base_dir + sub_path;
>         if (path.back() == '/') { path += "index.html"; }
> 
>         if (detail::is_file(path)) {
>           detail::read_file(path, res.body);
>           auto type =
>               detail::find_content_type(path, file_extension_and_mimetype_map_);
>           if (type) { res.set_header("Content-Type", type); }
>           res.status = 200;
>           if (!head && file_request_handler_) {
>             file_request_handler_(req, res);
3821a3936
>           return true;
3825d3939
<     return false;
3826a3941,3942
>   return false;
> }
3828,3841c3944,3958
<   inline socket_t Server::create_server_socket(const char *host, int port, int socket_flags) const {
<     return detail::create_socket(
<         host, port,
<         [](socket_t sock, struct addrinfo &ai) -> bool {
<           if (::bind(sock, ai.ai_addr, static_cast<socklen_t>(ai.ai_addrlen))) {
<             return false;
<           }
<           if (::listen(sock, 5)) {  // Listen through 5 channels
<             return false;
<           }
<           return true;
<         },
<         socket_flags);
<   }
---
> inline socket_t Server::create_server_socket(const char *host, int port,
>                                              int socket_flags) const {
>   return detail::create_socket(
>       host, port,
>       [](socket_t sock, struct addrinfo &ai) -> bool {
>         if (::bind(sock, ai.ai_addr, static_cast<socklen_t>(ai.ai_addrlen))) {
>           return false;
>         }
>         if (::listen(sock, 5)) { // Listen through 5 channels
>           return false;
>         }
>         return true;
>       },
>       socket_flags);
> }
3843,3846c3960,3964
<   inline int Server::bind_internal(const char *host, int port, int socket_flags) {
<     if (!is_valid()) {
<       return -1;
<     }
---
> inline int Server::bind_internal(const char *host, int port, int socket_flags) {
>   if (!is_valid()) { return -1; }
> 
>   svr_sock_ = create_server_socket(host, port, socket_flags);
>   if (svr_sock_ == INVALID_SOCKET) { return -1; }
3848,3849c3966,3970
<     svr_sock_ = create_server_socket(host, port, socket_flags);
<     if (svr_sock_ == INVALID_SOCKET) {
---
>   if (port == 0) {
>     struct sockaddr_storage addr;
>     socklen_t addr_len = sizeof(addr);
>     if (getsockname(svr_sock_, reinterpret_cast<struct sockaddr *>(&addr),
>                     &addr_len) == -1) {
3852,3865c3973,3976
< 
<     if (port == 0) {
<       struct sockaddr_storage addr;
<       socklen_t addr_len = sizeof(addr);
<       if (getsockname(svr_sock_, reinterpret_cast<struct sockaddr *>(&addr), &addr_len) == -1) {
<         return -1;
<       }
<       if (addr.ss_family == AF_INET) {
<         return ntohs(reinterpret_cast<struct sockaddr_in *>(&addr)->sin_port);
<       } else if (addr.ss_family == AF_INET6) {
<         return ntohs(reinterpret_cast<struct sockaddr_in6 *>(&addr)->sin6_port);
<       } else {
<         return -1;
<       }
---
>     if (addr.ss_family == AF_INET) {
>       return ntohs(reinterpret_cast<struct sockaddr_in *>(&addr)->sin_port);
>     } else if (addr.ss_family == AF_INET6) {
>       return ntohs(reinterpret_cast<struct sockaddr_in6 *>(&addr)->sin6_port);
3867c3978
<       return port;
---
>       return -1;
3868a3980,3981
>   } else {
>     return port;
3869a3983
> }
3871,3873c3985,3987
<   inline bool Server::listen_internal() {
<     auto ret = true;
<     is_running_ = true;
---
> inline bool Server::listen_internal() {
>   auto ret = true;
>   is_running_ = true;
3875,3878c3989,3990
<     {
< #ifndef __SWITCH__
<       std::unique_ptr<TaskQueue> task_queue(new_task_queue());
< #endif
---
>   {
>     std::unique_ptr<TaskQueue> task_queue(new_task_queue());
3880,3891c3992,3994
<       while (svr_sock_ != INVALID_SOCKET) {
< #if !defined(_WIN32) && !defined(__SWITCH__)
<         if (idle_interval_sec_ > 0 || idle_interval_usec_ > 0) {
< #endif
< #ifdef __SWITCH__
<           auto val = detail::select_read(svr_sock_, 0, 100000);
< #else
<         auto val = detail::select_read(svr_sock_, idle_interval_sec_, idle_interval_usec_);
< #endif
<           if (val == 0) {  // Timeout
< #ifndef __SWITCH__
<             task_queue->on_idle();
---
>     while (svr_sock_ != INVALID_SOCKET) {
> #ifndef _WIN32
>       if (idle_interval_sec_ > 0 || idle_interval_usec_ > 0) {
3893,3895c3996,4000
<             continue;
<           }
< #if !defined(_WIN32) && !defined(__SWITCH__)
---
>         auto val = detail::select_read(svr_sock_, idle_interval_sec_,
>                                        idle_interval_usec_);
>         if (val == 0) { // Timeout
>           task_queue->on_idle();
>           continue;
3896a4002,4003
> #ifndef _WIN32
>       }
3898c4005
<         socket_t sock = accept(svr_sock_, nullptr, nullptr);
---
>       socket_t sock = accept(svr_sock_, nullptr, nullptr);
3900,3913c4007,4012
<         if (sock == INVALID_SOCKET) {
<           if (errno == EMFILE) {
<             // The per-process limit of open file descriptors has been reached.
<             // Try to accept new connections after a short sleep.
<             std::this_thread::sleep_for(std::chrono::milliseconds(1));
<             continue;
<           }
<           if (svr_sock_ != INVALID_SOCKET) {
<             detail::close_socket(svr_sock_);
<             ret = false;
<           } else {
<             ;  // The server socket was closed by user.
<           }
<           break;
---
>       if (sock == INVALID_SOCKET) {
>         if (errno == EMFILE) {
>           // The per-process limit of open file descriptors has been reached.
>           // Try to accept new connections after a short sleep.
>           std::this_thread::sleep_for(std::chrono::milliseconds(1));
>           continue;
3915,3922c4014,4020
< 
< #ifdef __SWITCH__
<         process_and_close_socket(sock);
< #elif __cplusplus > 201703L
<         task_queue->enqueue([=, this]() { process_and_close_socket(sock); });
< #else
<         task_queue->enqueue([=]() { process_and_close_socket(sock); });
< #endif
---
>         if (svr_sock_ != INVALID_SOCKET) {
>           detail::close_socket(svr_sock_);
>           ret = false;
>         } else {
>           ; // The server socket was closed by user.
>         }
>         break;
3925,3926c4023,4026
< #ifndef __SWITCH__
<       task_queue->shutdown();
---
> #if __cplusplus > 201703L
>       task_queue->enqueue([=, this]() { process_and_close_socket(sock); });
> #else
>       task_queue->enqueue([=]() { process_and_close_socket(sock); });
3930,3931c4030
<     is_running_ = false;
<     return ret;
---
>     task_queue->shutdown();
3934,3939c4033,4035
<   inline bool Server::routing(Request &req, Response &res, Stream &strm) {
<     // File handler
<     bool is_head_request = req.method == "HEAD";
<     if ((req.method == "GET" || is_head_request) && handle_file_request(req, res, is_head_request)) {
<       return true;
<     }
---
>   is_running_ = false;
>   return ret;
> }
3941,3950c4037,4043
<     if (detail::expect_content(req)) {
<       // Content reader handler
<       {
<         ContentReader reader(
<             [&](ContentReceiver receiver) {
<               return read_content_with_content_receiver(strm, req, res, receiver, nullptr, nullptr);
<             },
<             [&](MultipartContentHeader header, ContentReceiver receiver) {
<               return read_content_with_content_receiver(strm, req, res, nullptr, header, receiver);
<             });
---
> inline bool Server::routing(Request &req, Response &res, Stream &strm) {
>   // File handler
>   bool is_head_request = req.method == "HEAD";
>   if ((req.method == "GET" || is_head_request) &&
>       handle_file_request(req, res, is_head_request)) {
>     return true;
>   }
3952,3969c4045,4056
<         if (req.method == "POST") {
<           if (dispatch_request_for_content_reader(req, res, reader, post_handlers_for_content_reader_)) {
<             return true;
<           }
<         } else if (req.method == "PUT") {
<           if (dispatch_request_for_content_reader(req, res, reader, put_handlers_for_content_reader_)) {
<             return true;
<           }
<         } else if (req.method == "PATCH") {
<           if (dispatch_request_for_content_reader(req, res, reader, patch_handlers_for_content_reader_)) {
<             return true;
<           }
<         } else if (req.method == "DELETE") {
<           if (dispatch_request_for_content_reader(req, res, reader, delete_handlers_for_content_reader_)) {
<             return true;
<           }
<         }
<       }
---
>   if (detail::expect_content(req)) {
>     // Content reader handler
>     {
>       ContentReader reader(
>           [&](ContentReceiver receiver) {
>             return read_content_with_content_receiver(strm, req, res, receiver,
>                                                       nullptr, nullptr);
>           },
>           [&](MultipartContentHeader header, ContentReceiver receiver) {
>             return read_content_with_content_receiver(strm, req, res, nullptr,
>                                                       header, receiver);
>           });
3971,3973c4058,4077
<       // Read content into `req.body`
<       if (!read_content(strm, req, res)) {
<         return false;
---
>       if (req.method == "POST") {
>         if (dispatch_request_for_content_reader(
>                 req, res, reader, post_handlers_for_content_reader_)) {
>           return true;
>         }
>       } else if (req.method == "PUT") {
>         if (dispatch_request_for_content_reader(
>                 req, res, reader, put_handlers_for_content_reader_)) {
>           return true;
>         }
>       } else if (req.method == "PATCH") {
>         if (dispatch_request_for_content_reader(
>                 req, res, reader, patch_handlers_for_content_reader_)) {
>           return true;
>         }
>       } else if (req.method == "DELETE") {
>         if (dispatch_request_for_content_reader(
>                 req, res, reader, delete_handlers_for_content_reader_)) {
>           return true;
>         }
3977,3993c4081,4082
<     // Regular handler
<     if (req.method == "GET" || req.method == "HEAD") {
<       return dispatch_request(req, res, get_handlers_);
<     } else if (req.method == "POST") {
<       return dispatch_request(req, res, post_handlers_);
<     } else if (req.method == "PUT") {
<       return dispatch_request(req, res, put_handlers_);
<     } else if (req.method == "DELETE") {
<       return dispatch_request(req, res, delete_handlers_);
<     } else if (req.method == "OPTIONS") {
<       return dispatch_request(req, res, options_handlers_);
<     } else if (req.method == "PATCH") {
<       return dispatch_request(req, res, patch_handlers_);
<     }
< 
<     res.status = 400;
<     return false;
---
>     // Read content into `req.body`
>     if (!read_content(strm, req, res)) { return false; }
3996c4085,4098
<   inline bool Server::dispatch_request(Request &req, Response &res, Handlers &handlers) {
---
>   // Regular handler
>   if (req.method == "GET" || req.method == "HEAD") {
>     return dispatch_request(req, res, get_handlers_);
>   } else if (req.method == "POST") {
>     return dispatch_request(req, res, post_handlers_);
>   } else if (req.method == "PUT") {
>     return dispatch_request(req, res, put_handlers_);
>   } else if (req.method == "DELETE") {
>     return dispatch_request(req, res, delete_handlers_);
>   } else if (req.method == "OPTIONS") {
>     return dispatch_request(req, res, options_handlers_);
>   } else if (req.method == "PATCH") {
>     return dispatch_request(req, res, patch_handlers_);
>   }
3998,4001c4100,4102
<     try {
<       for (const auto &x : handlers) {
<         const auto &pattern = x.first;
<         const auto &handler = x.second;
---
>   res.status = 400;
>   return false;
> }
4003,4016c4104,4105
<         if (std::regex_match(req.path, req.matches, pattern)) {
<           handler(req, res);
<           return true;
<         }
<       }
<     } catch (const std::exception &ex) {
<       res.status = 500;
<       res.set_header("EXCEPTION_WHAT", ex.what());
<     } catch (...) {
<       res.status = 500;
<       res.set_header("EXCEPTION_WHAT", "UNKNOWN");
<     }
<     return false;
<   }
---
> inline bool Server::dispatch_request(Request &req, Response &res,
>                                      Handlers &handlers) {
4018,4019c4107
<   inline bool Server::dispatch_request_for_content_reader(Request &req, Response &res, ContentReader content_reader,
<                                                           HandlersForContentReader &handlers) {
---
>   try {
4025c4113
<         handler(req, res, content_reader);
---
>         handler(req, res);
4029c4117,4122
<     return false;
---
>   } catch (const std::exception &ex) {
>     res.status = 500;
>     res.set_header("EXCEPTION_WHAT", ex.what());
>   } catch (...) {
>     res.status = 500;
>     res.set_header("EXCEPTION_WHAT", "UNKNOWN");
4030a4124,4125
>   return false;
> }
4032,4036c4127,4132
<   inline bool Server::process_request(Stream &strm, bool last_connection, bool &connection_close,
<                                       const std::function<void(Request &)> &setup_request) {
<     std::array<char, 2048> buf {};
< 
<     detail::stream_line_reader line_reader(strm, buf.data(), buf.size());
---
> inline bool Server::dispatch_request_for_content_reader(
>     Request &req, Response &res, ContentReader content_reader,
>     HandlersForContentReader &handlers) {
>   for (const auto &x : handlers) {
>     const auto &pattern = x.first;
>     const auto &handler = x.second;
4038,4040c4134,4136
<     // Connection has been closed on client
<     if (!line_reader.getline()) {
<       return false;
---
>     if (std::regex_match(req.path, req.matches, pattern)) {
>       handler(req, res, content_reader);
>       return true;
4041a4138,4140
>   }
>   return false;
> }
4043,4044c4142,4164
<     Request req;
<     Response res;
---
> inline bool
> Server::process_request(Stream &strm, bool last_connection,
>                         bool &connection_close,
>                         const std::function<void(Request &)> &setup_request) {
>   std::array<char, 2048> buf{};
> 
>   detail::stream_line_reader line_reader(strm, buf.data(), buf.size());
> 
>   // Connection has been closed on client
>   if (!line_reader.getline()) { return false; }
> 
>   Request req;
>   Response res;
> 
>   res.version = "HTTP/1.1";
> 
>   // Check if the request URI doesn't exceed the limit
>   if (line_reader.size() > CPPHTTPLIB_REQUEST_URI_MAX_LENGTH) {
>     Headers dummy;
>     detail::read_headers(strm, dummy);
>     res.status = 414;
>     return write_response(strm, last_connection, req, res);
>   }
4046c4166,4171
<     res.version = "HTTP/1.1";
---
>   // Request line and headers
>   if (!parse_request_line(line_reader.ptr(), req) ||
>       !detail::read_headers(strm, req.headers)) {
>     res.status = 400;
>     return write_response(strm, last_connection, req, res);
>   }
4048,4054c4173,4175
<     // Check if the request URI doesn't exceed the limit
<     if (line_reader.size() > CPPHTTPLIB_REQUEST_URI_MAX_LENGTH) {
<       Headers dummy;
<       detail::read_headers(strm, dummy);
<       res.status = 414;
<       return write_response(strm, last_connection, req, res);
<     }
---
>   if (req.get_header_value("Connection") == "close") {
>     connection_close = true;
>   }
4056,4060c4177,4180
<     // Request line and headers
<     if (!parse_request_line(line_reader.ptr(), req) || !detail::read_headers(strm, req.headers)) {
<       res.status = 400;
<       return write_response(strm, last_connection, req, res);
<     }
---
>   if (req.version == "HTTP/1.0" &&
>       req.get_header_value("Connection") != "Keep-Alive") {
>     connection_close = true;
>   }
4062,4064c4182,4184
<     if (req.get_header_value("Connection") == "close") {
<       connection_close = true;
<     }
---
>   strm.get_remote_ip_and_port(req.remote_addr, req.remote_port);
>   req.set_header("REMOTE_ADDR", req.remote_addr);
>   req.set_header("REMOTE_PORT", std::to_string(req.remote_port));
4066,4067c4186,4189
<     if (req.version == "HTTP/1.0" && req.get_header_value("Connection") != "Keep-Alive") {
<       connection_close = true;
---
>   if (req.has_header("Range")) {
>     const auto &range_header_value = req.get_header_value("Range");
>     if (!detail::parse_range_header(range_header_value, req.ranges)) {
>       // TODO: error
4068a4191
>   }
4070,4072c4193
<     strm.get_remote_ip_and_port(req.remote_addr, req.remote_port);
<     req.set_header("REMOTE_ADDR", req.remote_addr);
<     req.set_header("REMOTE_PORT", std::to_string(req.remote_port));
---
>   if (setup_request) { setup_request(req); }
4074,4078c4195,4198
<     if (req.has_header("Range")) {
<       const auto &range_header_value = req.get_header_value("Range");
<       if (!detail::parse_range_header(range_header_value, req.ranges)) {
<         // TODO: error
<       }
---
>   if (req.get_header_value("Expect") == "100-continue") {
>     auto status = 100;
>     if (expect_100_continue_handler_) {
>       status = expect_100_continue_handler_(req, res);
4080,4082c4200,4206
< 
<     if (setup_request) {
<       setup_request(req);
---
>     switch (status) {
>     case 100:
>     case 417:
>       strm.write_format("HTTP/1.1 %d %s\r\n\r\n", status,
>                         detail::status_message(status));
>       break;
>     default: return write_response(strm, last_connection, req, res);
4083a4208
>   }
4085,4098c4210,4215
<     if (req.get_header_value("Expect") == "100-continue") {
<       auto status = 100;
<       if (expect_100_continue_handler_) {
<         status = expect_100_continue_handler_(req, res);
<       }
<       switch (status) {
<         case 100:
<         case 417:
<           strm.write_format("HTTP/1.1 %d %s\r\n\r\n", status, detail::status_message(status));
<           break;
<         default:
<           return write_response(strm, last_connection, req, res);
<       }
<     }
---
>   // Rounting
>   if (routing(req, res, strm)) {
>     if (res.status == -1) { res.status = req.ranges.empty() ? 200 : 206; }
>   } else {
>     if (res.status == -1) { res.status = 404; }
>   }
4100,4109c4217,4218
<     // Rounting
<     if (routing(req, res, strm)) {
<       if (res.status == -1) {
<         res.status = req.ranges.empty() ? 200 : 206;
<       }
<     } else {
<       if (res.status == -1) {
<         res.status = 404;
<       }
<     }
---
>   return write_response(strm, last_connection, req, res);
> }
4111,4112c4220
<     return write_response(strm, last_connection, req, res);
<   }
---
> inline bool Server::is_valid() const { return true; }
4114c4222,4230
<   inline bool Server::is_valid() const { return true; }
---
> inline bool Server::process_and_close_socket(socket_t sock) {
>   return detail::process_and_close_socket(
>       false, sock, keep_alive_max_count_, read_timeout_sec_, read_timeout_usec_,
>       write_timeout_sec_, write_timeout_usec_,
>       [this](Stream &strm, bool last_connection, bool &connection_close) {
>         return process_request(strm, last_connection, connection_close,
>                                nullptr);
>       });
> }
4116,4133c4232,4242
<   inline bool Server::process_and_close_socket(socket_t sock) {
<     return detail::process_and_close_socket(false, sock, keep_alive_max_count_, read_timeout_sec_, read_timeout_usec_,
<                                             write_timeout_sec_, write_timeout_usec_,
<                                             [this](Stream &strm, bool last_connection, bool &connection_close) {
<                                               return process_request(strm, last_connection, connection_close, nullptr);
<                                             });
<   }
< 
<   // HTTP client implementation
<   inline Client::Client(const std::string &host) : Client(host, 80, std::string(), std::string()) {}
< 
<   inline Client::Client(const std::string &host, int port) : Client(host, port, std::string(), std::string()) {}
< 
<   inline Client::Client(const std::string &host, int port, const std::string &client_cert_path,
<                         const std::string &client_key_path) :
<       sock_(INVALID_SOCKET),
<       host_(host),
<       port_(port),
---
> // HTTP client implementation
> inline Client::Client(const std::string &host)
>     : Client(host, 80, std::string(), std::string()) {}
> 
> inline Client::Client(const std::string &host, int port)
>     : Client(host, port, std::string(), std::string()) {}
> 
> inline Client::Client(const std::string &host, int port,
>                       const std::string &client_cert_path,
>                       const std::string &client_key_path)
>     : sock_(INVALID_SOCKET), host_(host), port_(port),
4135,4136c4244
<       client_cert_path_(client_cert_path),
<       client_key_path_(client_key_path) {}
---
>       client_cert_path_(client_cert_path), client_key_path_(client_key_path) {}
4138c4246
<   inline Client::~Client() {}
---
> inline Client::~Client() {}
4140c4248
<   inline bool Client::is_valid() const { return true; }
---
> inline bool Client::is_valid() const { return true; }
4142,4147c4250,4254
<   inline socket_t Client::create_client_socket() const {
<     if (!proxy_host_.empty()) {
<       return detail::create_client_socket(proxy_host_.c_str(), proxy_port_, connection_timeout_sec_, connection_timeout_usec_,
<                                           interface_);
<     }
<     return detail::create_client_socket(host_.c_str(), port_, connection_timeout_sec_, connection_timeout_usec_, interface_);
---
> inline socket_t Client::create_client_socket() const {
>   if (!proxy_host_.empty()) {
>     return detail::create_client_socket(proxy_host_.c_str(), proxy_port_,
>                                         connection_timeout_sec_,
>                                         connection_timeout_usec_, interface_);
4148a4256,4259
>   return detail::create_client_socket(host_.c_str(), port_,
>                                       connection_timeout_sec_,
>                                       connection_timeout_usec_, interface_);
> }
4150,4151c4261,4262
<   inline bool Client::read_response_line(Stream &strm, Response &res) {
<     std::array<char, 2048> buf;
---
> inline bool Client::read_response_line(Stream &strm, Response &res) {
>   std::array<char, 2048> buf;
4153c4264
<     detail::stream_line_reader line_reader(strm, buf.data(), buf.size());
---
>   detail::stream_line_reader line_reader(strm, buf.data(), buf.size());
4155,4157c4266
<     if (!line_reader.getline()) {
<       return false;
<     }
---
>   if (!line_reader.getline()) { return false; }
4159c4268
<     const static std::regex re("(HTTP/1\\.[01]) (\\d+?) .*\r\n");
---
>   const static std::regex re("(HTTP/1\\.[01]) (\\d+?) .*\r\n");
4161,4165c4270,4274
<     std::cmatch m;
<     if (std::regex_match(line_reader.ptr(), m, re)) {
<       res.version = std::string(m[1]);
<       res.status = std::stoi(std::string(m[2]));
<     }
---
>   std::cmatch m;
>   if (std::regex_match(line_reader.ptr(), m, re)) {
>     res.version = std::string(m[1]);
>     res.status = std::stoi(std::string(m[2]));
>   }
4167c4276,4286
<     return true;
---
>   return true;
> }
> 
> inline bool Client::send(const Request &req, Response &res) {
>   sock_ = create_client_socket();
>   if (sock_ == INVALID_SOCKET) { return false; }
> 
> #ifdef CPPHTTPLIB_OPENSSL_SUPPORT
>   if (is_ssl() && !proxy_host_.empty()) {
>     bool error;
>     if (!connect(sock_, res, error)) { return error; }
4168a4288,4296
> #endif
> 
>   return process_and_close_socket(
>       sock_, 1,
>       [&](Stream &strm, bool last_connection, bool &connection_close) {
>         return handle_request(strm, req, res, last_connection,
>                               connection_close);
>       });
> }
4170c4298,4301
<   inline bool Client::send(const Request &req, Response &res) {
---
> inline bool Client::send(const std::vector<Request> &requests,
>                          std::vector<Response> &responses) {
>   size_t i = 0;
>   while (i < requests.size()) {
4172,4174c4303
<     if (sock_ == INVALID_SOCKET) {
<       return false;
<     }
---
>     if (sock_ == INVALID_SOCKET) { return false; }
4177a4307
>       Response res;
4179,4181c4309
<       if (!connect(sock_, res, error)) {
<         return error;
<       }
---
>       if (!connect(sock_, res, error)) { return false; }
4185,4187c4313,4327
<     return process_and_close_socket(sock_, 1, [&](Stream &strm, bool last_connection, bool &connection_close) {
<       return handle_request(strm, req, res, last_connection, connection_close);
<     });
---
>     if (!process_and_close_socket(sock_, requests.size() - i,
>                                   [&](Stream &strm, bool last_connection,
>                                       bool &connection_close) -> bool {
>                                     auto &req = requests[i++];
>                                     auto res = Response();
>                                     auto ret = handle_request(strm, req, res,
>                                                               last_connection,
>                                                               connection_close);
>                                     if (ret) {
>                                       responses.emplace_back(std::move(res));
>                                     }
>                                     return ret;
>                                   })) {
>       return false;
>     }
4190,4196c4330,4331
<   inline bool Client::send(const std::vector<Request> &requests, std::vector<Response> &responses) {
<     size_t i = 0;
<     while (i < requests.size()) {
<       sock_ = create_client_socket();
<       if (sock_ == INVALID_SOCKET) {
<         return false;
<       }
---
>   return true;
> }
4198,4206c4333,4336
< #ifdef CPPHTTPLIB_OPENSSL_SUPPORT
<       if (is_ssl() && !proxy_host_.empty()) {
<         Response res;
<         bool error;
<         if (!connect(sock_, res, error)) {
<           return false;
<         }
<       }
< #endif
---
> inline bool Client::handle_request(Stream &strm, const Request &req,
>                                    Response &res, bool last_connection,
>                                    bool &connection_close) {
>   if (req.path.empty()) { return false; }
4208,4220c4338
<       if (!process_and_close_socket(sock_, requests.size() - i,
<                                     [&](Stream &strm, bool last_connection, bool &connection_close) -> bool {
<                                       auto &req = requests[i++];
<                                       auto res = Response();
<                                       auto ret = handle_request(strm, req, res, last_connection, connection_close);
<                                       if (ret) {
<                                         responses.emplace_back(std::move(res));
<                                       }
<                                       return ret;
<                                     })) {
<         return false;
<       }
<     }
---
>   bool ret;
4222c4340,4345
<     return true;
---
>   if (!is_ssl() && !proxy_host_.empty()) {
>     auto req2 = req;
>     req2.path = "http://" + host_and_port_ + req.path;
>     ret = process_request(strm, req2, res, last_connection, connection_close);
>   } else {
>     ret = process_request(strm, req, res, last_connection, connection_close);
4225,4229c4348
<   inline bool Client::handle_request(Stream &strm, const Request &req, Response &res, bool last_connection,
<                                      bool &connection_close) {
<     if (req.path.empty()) {
<       return false;
<     }
---
>   if (!ret) { return false; }
4231c4350,4352
<     bool ret;
---
>   if (300 < res.status && res.status < 400 && follow_location_) {
>     ret = redirect(req, res);
>   }
4233,4239c4354,4361
<     if (!is_ssl() && !proxy_host_.empty()) {
<       auto req2 = req;
<       req2.path = "http://" + host_and_port_ + req.path;
<       ret = process_request(strm, req2, res, last_connection, connection_close);
<     } else {
<       ret = process_request(strm, req, res, last_connection, connection_close);
<     }
---
> #ifdef CPPHTTPLIB_OPENSSL_SUPPORT
>   if ((res.status == 401 || res.status == 407) &&
>       req.authorization_count_ < 5) {
>     auto is_proxy = res.status == 407;
>     const auto &username =
>         is_proxy ? proxy_digest_auth_username_ : digest_auth_username_;
>     const auto &password =
>         is_proxy ? proxy_digest_auth_password_ : digest_auth_password_;
4241,4243c4363,4372
<     if (!ret) {
<       return false;
<     }
---
>     if (!username.empty() && !password.empty()) {
>       std::map<std::string, std::string> auth;
>       if (parse_www_authenticate(res, auth, is_proxy)) {
>         Request new_req = req;
>         new_req.authorization_count_ += 1;
>         auto key = is_proxy ? "Proxy-Authorization" : "Authorization";
>         new_req.headers.erase(key);
>         new_req.headers.insert(make_digest_authentication_header(
>             req, auth, new_req.authorization_count_, random_string(10),
>             username, password, is_proxy));
4245,4247c4374
<     if (300 < res.status && res.status < 400 && follow_location_) {
<       ret = redirect(req, res);
<     }
---
>         Response new_res;
4249,4271c4376,4377
< #ifdef CPPHTTPLIB_OPENSSL_SUPPORT
<     if ((res.status == 401 || res.status == 407) && req.authorization_count_ < 5) {
<       auto is_proxy = res.status == 407;
<       const auto &username = is_proxy ? proxy_digest_auth_username_ : digest_auth_username_;
<       const auto &password = is_proxy ? proxy_digest_auth_password_ : digest_auth_password_;
< 
<       if (!username.empty() && !password.empty()) {
<         std::map<std::string, std::string> auth;
<         if (parse_www_authenticate(res, auth, is_proxy)) {
<           Request new_req = req;
<           new_req.authorization_count_ += 1;
<           auto key = is_proxy ? "Proxy-Authorization" : "Authorization";
<           new_req.headers.erase(key);
<           new_req.headers.insert(make_digest_authentication_header(req, auth, new_req.authorization_count_, random_string(10),
<                                                                    username, password, is_proxy));
< 
<           Response new_res;
< 
<           ret = send(new_req, new_res);
<           if (ret) {
<             res = new_res;
<           }
<         }
---
>         ret = send(new_req, new_res);
>         if (ret) { res = new_res; }
4273a4380
>   }
4276,4277c4383,4384
<     return ret;
<   }
---
>   return ret;
> }
4280,4294c4387,4403
<   inline bool Client::connect(socket_t sock, Response &res, bool &error) {
<     error = true;
<     Response res2;
< 
<     if (!detail::process_socket(true, sock, 1, read_timeout_sec_, read_timeout_usec_, write_timeout_sec_, write_timeout_usec_,
<                                 [&](Stream &strm, bool /*last_connection*/, bool &connection_close) {
<                                   Request req2;
<                                   req2.method = "CONNECT";
<                                   req2.path = host_and_port_;
<                                   return process_request(strm, req2, res2, false, connection_close);
<                                 })) {
<       detail::close_socket(sock);
<       error = false;
<       return false;
<     }
---
> inline bool Client::connect(socket_t sock, Response &res, bool &error) {
>   error = true;
>   Response res2;
> 
>   if (!detail::process_socket(
>           true, sock, 1, read_timeout_sec_, read_timeout_usec_,
>           write_timeout_sec_, write_timeout_usec_,
>           [&](Stream &strm, bool /*last_connection*/, bool &connection_close) {
>             Request req2;
>             req2.method = "CONNECT";
>             req2.path = host_and_port_;
>             return process_request(strm, req2, res2, false, connection_close);
>           })) {
>     detail::close_socket(sock);
>     error = false;
>     return false;
>   }
4296,4314c4405,4428
<     if (res2.status == 407) {
<       if (!proxy_digest_auth_username_.empty() && !proxy_digest_auth_password_.empty()) {
<         std::map<std::string, std::string> auth;
<         if (parse_www_authenticate(res2, auth, true)) {
<           Response res3;
<           if (!detail::process_socket(true, sock, 1, read_timeout_sec_, read_timeout_usec_, write_timeout_sec_,
<                                       write_timeout_usec_, [&](Stream &strm, bool /*last_connection*/, bool &connection_close) {
<                                         Request req3;
<                                         req3.method = "CONNECT";
<                                         req3.path = host_and_port_;
<                                         req3.headers.insert(make_digest_authentication_header(req3, auth, 1, random_string(10),
<                                                                                               proxy_digest_auth_username_,
<                                                                                               proxy_digest_auth_password_, true));
<                                         return process_request(strm, req3, res3, false, connection_close);
<                                       })) {
<             detail::close_socket(sock);
<             error = false;
<             return false;
<           }
---
>   if (res2.status == 407) {
>     if (!proxy_digest_auth_username_.empty() &&
>         !proxy_digest_auth_password_.empty()) {
>       std::map<std::string, std::string> auth;
>       if (parse_www_authenticate(res2, auth, true)) {
>         Response res3;
>         if (!detail::process_socket(
>                 true, sock, 1, read_timeout_sec_, read_timeout_usec_,
>                 write_timeout_sec_, write_timeout_usec_,
>                 [&](Stream &strm, bool /*last_connection*/,
>                     bool &connection_close) {
>                   Request req3;
>                   req3.method = "CONNECT";
>                   req3.path = host_and_port_;
>                   req3.headers.insert(make_digest_authentication_header(
>                       req3, auth, 1, random_string(10),
>                       proxy_digest_auth_username_, proxy_digest_auth_password_,
>                       true));
>                   return process_request(strm, req3, res3, false,
>                                          connection_close);
>                 })) {
>           detail::close_socket(sock);
>           error = false;
>           return false;
4316,4318d4429
<       } else {
<         res = res2;
<         return false;
4319a4431,4433
>     } else {
>       res = res2;
>       return false;
4321,4322d4434
< 
<     return true;
4323a4436,4438
> 
>   return true;
> }
4326,4329c4441,4442
<   inline bool Client::redirect(const Request &req, Response &res) {
<     if (req.redirect_count == 0) {
<       return false;
<     }
---
> inline bool Client::redirect(const Request &req, Response &res) {
>   if (req.redirect_count == 0) { return false; }
4331,4334c4444,4445
<     auto location = res.get_header_value("location");
<     if (location.empty()) {
<       return false;
<     }
---
>   auto location = res.get_header_value("location");
>   if (location.empty()) { return false; }
4336c4447,4448
<     const static std::regex re(R"(^(?:(https?):)?(?://([^:/?#]*)(?::(\d+))?)?([^?#]*(?:\?[^#]*)?)(?:#.*)?)");
---
>   const static std::regex re(
>       R"(^(?:(https?):)?(?://([^:/?#]*)(?::(\d+))?)?([^?#]*(?:\?[^#]*)?)(?:#.*)?)");
4338,4341c4450,4451
<     std::smatch m;
<     if (!std::regex_match(location, m, re)) {
<       return false;
<     }
---
>   std::smatch m;
>   if (!std::regex_match(location, m, re)) { return false; }
4343c4453
<     auto scheme = is_ssl() ? "https" : "http";
---
>   auto scheme = is_ssl() ? "https" : "http";
4345,4348c4455,4458
<     auto next_scheme = m[1].str();
<     auto next_host = m[2].str();
<     auto port_str = m[3].str();
<     auto next_path = m[4].str();
---
>   auto next_scheme = m[1].str();
>   auto next_host = m[2].str();
>   auto port_str = m[3].str();
>   auto next_path = m[4].str();
4350,4355c4460,4465
<     auto next_port = port_;
<     if (!port_str.empty()) {
<       next_port = std::stoi(port_str);
<     } else if (!next_scheme.empty()) {
<       next_port = next_scheme == "https" ? 443 : 80;
<     }
---
>   auto next_port = port_;
>   if (!port_str.empty()) {
>     next_port = std::stoi(port_str);
>   } else if (!next_scheme.empty()) {
>     next_port = next_scheme == "https" ? 443 : 80;
>   }
4357,4365c4467,4469
<     if (next_scheme.empty()) {
<       next_scheme = scheme;
<     }
<     if (next_host.empty()) {
<       next_host = host_;
<     }
<     if (next_path.empty()) {
<       next_path = "/";
<     }
---
>   if (next_scheme.empty()) { next_scheme = scheme; }
>   if (next_host.empty()) { next_host = host_; }
>   if (next_path.empty()) { next_path = "/"; }
4367,4370c4471,4474
<     if (next_scheme == scheme && next_host == host_ && next_port == port_) {
<       return detail::redirect(*this, req, res, next_path);
<     } else {
<       if (next_scheme == "https") {
---
>   if (next_scheme == scheme && next_host == host_ && next_port == port_) {
>     return detail::redirect(*this, req, res, next_path);
>   } else {
>     if (next_scheme == "https") {
4372,4374c4476,4478
<         SSLClient cli(next_host.c_str(), next_port);
<         cli.copy_settings(*this);
<         return detail::redirect(cli, req, res, next_path);
---
>       SSLClient cli(next_host.c_str(), next_port);
>       cli.copy_settings(*this);
>       return detail::redirect(cli, req, res, next_path);
4376c4480
<         return false;
---
>       return false;
4377a4482,4512
>     } else {
>       Client cli(next_host.c_str(), next_port);
>       cli.copy_settings(*this);
>       return detail::redirect(cli, req, res, next_path);
>     }
>   }
> }
> 
> inline bool Client::write_request(Stream &strm, const Request &req,
>                                   bool last_connection) {
>   detail::BufferStream bstrm;
> 
>   // Request line
>   const auto &path = detail::encode_url(req.path);
> 
>   bstrm.write_format("%s %s HTTP/1.1\r\n", req.method.c_str(), path.c_str());
> 
>   // Additonal headers
>   Headers headers;
>   if (last_connection) { headers.emplace("Connection", "close"); }
> 
>   if (!req.has_header("Host")) {
>     if (is_ssl()) {
>       if (port_ == 443) {
>         headers.emplace("Host", host_);
>       } else {
>         headers.emplace("Host", host_and_port_);
>       }
>     } else {
>       if (port_ == 80) {
>         headers.emplace("Host", host_);
4379,4381c4514
<         Client cli(next_host.c_str(), next_port);
<         cli.copy_settings(*this);
<         return detail::redirect(cli, req, res, next_path);
---
>         headers.emplace("Host", host_and_port_);
4386,4387c4519
<   inline bool Client::write_request(Stream &strm, const Request &req, bool last_connection) {
<     detail::BufferStream bstrm;
---
>   if (!req.has_header("Accept")) { headers.emplace("Accept", "*/*"); }
4389,4398c4521,4523
<     // Request line
<     const auto &path = detail::encode_url(req.path);
< 
<     bstrm.write_format("%s %s HTTP/1.1\r\n", req.method.c_str(), path.c_str());
< 
<     // Additonal headers
<     Headers headers;
<     if (last_connection) {
<       headers.emplace("Connection", "close");
<     }
---
>   if (!req.has_header("User-Agent")) {
>     headers.emplace("User-Agent", "cpp-httplib/0.6");
>   }
4400,4413c4525,4530
<     if (!req.has_header("Host")) {
<       if (is_ssl()) {
<         if (port_ == 443) {
<           headers.emplace("Host", host_);
<         } else {
<           headers.emplace("Host", host_and_port_);
<         }
<       } else {
<         if (port_ == 80) {
<           headers.emplace("Host", host_);
<         } else {
<           headers.emplace("Host", host_and_port_);
<         }
<       }
---
>   if (req.body.empty()) {
>     if (req.content_provider) {
>       auto length = std::to_string(req.content_length);
>       headers.emplace("Content-Length", length);
>     } else {
>       headers.emplace("Content-Length", "0");
4415,4417c4532,4534
< 
<     if (!req.has_header("Accept")) {
<       headers.emplace("Accept", "*/*");
---
>   } else {
>     if (!req.has_header("Content-Type")) {
>       headers.emplace("Content-Type", "text/plain");
4420,4421c4537,4539
<     if (!req.has_header("User-Agent")) {
<       headers.emplace("User-Agent", "cpp-httplib/0.6");
---
>     if (!req.has_header("Content-Length")) {
>       auto length = std::to_string(req.body.size());
>       headers.emplace("Content-Length", length);
4422a4541
>   }
4424,4434c4543,4546
<     if (req.body.empty()) {
<       if (req.content_provider) {
<         auto length = std::to_string(req.content_length);
<         headers.emplace("Content-Length", length);
<       } else {
<         headers.emplace("Content-Length", "0");
<       }
<     } else {
<       if (!req.has_header("Content-Type")) {
<         headers.emplace("Content-Type", "text/plain");
<       }
---
>   if (!basic_auth_username_.empty() && !basic_auth_password_.empty()) {
>     headers.insert(make_basic_authentication_header(
>         basic_auth_username_, basic_auth_password_, false));
>   }
4436,4440c4548,4552
<       if (!req.has_header("Content-Length")) {
<         auto length = std::to_string(req.body.size());
<         headers.emplace("Content-Length", length);
<       }
<     }
---
>   if (!proxy_basic_auth_username_.empty() &&
>       !proxy_basic_auth_password_.empty()) {
>     headers.insert(make_basic_authentication_header(
>         proxy_basic_auth_username_, proxy_basic_auth_password_, true));
>   }
4442,4444c4554
<     if (!basic_auth_username_.empty() && !basic_auth_password_.empty()) {
<       headers.insert(make_basic_authentication_header(basic_auth_username_, basic_auth_password_, false));
<     }
---
>   detail::write_headers(bstrm, req, headers);
4446,4448c4556,4558
<     if (!proxy_basic_auth_username_.empty() && !proxy_basic_auth_password_.empty()) {
<       headers.insert(make_basic_authentication_header(proxy_basic_auth_username_, proxy_basic_auth_password_, true));
<     }
---
>   // Flush buffer
>   auto &data = bstrm.get_buffer();
>   if (!detail::write_data(strm, data.data(), data.size())) { return false; }
4450c4560,4564
<     detail::write_headers(bstrm, req, headers);
---
>   // Body
>   if (req.body.empty()) {
>     if (req.content_provider) {
>       size_t offset = 0;
>       size_t end_offset = req.content_length;
4452,4456c4566
<     // Flush buffer
<     auto &data = bstrm.get_buffer();
<     if (!detail::write_data(strm, data.data(), data.size())) {
<       return false;
<     }
---
>       bool ok = true;
4458,4473c4568,4574
<     // Body
<     if (req.body.empty()) {
<       if (req.content_provider) {
<         size_t offset = 0;
<         size_t end_offset = req.content_length;
< 
<         bool ok = true;
< 
<         DataSink data_sink;
<         data_sink.write = [&](const char *d, size_t l) {
<           if (ok) {
<             if (detail::write_data(strm, d, l)) {
<               offset += l;
<             } else {
<               ok = false;
<             }
---
>       DataSink data_sink;
>       data_sink.write = [&](const char *d, size_t l) {
>         if (ok) {
>           if (detail::write_data(strm, d, l)) {
>             offset += l;
>           } else {
>             ok = false;
4475,4476c4576,4578
<         };
<         data_sink.is_writable = [&](void) { return ok && strm.is_writable(); };
---
>         }
>       };
>       data_sink.is_writable = [&](void) { return ok && strm.is_writable(); };
4478,4484c4580,4582
<         while (offset < end_offset) {
<           if (!req.content_provider(offset, end_offset - offset, data_sink)) {
<             return false;
<           }
<           if (!ok) {
<             return false;
<           }
---
>       while (offset < end_offset) {
>         if (!req.content_provider(offset, end_offset - offset, data_sink)) {
>           return false;
4485a4584
>         if (!ok) { return false; }
4487,4488d4585
<     } else {
<       return detail::write_data(strm, req.body.data(), req.body.size());
4490,4491c4587,4588
< 
<     return true;
---
>   } else {
>     return detail::write_data(strm, req.body.data(), req.body.size());
4494,4501c4591,4592
<   inline std::shared_ptr<Response> Client::send_with_content_provider(const char *method, const char *path,
<                                                                       const Headers &headers, const std::string &body,
<                                                                       size_t content_length, ContentProvider content_provider,
<                                                                       const char *content_type) {
<     Request req;
<     req.method = method;
<     req.headers = headers;
<     req.path = path;
---
>   return true;
> }
4503,4505c4594,4603
<     if (content_type) {
<       req.headers.emplace("Content-Type", content_type);
<     }
---
> inline std::shared_ptr<Response> Client::send_with_content_provider(
>     const char *method, const char *path, const Headers &headers,
>     const std::string &body, size_t content_length,
>     ContentProvider content_provider, const char *content_type) {
>   Request req;
>   req.method = method;
>   req.headers = headers;
>   req.path = path;
> 
>   if (content_type) { req.headers.emplace("Content-Type", content_type); }
4508,4522c4606,4619
<     if (compress_) {
<       if (content_provider) {
<         size_t offset = 0;
< 
<         DataSink data_sink;
<         data_sink.write = [&](const char *data, size_t data_len) {
<           req.body.append(data, data_len);
<           offset += data_len;
<         };
<         data_sink.is_writable = [&](void) { return true; };
< 
<         while (offset < content_length) {
<           if (!content_provider(offset, content_length - offset, data_sink)) {
<             return nullptr;
<           }
---
>   if (compress_) {
>     if (content_provider) {
>       size_t offset = 0;
> 
>       DataSink data_sink;
>       data_sink.write = [&](const char *data, size_t data_len) {
>         req.body.append(data, data_len);
>         offset += data_len;
>       };
>       data_sink.is_writable = [&](void) { return true; };
> 
>       while (offset < content_length) {
>         if (!content_provider(offset, content_length - offset, data_sink)) {
>           return nullptr;
4524,4525d4620
<       } else {
<         req.body = body;
4526a4622,4624
>     } else {
>       req.body = body;
>     }
4528,4532c4626,4628
<       if (!detail::compress(req.body)) {
<         return nullptr;
<       }
<       req.headers.emplace("Content-Encoding", "gzip");
<     } else
---
>     if (!detail::compress(req.body)) { return nullptr; }
>     req.headers.emplace("Content-Encoding", "gzip");
>   } else
4534,4540c4630,4635
<     {
<       if (content_provider) {
<         req.content_length = content_length;
<         req.content_provider = content_provider;
<       } else {
<         req.body = body;
<       }
---
>   {
>     if (content_provider) {
>       req.content_length = content_length;
>       req.content_provider = content_provider;
>     } else {
>       req.body = body;
4541a4637,4639
>   }
> 
>   auto res = std::make_shared<Response>();
4543c4641,4642
<     auto res = std::make_shared<Response>();
---
>   return send(req, *res) ? res : nullptr;
> }
4545c4644,4653
<     return send(req, *res) ? res : nullptr;
---
> inline bool Client::process_request(Stream &strm, const Request &req,
>                                     Response &res, bool last_connection,
>                                     bool &connection_close) {
>   // Send request
>   if (!write_request(strm, req, last_connection)) { return false; }
> 
>   // Receive response and headers
>   if (!read_response_line(strm, res) ||
>       !detail::read_headers(strm, res.headers)) {
>     return false;
4548,4553c4656,4676
<   inline bool Client::process_request(Stream &strm, const Request &req, Response &res, bool last_connection,
<                                       bool &connection_close) {
<     // Send request
<     if (!write_request(strm, req, last_connection)) {
<       return false;
<     }
---
>   if (res.get_header_value("Connection") == "close" ||
>       res.version == "HTTP/1.0") {
>     connection_close = true;
>   }
> 
>   if (req.response_handler) {
>     if (!req.response_handler(res)) { return false; }
>   }
> 
>   // Body
>   if (req.method != "HEAD" && req.method != "CONNECT") {
>     auto out =
>         req.content_receiver
>             ? static_cast<ContentReceiver>([&](const char *buf, size_t n) {
>                 return req.content_receiver(buf, n);
>               })
>             : static_cast<ContentReceiver>([&](const char *buf, size_t n) {
>                 if (res.body.size() + n > res.body.max_size()) { return false; }
>                 res.body.append(buf, n);
>                 return true;
>               });
4555,4556c4678,4680
<     // Receive response and headers
<     if (!read_response_line(strm, res) || !detail::read_headers(strm, res.headers)) {
---
>     int dummy_status;
>     if (!detail::read_content(strm, res, (std::numeric_limits<size_t>::max)(),
>                               dummy_status, req.progress, out, decompress_)) {
4558a4683
>   }
4560,4562c4685,4686
<     if (res.get_header_value("Connection") == "close" || res.version == "HTTP/1.0") {
<       connection_close = true;
<     }
---
>   // Log
>   if (logger_) { logger_(req, res); }
4564,4568c4688,4689
<     if (req.response_handler) {
<       if (!req.response_handler(res)) {
<         return false;
<       }
<     }
---
>   return true;
> }
4570,4580c4691,4700
<     // Body
<     if (req.method != "HEAD" && req.method != "CONNECT") {
<       auto out = req.content_receiver
<           ? static_cast<ContentReceiver>([&](const char *buf, size_t n) { return req.content_receiver(buf, n); })
<           : static_cast<ContentReceiver>([&](const char *buf, size_t n) {
<               if (res.body.size() + n > res.body.max_size()) {
<                 return false;
<               }
<               res.body.append(buf, n);
<               return true;
<             });
---
> inline bool Client::process_and_close_socket(
>     socket_t sock, size_t request_count,
>     std::function<bool(Stream &strm, bool last_connection,
>                        bool &connection_close)>
>         callback) {
>   request_count = (std::min)(request_count, keep_alive_max_count_);
>   return detail::process_and_close_socket(
>       true, sock, request_count, read_timeout_sec_, read_timeout_usec_,
>       write_timeout_sec_, write_timeout_usec_, callback);
> }
4582,4586c4702
<       int dummy_status;
<       if (!detail::read_content(strm, res, (std::numeric_limits<size_t>::max)(), dummy_status, req.progress, out)) {
<         return false;
<       }
<     }
---
> inline bool Client::is_ssl() const { return false; }
4588,4591c4704,4706
<     // Log
<     if (logger_) {
<       logger_(req, res);
<     }
---
> inline std::shared_ptr<Response> Client::Get(const char *path) {
>   return Get(path, Headers(), Progress());
> }
4593,4594c4708,4711
<     return true;
<   }
---
> inline std::shared_ptr<Response> Client::Get(const char *path,
>                                              Progress progress) {
>   return Get(path, Headers(), std::move(progress));
> }
4596,4602c4713,4716
<   inline bool
<   Client::process_and_close_socket(socket_t sock, size_t request_count,
<                                    std::function<bool(Stream &strm, bool last_connection, bool &connection_close)> callback) {
<     request_count = (std::min)(request_count, keep_alive_max_count_);
<     return detail::process_and_close_socket(true, sock, request_count, read_timeout_sec_, read_timeout_usec_, write_timeout_sec_,
<                                             write_timeout_usec_, callback);
<   }
---
> inline std::shared_ptr<Response> Client::Get(const char *path,
>                                              const Headers &headers) {
>   return Get(path, headers, Progress());
> }
4604c4718,4724
<   inline bool Client::is_ssl() const { return false; }
---
> inline std::shared_ptr<Response>
> Client::Get(const char *path, const Headers &headers, Progress progress) {
>   Request req;
>   req.method = "GET";
>   req.path = path;
>   req.headers = headers;
>   req.progress = std::move(progress);
4606c4726,4728
<   inline std::shared_ptr<Response> Client::Get(const char *path) { return Get(path, Headers(), Progress()); }
---
>   auto res = std::make_shared<Response>();
>   return send(req, *res) ? res : nullptr;
> }
4608,4610c4730,4733
<   inline std::shared_ptr<Response> Client::Get(const char *path, Progress progress) {
<     return Get(path, Headers(), std::move(progress));
<   }
---
> inline std::shared_ptr<Response> Client::Get(const char *path,
>                                              ContentReceiver content_receiver) {
>   return Get(path, Headers(), nullptr, std::move(content_receiver), Progress());
> }
4612,4614c4735,4740
<   inline std::shared_ptr<Response> Client::Get(const char *path, const Headers &headers) {
<     return Get(path, headers, Progress());
<   }
---
> inline std::shared_ptr<Response> Client::Get(const char *path,
>                                              ContentReceiver content_receiver,
>                                              Progress progress) {
>   return Get(path, Headers(), nullptr, std::move(content_receiver),
>              std::move(progress));
> }
4616,4621c4742,4746
<   inline std::shared_ptr<Response> Client::Get(const char *path, const Headers &headers, Progress progress) {
<     Request req;
<     req.method = "GET";
<     req.path = path;
<     req.headers = headers;
<     req.progress = std::move(progress);
---
> inline std::shared_ptr<Response> Client::Get(const char *path,
>                                              const Headers &headers,
>                                              ContentReceiver content_receiver) {
>   return Get(path, headers, nullptr, std::move(content_receiver), Progress());
> }
4623,4625c4748,4754
<     auto res = std::make_shared<Response>();
<     return send(req, *res) ? res : nullptr;
<   }
---
> inline std::shared_ptr<Response> Client::Get(const char *path,
>                                              const Headers &headers,
>                                              ContentReceiver content_receiver,
>                                              Progress progress) {
>   return Get(path, headers, nullptr, std::move(content_receiver),
>              std::move(progress));
> }
4627,4629c4756,4762
<   inline std::shared_ptr<Response> Client::Get(const char *path, ContentReceiver content_receiver) {
<     return Get(path, Headers(), nullptr, std::move(content_receiver), Progress());
<   }
---
> inline std::shared_ptr<Response> Client::Get(const char *path,
>                                              const Headers &headers,
>                                              ResponseHandler response_handler,
>                                              ContentReceiver content_receiver) {
>   return Get(path, headers, std::move(response_handler), content_receiver,
>              Progress());
> }
4631,4633c4764,4775
<   inline std::shared_ptr<Response> Client::Get(const char *path, ContentReceiver content_receiver, Progress progress) {
<     return Get(path, Headers(), nullptr, std::move(content_receiver), std::move(progress));
<   }
---
> inline std::shared_ptr<Response> Client::Get(const char *path,
>                                              const Headers &headers,
>                                              ResponseHandler response_handler,
>                                              ContentReceiver content_receiver,
>                                              Progress progress) {
>   Request req;
>   req.method = "GET";
>   req.path = path;
>   req.headers = headers;
>   req.response_handler = std::move(response_handler);
>   req.content_receiver = std::move(content_receiver);
>   req.progress = std::move(progress);
4635,4637c4777,4779
<   inline std::shared_ptr<Response> Client::Get(const char *path, const Headers &headers, ContentReceiver content_receiver) {
<     return Get(path, headers, nullptr, std::move(content_receiver), Progress());
<   }
---
>   auto res = std::make_shared<Response>();
>   return send(req, *res) ? res : nullptr;
> }
4639,4642c4781,4783
<   inline std::shared_ptr<Response> Client::Get(const char *path, const Headers &headers, ContentReceiver content_receiver,
<                                                Progress progress) {
<     return Get(path, headers, nullptr, std::move(content_receiver), std::move(progress));
<   }
---
> inline std::shared_ptr<Response> Client::Head(const char *path) {
>   return Head(path, Headers());
> }
4644,4647c4785,4790
<   inline std::shared_ptr<Response> Client::Get(const char *path, const Headers &headers, ResponseHandler response_handler,
<                                                ContentReceiver content_receiver) {
<     return Get(path, headers, std::move(response_handler), content_receiver, Progress());
<   }
---
> inline std::shared_ptr<Response> Client::Head(const char *path,
>                                               const Headers &headers) {
>   Request req;
>   req.method = "HEAD";
>   req.headers = headers;
>   req.path = path;
4649,4657c4792
<   inline std::shared_ptr<Response> Client::Get(const char *path, const Headers &headers, ResponseHandler response_handler,
<                                                ContentReceiver content_receiver, Progress progress) {
<     Request req;
<     req.method = "GET";
<     req.path = path;
<     req.headers = headers;
<     req.response_handler = std::move(response_handler);
<     req.content_receiver = std::move(content_receiver);
<     req.progress = std::move(progress);
---
>   auto res = std::make_shared<Response>();
4659,4661c4794,4795
<     auto res = std::make_shared<Response>();
<     return send(req, *res) ? res : nullptr;
<   }
---
>   return send(req, *res) ? res : nullptr;
> }
4663c4797,4799
<   inline std::shared_ptr<Response> Client::Head(const char *path) { return Head(path, Headers()); }
---
> inline std::shared_ptr<Response> Client::Post(const char *path) {
>   return Post(path, std::string(), nullptr);
> }
4665,4669c4801,4805
<   inline std::shared_ptr<Response> Client::Head(const char *path, const Headers &headers) {
<     Request req;
<     req.method = "HEAD";
<     req.headers = headers;
<     req.path = path;
---
> inline std::shared_ptr<Response> Client::Post(const char *path,
>                                               const std::string &body,
>                                               const char *content_type) {
>   return Post(path, Headers(), body, content_type);
> }
4671c4807,4813
<     auto res = std::make_shared<Response>();
---
> inline std::shared_ptr<Response> Client::Post(const char *path,
>                                               const Headers &headers,
>                                               const std::string &body,
>                                               const char *content_type) {
>   return send_with_content_provider("POST", path, headers, body, 0, nullptr,
>                                     content_type);
> }
4673,4674c4815,4818
<     return send(req, *res) ? res : nullptr;
<   }
---
> inline std::shared_ptr<Response> Client::Post(const char *path,
>                                               const Params &params) {
>   return Post(path, Headers(), params);
> }
4676c4820,4825
<   inline std::shared_ptr<Response> Client::Post(const char *path) { return Post(path, std::string(), nullptr); }
---
> inline std::shared_ptr<Response> Client::Post(const char *path,
>                                               size_t content_length,
>                                               ContentProvider content_provider,
>                                               const char *content_type) {
>   return Post(path, Headers(), content_length, content_provider, content_type);
> }
4678,4680c4827,4833
<   inline std::shared_ptr<Response> Client::Post(const char *path, const std::string &body, const char *content_type) {
<     return Post(path, Headers(), body, content_type);
<   }
---
> inline std::shared_ptr<Response>
> Client::Post(const char *path, const Headers &headers, size_t content_length,
>              ContentProvider content_provider, const char *content_type) {
>   return send_with_content_provider("POST", path, headers, std::string(),
>                                     content_length, content_provider,
>                                     content_type);
> }
4682,4685c4835,4839
<   inline std::shared_ptr<Response> Client::Post(const char *path, const Headers &headers, const std::string &body,
<                                                 const char *content_type) {
<     return send_with_content_provider("POST", path, headers, body, 0, nullptr, content_type);
<   }
---
> inline std::shared_ptr<Response>
> Client::Post(const char *path, const Headers &headers, const Params &params) {
>   auto query = detail::params_to_query_str(params);
>   return Post(path, headers, query, "application/x-www-form-urlencoded");
> }
4687c4841,4844
<   inline std::shared_ptr<Response> Client::Post(const char *path, const Params &params) { return Post(path, Headers(), params); }
---
> inline std::shared_ptr<Response>
> Client::Post(const char *path, const MultipartFormDataItems &items) {
>   return Post(path, Headers(), items);
> }
4689,4692c4846,4849
<   inline std::shared_ptr<Response> Client::Post(const char *path, size_t content_length, ContentProvider content_provider,
<                                                 const char *content_type) {
<     return Post(path, Headers(), content_length, content_provider, content_type);
<   }
---
> inline std::shared_ptr<Response>
> Client::Post(const char *path, const Headers &headers,
>              const MultipartFormDataItems &items) {
>   auto boundary = detail::make_multipart_data_boundary();
4694,4697c4851
<   inline std::shared_ptr<Response> Client::Post(const char *path, const Headers &headers, size_t content_length,
<                                                 ContentProvider content_provider, const char *content_type) {
<     return send_with_content_provider("POST", path, headers, std::string(), content_length, content_provider, content_type);
<   }
---
>   std::string body;
4699,4701c4853,4864
<   inline std::shared_ptr<Response> Client::Post(const char *path, const Headers &headers, const Params &params) {
<     auto query = detail::params_to_query_str(params);
<     return Post(path, headers, query, "application/x-www-form-urlencoded");
---
>   for (const auto &item : items) {
>     body += "--" + boundary + "\r\n";
>     body += "Content-Disposition: form-data; name=\"" + item.name + "\"";
>     if (!item.filename.empty()) {
>       body += "; filename=\"" + item.filename + "\"";
>     }
>     body += "\r\n";
>     if (!item.content_type.empty()) {
>       body += "Content-Type: " + item.content_type + "\r\n";
>     }
>     body += "\r\n";
>     body += item.content + "\r\n";
4704,4706c4867
<   inline std::shared_ptr<Response> Client::Post(const char *path, const MultipartFormDataItems &items) {
<     return Post(path, Headers(), items);
<   }
---
>   body += "--" + boundary + "--\r\n";
4708,4709c4869,4871
<   inline std::shared_ptr<Response> Client::Post(const char *path, const Headers &headers, const MultipartFormDataItems &items) {
<     auto boundary = detail::make_multipart_data_boundary();
---
>   std::string content_type = "multipart/form-data; boundary=" + boundary;
>   return Post(path, headers, body, content_type.c_str());
> }
4711c4873,4875
<     std::string body;
---
> inline std::shared_ptr<Response> Client::Put(const char *path) {
>   return Put(path, std::string(), nullptr);
> }
4713,4725c4877,4881
<     for (const auto &item : items) {
<       body += "--" + boundary + "\r\n";
<       body += "Content-Disposition: form-data; name=\"" + item.name + "\"";
<       if (!item.filename.empty()) {
<         body += "; filename=\"" + item.filename + "\"";
<       }
<       body += "\r\n";
<       if (!item.content_type.empty()) {
<         body += "Content-Type: " + item.content_type + "\r\n";
<       }
<       body += "\r\n";
<       body += item.content + "\r\n";
<     }
---
> inline std::shared_ptr<Response> Client::Put(const char *path,
>                                              const std::string &body,
>                                              const char *content_type) {
>   return Put(path, Headers(), body, content_type);
> }
4727c4883,4889
<     body += "--" + boundary + "--\r\n";
---
> inline std::shared_ptr<Response> Client::Put(const char *path,
>                                              const Headers &headers,
>                                              const std::string &body,
>                                              const char *content_type) {
>   return send_with_content_provider("PUT", path, headers, body, 0, nullptr,
>                                     content_type);
> }
4729,4731c4891,4896
<     std::string content_type = "multipart/form-data; boundary=" + boundary;
<     return Post(path, headers, body, content_type.c_str());
<   }
---
> inline std::shared_ptr<Response> Client::Put(const char *path,
>                                              size_t content_length,
>                                              ContentProvider content_provider,
>                                              const char *content_type) {
>   return Put(path, Headers(), content_length, content_provider, content_type);
> }
4733c4898,4904
<   inline std::shared_ptr<Response> Client::Put(const char *path) { return Put(path, std::string(), nullptr); }
---
> inline std::shared_ptr<Response>
> Client::Put(const char *path, const Headers &headers, size_t content_length,
>             ContentProvider content_provider, const char *content_type) {
>   return send_with_content_provider("PUT", path, headers, std::string(),
>                                     content_length, content_provider,
>                                     content_type);
> }
4735,4737c4906,4909
<   inline std::shared_ptr<Response> Client::Put(const char *path, const std::string &body, const char *content_type) {
<     return Put(path, Headers(), body, content_type);
<   }
---
> inline std::shared_ptr<Response> Client::Put(const char *path,
>                                              const Params &params) {
>   return Put(path, Headers(), params);
> }
4739,4742c4911,4915
<   inline std::shared_ptr<Response> Client::Put(const char *path, const Headers &headers, const std::string &body,
<                                                const char *content_type) {
<     return send_with_content_provider("PUT", path, headers, body, 0, nullptr, content_type);
<   }
---
> inline std::shared_ptr<Response>
> Client::Put(const char *path, const Headers &headers, const Params &params) {
>   auto query = detail::params_to_query_str(params);
>   return Put(path, headers, query, "application/x-www-form-urlencoded");
> }
4744c4917,4918
<   inline std::shared_ptr<Response> Client::Put(const char *path, size_t content_length, ContentProvider content_provider,
---
> inline std::shared_ptr<Response> Client::Patch(const char *path,
>                                                const std::string &body,
4746,4763c4920,4921
<     return Put(path, Headers(), content_length, content_provider, content_type);
<   }
< 
<   inline std::shared_ptr<Response> Client::Put(const char *path, const Headers &headers, size_t content_length,
<                                                ContentProvider content_provider, const char *content_type) {
<     return send_with_content_provider("PUT", path, headers, std::string(), content_length, content_provider, content_type);
<   }
< 
<   inline std::shared_ptr<Response> Client::Put(const char *path, const Params &params) { return Put(path, Headers(), params); }
< 
<   inline std::shared_ptr<Response> Client::Put(const char *path, const Headers &headers, const Params &params) {
<     auto query = detail::params_to_query_str(params);
<     return Put(path, headers, query, "application/x-www-form-urlencoded");
<   }
< 
<   inline std::shared_ptr<Response> Client::Patch(const char *path, const std::string &body, const char *content_type) {
<     return Patch(path, Headers(), body, content_type);
<   }
---
>   return Patch(path, Headers(), body, content_type);
> }
4765,4768c4923,4929
<   inline std::shared_ptr<Response> Client::Patch(const char *path, const Headers &headers, const std::string &body,
<                                                  const char *content_type) {
<     return send_with_content_provider("PATCH", path, headers, body, 0, nullptr, content_type);
<   }
---
> inline std::shared_ptr<Response> Client::Patch(const char *path,
>                                                const Headers &headers,
>                                                const std::string &body,
>                                                const char *content_type) {
>   return send_with_content_provider("PATCH", path, headers, body, 0, nullptr,
>                                     content_type);
> }
4770,4773c4931,4936
<   inline std::shared_ptr<Response> Client::Patch(const char *path, size_t content_length, ContentProvider content_provider,
<                                                  const char *content_type) {
<     return Patch(path, Headers(), content_length, content_provider, content_type);
<   }
---
> inline std::shared_ptr<Response> Client::Patch(const char *path,
>                                                size_t content_length,
>                                                ContentProvider content_provider,
>                                                const char *content_type) {
>   return Patch(path, Headers(), content_length, content_provider, content_type);
> }
4775,4778c4938,4944
<   inline std::shared_ptr<Response> Client::Patch(const char *path, const Headers &headers, size_t content_length,
<                                                  ContentProvider content_provider, const char *content_type) {
<     return send_with_content_provider("PATCH", path, headers, std::string(), content_length, content_provider, content_type);
<   }
---
> inline std::shared_ptr<Response>
> Client::Patch(const char *path, const Headers &headers, size_t content_length,
>               ContentProvider content_provider, const char *content_type) {
>   return send_with_content_provider("PATCH", path, headers, std::string(),
>                                     content_length, content_provider,
>                                     content_type);
> }
4780c4946,4948
<   inline std::shared_ptr<Response> Client::Delete(const char *path) { return Delete(path, Headers(), std::string(), nullptr); }
---
> inline std::shared_ptr<Response> Client::Delete(const char *path) {
>   return Delete(path, Headers(), std::string(), nullptr);
> }
4782,4784c4950,4954
<   inline std::shared_ptr<Response> Client::Delete(const char *path, const std::string &body, const char *content_type) {
<     return Delete(path, Headers(), body, content_type);
<   }
---
> inline std::shared_ptr<Response> Client::Delete(const char *path,
>                                                 const std::string &body,
>                                                 const char *content_type) {
>   return Delete(path, Headers(), body, content_type);
> }
4786,4788c4956,4959
<   inline std::shared_ptr<Response> Client::Delete(const char *path, const Headers &headers) {
<     return Delete(path, headers, std::string(), nullptr);
<   }
---
> inline std::shared_ptr<Response> Client::Delete(const char *path,
>                                                 const Headers &headers) {
>   return Delete(path, headers, std::string(), nullptr);
> }
4790,4795c4961,4968
<   inline std::shared_ptr<Response> Client::Delete(const char *path, const Headers &headers, const std::string &body,
<                                                   const char *content_type) {
<     Request req;
<     req.method = "DELETE";
<     req.headers = headers;
<     req.path = path;
---
> inline std::shared_ptr<Response> Client::Delete(const char *path,
>                                                 const Headers &headers,
>                                                 const std::string &body,
>                                                 const char *content_type) {
>   Request req;
>   req.method = "DELETE";
>   req.headers = headers;
>   req.path = path;
4797,4800c4970,4971
<     if (content_type) {
<       req.headers.emplace("Content-Type", content_type);
<     }
<     req.body = body;
---
>   if (content_type) { req.headers.emplace("Content-Type", content_type); }
>   req.body = body;
4802c4973
<     auto res = std::make_shared<Response>();
---
>   auto res = std::make_shared<Response>();
4804,4805c4975,4976
<     return send(req, *res) ? res : nullptr;
<   }
---
>   return send(req, *res) ? res : nullptr;
> }
4807c4978,4980
<   inline std::shared_ptr<Response> Client::Options(const char *path) { return Options(path, Headers()); }
---
> inline std::shared_ptr<Response> Client::Options(const char *path) {
>   return Options(path, Headers());
> }
4809,4813c4982,4987
<   inline std::shared_ptr<Response> Client::Options(const char *path, const Headers &headers) {
<     Request req;
<     req.method = "OPTIONS";
<     req.path = path;
<     req.headers = headers;
---
> inline std::shared_ptr<Response> Client::Options(const char *path,
>                                                  const Headers &headers) {
>   Request req;
>   req.method = "OPTIONS";
>   req.path = path;
>   req.headers = headers;
4815c4989
<     auto res = std::make_shared<Response>();
---
>   auto res = std::make_shared<Response>();
4817,4818c4991,4992
<     return send(req, *res) ? res : nullptr;
<   }
---
>   return send(req, *res) ? res : nullptr;
> }
4820,4825c4994,4998
<   inline void Client::stop() {
<     if (sock_ != INVALID_SOCKET) {
<       std::atomic<socket_t> sock(sock_.exchange(INVALID_SOCKET));
<       detail::shutdown_socket(sock);
<       detail::close_socket(sock);
<     }
---
> inline void Client::stop() {
>   if (sock_ != INVALID_SOCKET) {
>     std::atomic<socket_t> sock(sock_.exchange(INVALID_SOCKET));
>     detail::shutdown_socket(sock);
>     detail::close_socket(sock);
4826a5000
> }
4828c5002,5004
<   inline void Client::set_timeout_sec(time_t timeout_sec) { set_connection_timeout(timeout_sec, 0); }
---
> inline void Client::set_timeout_sec(time_t timeout_sec) {
>   set_connection_timeout(timeout_sec, 0);
> }
4830,4833c5006,5009
<   inline void Client::set_connection_timeout(time_t sec, time_t usec) {
<     connection_timeout_sec_ = sec;
<     connection_timeout_usec_ = usec;
<   }
---
> inline void Client::set_connection_timeout(time_t sec, time_t usec) {
>   connection_timeout_sec_ = sec;
>   connection_timeout_usec_ = usec;
> }
4835,4838c5011,5014
<   inline void Client::set_read_timeout(time_t sec, time_t usec) {
<     read_timeout_sec_ = sec;
<     read_timeout_usec_ = usec;
<   }
---
> inline void Client::set_read_timeout(time_t sec, time_t usec) {
>   read_timeout_sec_ = sec;
>   read_timeout_usec_ = usec;
> }
4840,4843c5016,5019
<   inline void Client::set_write_timeout(time_t sec, time_t usec) {
<     write_timeout_sec_ = sec;
<     write_timeout_usec_ = usec;
<   }
---
> inline void Client::set_write_timeout(time_t sec, time_t usec) {
>   write_timeout_sec_ = sec;
>   write_timeout_usec_ = usec;
> }
4845c5021,5023
<   inline void Client::set_keep_alive_max_count(size_t count) { keep_alive_max_count_ = count; }
---
> inline void Client::set_keep_alive_max_count(size_t count) {
>   keep_alive_max_count_ = count;
> }
4847,4850c5025,5028
<   inline void Client::set_basic_auth(const char *username, const char *password) {
<     basic_auth_username_ = username;
<     basic_auth_password_ = password;
<   }
---
> inline void Client::set_basic_auth(const char *username, const char *password) {
>   basic_auth_username_ = username;
>   basic_auth_password_ = password;
> }
4853,4856c5031,5035
<   inline void Client::set_digest_auth(const char *username, const char *password) {
<     digest_auth_username_ = username;
<     digest_auth_password_ = password;
<   }
---
> inline void Client::set_digest_auth(const char *username,
>                                     const char *password) {
>   digest_auth_username_ = username;
>   digest_auth_password_ = password;
> }
4859c5038
<   inline void Client::set_follow_location(bool on) { follow_location_ = on; }
---
> inline void Client::set_follow_location(bool on) { follow_location_ = on; }
4861c5040
<   inline void Client::set_compress(bool on) { compress_ = on; }
---
> inline void Client::set_compress(bool on) { compress_ = on; }
4863c5042
<   inline void Client::set_interface(const char *intf) { interface_ = intf; }
---
> inline void Client::set_decompress(bool on) { decompress_ = on; }
4865,4868c5044
<   inline void Client::set_proxy(const char *host, int port) {
<     proxy_host_ = host;
<     proxy_port_ = port;
<   }
---
> inline void Client::set_interface(const char *intf) { interface_ = intf; }
4870,4873c5046,5055
<   inline void Client::set_proxy_basic_auth(const char *username, const char *password) {
<     proxy_basic_auth_username_ = username;
<     proxy_basic_auth_password_ = password;
<   }
---
> inline void Client::set_proxy(const char *host, int port) {
>   proxy_host_ = host;
>   proxy_port_ = port;
> }
> 
> inline void Client::set_proxy_basic_auth(const char *username,
>                                          const char *password) {
>   proxy_basic_auth_username_ = username;
>   proxy_basic_auth_password_ = password;
> }
4876,4879c5058,5062
<   inline void Client::set_proxy_digest_auth(const char *username, const char *password) {
<     proxy_digest_auth_username_ = username;
<     proxy_digest_auth_password_ = password;
<   }
---
> inline void Client::set_proxy_digest_auth(const char *username,
>                                           const char *password) {
>   proxy_digest_auth_username_ = username;
>   proxy_digest_auth_password_ = password;
> }
4882c5065
<   inline void Client::set_logger(Logger logger) { logger_ = std::move(logger); }
---
> inline void Client::set_logger(Logger logger) { logger_ = std::move(logger); }
4888c5071
<   namespace detail {
---
> namespace detail {
4890,4901c5073,5085
<     template <typename U, typename V, typename T>
<     inline bool process_and_close_socket_ssl(bool is_client_request, socket_t sock, size_t keep_alive_max_count,
<                                              time_t read_timeout_sec, time_t read_timeout_usec, time_t write_timeout_sec,
<                                              time_t write_timeout_usec, SSL_CTX *ctx, std::mutex &ctx_mutex,
<                                              U SSL_connect_or_accept, V setup, T callback) {
<       assert(keep_alive_max_count > 0);
< 
<       SSL *ssl = nullptr;
<       {
<         std::lock_guard<std::mutex> guard(ctx_mutex);
<         ssl = SSL_new(ctx);
<       }
---
> template <typename U, typename V, typename T>
> inline bool process_and_close_socket_ssl(
>     bool is_client_request, socket_t sock, size_t keep_alive_max_count,
>     time_t read_timeout_sec, time_t read_timeout_usec, time_t write_timeout_sec,
>     time_t write_timeout_usec, SSL_CTX *ctx, std::mutex &ctx_mutex,
>     U SSL_connect_or_accept, V setup, T callback) {
>   assert(keep_alive_max_count > 0);
> 
>   SSL *ssl = nullptr;
>   {
>     std::lock_guard<std::mutex> guard(ctx_mutex);
>     ssl = SSL_new(ctx);
>   }
4903,4906c5087,5090
<       if (!ssl) {
<         close_socket(sock);
<         return false;
<       }
---
>   if (!ssl) {
>     close_socket(sock);
>     return false;
>   }
4908,4909c5092,5093
<       auto bio = BIO_new_socket(static_cast<int>(sock), BIO_NOCLOSE);
<       SSL_set_bio(ssl, bio, bio);
---
>   auto bio = BIO_new_socket(static_cast<int>(sock), BIO_NOCLOSE);
>   SSL_set_bio(ssl, bio, bio);
4911,4916c5095,5100
<       if (!setup(ssl)) {
<         SSL_shutdown(ssl);
<         {
<           std::lock_guard<std::mutex> guard(ctx_mutex);
<           SSL_free(ssl);
<         }
---
>   if (!setup(ssl)) {
>     SSL_shutdown(ssl);
>     {
>       std::lock_guard<std::mutex> guard(ctx_mutex);
>       SSL_free(ssl);
>     }
4918,4920c5102,5104
<         close_socket(sock);
<         return false;
<       }
---
>     close_socket(sock);
>     return false;
>   }
4922c5106
<       auto ret = false;
---
>   auto ret = false;
4924,4937c5108,5118
<       if (SSL_connect_or_accept(ssl) == 1) {
<         if (keep_alive_max_count > 1) {
<           auto count = keep_alive_max_count;
<           while (count > 0
<                  && (is_client_request
<                      || select_read(sock, CPPHTTPLIB_KEEPALIVE_TIMEOUT_SECOND, CPPHTTPLIB_KEEPALIVE_TIMEOUT_USECOND) > 0)) {
<             SSLSocketStream strm(sock, ssl, read_timeout_sec, read_timeout_usec, write_timeout_sec, write_timeout_usec);
<             auto last_connection = count == 1;
<             auto connection_close = false;
< 
<             ret = callback(ssl, strm, last_connection, connection_close);
<             if (!ret || connection_close) {
<               break;
<             }
---
>   if (SSL_connect_or_accept(ssl) == 1) {
>     if (keep_alive_max_count > 1) {
>       auto count = keep_alive_max_count;
>       while (count > 0 &&
>              (is_client_request ||
>               select_read(sock, CPPHTTPLIB_KEEPALIVE_TIMEOUT_SECOND,
>                           CPPHTTPLIB_KEEPALIVE_TIMEOUT_USECOND) > 0)) {
>         SSLSocketStream strm(sock, ssl, read_timeout_sec, read_timeout_usec,
>                              write_timeout_sec, write_timeout_usec);
>         auto last_connection = count == 1;
>         auto connection_close = false;
4939,4946c5120,5121
<             count--;
<           }
<         } else {
<           SSLSocketStream strm(sock, ssl, read_timeout_sec, read_timeout_usec, write_timeout_sec, write_timeout_usec);
<           auto dummy_connection_close = false;
<           ret = callback(ssl, strm, true, dummy_connection_close);
<         }
<       }
---
>         ret = callback(ssl, strm, last_connection, connection_close);
>         if (!ret || connection_close) { break; }
4948,4953c5123
<       if (ret) {
<         SSL_shutdown(ssl);  // shutdown only if not already closed by remote
<       }
<       {
<         std::lock_guard<std::mutex> guard(ctx_mutex);
<         SSL_free(ssl);
---
>         count--;
4954a5125,5131
>     } else {
>       SSLSocketStream strm(sock, ssl, read_timeout_sec, read_timeout_usec,
>                            write_timeout_sec, write_timeout_usec);
>       auto dummy_connection_close = false;
>       ret = callback(ssl, strm, true, dummy_connection_close);
>     }
>   }
4956c5133,5139
<       close_socket(sock);
---
>   if (ret) {
>     SSL_shutdown(ssl); // shutdown only if not already closed by remote
>   }
>   {
>     std::lock_guard<std::mutex> guard(ctx_mutex);
>     SSL_free(ssl);
>   }
4958,4959c5141,5144
<       return ret;
<     }
---
>   close_socket(sock);
> 
>   return ret;
> }
4962c5147
<     static std::shared_ptr<std::vector<std::mutex>> openSSL_locks_;
---
> static std::shared_ptr<std::vector<std::mutex>> openSSL_locks_;
4964,4982c5149,5169
<     class SSLThreadLocks {
<      public:
<       SSLThreadLocks() {
<         openSSL_locks_ = std::make_shared<std::vector<std::mutex>>(CRYPTO_num_locks());
<         CRYPTO_set_locking_callback(locking_callback);
<       }
< 
<       ~SSLThreadLocks() { CRYPTO_set_locking_callback(nullptr); }
< 
<      private:
<       static void locking_callback(int mode, int type, const char * /*file*/, int /*line*/) {
<         auto &lk = (*openSSL_locks_)[static_cast<size_t>(type)];
<         if (mode & CRYPTO_LOCK) {
<           lk.lock();
<         } else {
<           lk.unlock();
<         }
<       }
<     };
---
> class SSLThreadLocks {
> public:
>   SSLThreadLocks() {
>     openSSL_locks_ =
>         std::make_shared<std::vector<std::mutex>>(CRYPTO_num_locks());
>     CRYPTO_set_locking_callback(locking_callback);
>   }
> 
>   ~SSLThreadLocks() { CRYPTO_set_locking_callback(nullptr); }
> 
> private:
>   static void locking_callback(int mode, int type, const char * /*file*/,
>                                int /*line*/) {
>     auto &lk = (*openSSL_locks_)[static_cast<size_t>(type)];
>     if (mode & CRYPTO_LOCK) {
>       lk.lock();
>     } else {
>       lk.unlock();
>     }
>   }
> };
4986,4988c5173,5175
<     class SSLInit {
<      public:
<       SSLInit() {
---
> class SSLInit {
> public:
>   SSLInit() {
4990,4991c5177,5178
<         SSL_load_error_strings();
<         SSL_library_init();
---
>     SSL_load_error_strings();
>     SSL_library_init();
4993c5180,5181
<         OPENSSL_init_ssl(OPENSSL_INIT_LOAD_SSL_STRINGS | OPENSSL_INIT_LOAD_CRYPTO_STRINGS, NULL);
---
>     OPENSSL_init_ssl(
>         OPENSSL_INIT_LOAD_SSL_STRINGS | OPENSSL_INIT_LOAD_CRYPTO_STRINGS, NULL);
4995c5183
<       }
---
>   }
4997c5185
<       ~SSLInit() {
---
>   ~SSLInit() {
4999c5187
<         ERR_free_strings();
---
>     ERR_free_strings();
5001c5189
<       }
---
>   }
5003c5191
<      private:
---
> private:
5005c5193
<       SSLThreadLocks thread_init_;
---
>   SSLThreadLocks thread_init_;
5007,5017c5195
<     };
< 
<     // SSL socket stream implementation
<     inline SSLSocketStream::SSLSocketStream(socket_t sock, SSL *ssl, time_t read_timeout_sec, time_t read_timeout_usec,
<                                             time_t write_timeout_sec, time_t write_timeout_usec) :
<         sock_(sock),
<         ssl_(ssl),
<         read_timeout_sec_(read_timeout_sec),
<         read_timeout_usec_(read_timeout_usec),
<         write_timeout_sec_(write_timeout_sec),
<         write_timeout_usec_(write_timeout_usec) {}
---
> };
5019c5197,5206
<     inline SSLSocketStream::~SSLSocketStream() {}
---
> // SSL socket stream implementation
> inline SSLSocketStream::SSLSocketStream(socket_t sock, SSL *ssl,
>                                         time_t read_timeout_sec,
>                                         time_t read_timeout_usec,
>                                         time_t write_timeout_sec,
>                                         time_t write_timeout_usec)
>     : sock_(sock), ssl_(ssl), read_timeout_sec_(read_timeout_sec),
>       read_timeout_usec_(read_timeout_usec),
>       write_timeout_sec_(write_timeout_sec),
>       write_timeout_usec_(write_timeout_usec) {}
5021,5023c5208
<     inline bool SSLSocketStream::is_readable() const {
<       return detail::select_read(sock_, read_timeout_sec_, read_timeout_usec_) > 0;
<     }
---
> inline SSLSocketStream::~SSLSocketStream() {}
5025,5027c5210,5212
<     inline bool SSLSocketStream::is_writable() const {
<       return detail::select_write(sock_, write_timeout_sec_, write_timeout_usec_) > 0;
<     }
---
> inline bool SSLSocketStream::is_readable() const {
>   return detail::select_read(sock_, read_timeout_sec_, read_timeout_usec_) > 0;
> }
5029,5034c5214,5217
<     inline ssize_t SSLSocketStream::read(char *ptr, size_t size) {
<       if (SSL_pending(ssl_) > 0 || select_read(sock_, read_timeout_sec_, read_timeout_usec_) > 0) {
<         return SSL_read(ssl_, ptr, static_cast<int>(size));
<       }
<       return -1;
<     }
---
> inline bool SSLSocketStream::is_writable() const {
>   return detail::select_write(sock_, write_timeout_sec_, write_timeout_usec_) >
>          0;
> }
5036,5041c5219,5225
<     inline ssize_t SSLSocketStream::write(const char *ptr, size_t size) {
<       if (is_writable()) {
<         return SSL_write(ssl_, ptr, static_cast<int>(size));
<       }
<       return -1;
<     }
---
> inline ssize_t SSLSocketStream::read(char *ptr, size_t size) {
>   if (SSL_pending(ssl_) > 0 ||
>       select_read(sock_, read_timeout_sec_, read_timeout_usec_) > 0) {
>     return SSL_read(ssl_, ptr, static_cast<int>(size));
>   }
>   return -1;
> }
5043,5045c5227,5230
<     inline void SSLSocketStream::get_remote_ip_and_port(std::string &ip, int &port) const {
<       detail::get_remote_ip_and_port(sock_, ip, port);
<     }
---
> inline ssize_t SSLSocketStream::write(const char *ptr, size_t size) {
>   if (is_writable()) { return SSL_write(ssl_, ptr, static_cast<int>(size)); }
>   return -1;
> }
5047c5232,5235
<     static SSLInit sslinit_;
---
> inline void SSLSocketStream::get_remote_ip_and_port(std::string &ip,
>                                                     int &port) const {
>   detail::get_remote_ip_and_port(sock_, ip, port);
> }
5049c5237
<   }  // namespace detail
---
> static SSLInit sslinit_;
5051,5054c5239
<   // SSL HTTP server implementation
<   inline SSLServer::SSLServer(const char *cert_path, const char *private_key_path, const char *client_ca_cert_file_path,
<                               const char *client_ca_cert_dir_path) {
<     ctx_ = SSL_CTX_new(SSLv23_server_method());
---
> } // namespace detail
5056,5059c5241,5278
<     if (ctx_) {
<       SSL_CTX_set_options(ctx_,
<                           SSL_OP_ALL | SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 | SSL_OP_NO_COMPRESSION
<                               | SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION);
---
> // SSL HTTP server implementation
> inline SSLServer::SSLServer(const char *cert_path, const char *private_key_path,
>                             const char *client_ca_cert_file_path,
>                             const char *client_ca_cert_dir_path) {
>   ctx_ = SSL_CTX_new(SSLv23_server_method());
> 
>   if (ctx_) {
>     SSL_CTX_set_options(ctx_,
>                         SSL_OP_ALL | SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 |
>                             SSL_OP_NO_COMPRESSION |
>                             SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION);
> 
>     // auto ecdh = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);
>     // SSL_CTX_set_tmp_ecdh(ctx_, ecdh);
>     // EC_KEY_free(ecdh);
> 
>     if (SSL_CTX_use_certificate_chain_file(ctx_, cert_path) != 1 ||
>         SSL_CTX_use_PrivateKey_file(ctx_, private_key_path, SSL_FILETYPE_PEM) !=
>             1) {
>       SSL_CTX_free(ctx_);
>       ctx_ = nullptr;
>     } else if (client_ca_cert_file_path || client_ca_cert_dir_path) {
>       // if (client_ca_cert_file_path) {
>       //   auto list = SSL_load_client_CA_file(client_ca_cert_file_path);
>       //   SSL_CTX_set_client_CA_list(ctx_, list);
>       // }
> 
>       SSL_CTX_load_verify_locations(ctx_, client_ca_cert_file_path,
>                                     client_ca_cert_dir_path);
> 
>       SSL_CTX_set_verify(
>           ctx_,
>           SSL_VERIFY_PEER |
>               SSL_VERIFY_FAIL_IF_NO_PEER_CERT, // SSL_VERIFY_CLIENT_ONCE,
>           nullptr);
>     }
>   }
> }
5061,5063c5280,5288
<       // auto ecdh = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);
<       // SSL_CTX_set_tmp_ecdh(ctx_, ecdh);
<       // EC_KEY_free(ecdh);
---
> inline SSLServer::SSLServer(X509 *cert, EVP_PKEY *private_key,
>                             X509_STORE *client_ca_cert_store) {
>   ctx_ = SSL_CTX_new(SSLv23_server_method());
> 
>   if (ctx_) {
>     SSL_CTX_set_options(ctx_,
>                         SSL_OP_ALL | SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 |
>                             SSL_OP_NO_COMPRESSION |
>                             SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION);
5065,5073c5290,5294
<       if (SSL_CTX_use_certificate_chain_file(ctx_, cert_path) != 1
<           || SSL_CTX_use_PrivateKey_file(ctx_, private_key_path, SSL_FILETYPE_PEM) != 1) {
<         SSL_CTX_free(ctx_);
<         ctx_ = nullptr;
<       } else if (client_ca_cert_file_path || client_ca_cert_dir_path) {
<         // if (client_ca_cert_file_path) {
<         //   auto list = SSL_load_client_CA_file(client_ca_cert_file_path);
<         //   SSL_CTX_set_client_CA_list(ctx_, list);
<         // }
---
>     if (SSL_CTX_use_certificate(ctx_, cert) != 1 ||
>         SSL_CTX_use_PrivateKey(ctx_, private_key) != 1) {
>       SSL_CTX_free(ctx_);
>       ctx_ = nullptr;
>     } else if (client_ca_cert_store) {
5075c5296
<         SSL_CTX_load_verify_locations(ctx_, client_ca_cert_file_path, client_ca_cert_dir_path);
---
>       SSL_CTX_set_cert_store(ctx_, client_ca_cert_store);
5077,5080c5298,5302
<         SSL_CTX_set_verify(ctx_,
<                            SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,  // SSL_VERIFY_CLIENT_ONCE,
<                            nullptr);
<       }
---
>       SSL_CTX_set_verify(
>           ctx_,
>           SSL_VERIFY_PEER |
>               SSL_VERIFY_FAIL_IF_NO_PEER_CERT, // SSL_VERIFY_CLIENT_ONCE,
>           nullptr);
5082a5305
> }
5084,5090c5307,5309
<   inline SSLServer::SSLServer(X509 *cert, EVP_PKEY *private_key, X509_STORE *client_ca_cert_store) {
<     ctx_ = SSL_CTX_new(SSLv23_server_method());
< 
<     if (ctx_) {
<       SSL_CTX_set_options(ctx_,
<                           SSL_OP_ALL | SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 | SSL_OP_NO_COMPRESSION
<                               | SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION);
---
> inline SSLServer::~SSLServer() {
>   if (ctx_) { SSL_CTX_free(ctx_); }
> }
5092,5095c5311
<       if (SSL_CTX_use_certificate(ctx_, cert) != 1 || SSL_CTX_use_PrivateKey(ctx_, private_key) != 1) {
<         SSL_CTX_free(ctx_);
<         ctx_ = nullptr;
<       } else if (client_ca_cert_store) {
---
> inline bool SSLServer::is_valid() const { return ctx_; }
5097c5313,5323
<         SSL_CTX_set_cert_store(ctx_, client_ca_cert_store);
---
> inline bool SSLServer::process_and_close_socket(socket_t sock) {
>   return detail::process_and_close_socket_ssl(
>       false, sock, keep_alive_max_count_, read_timeout_sec_, read_timeout_usec_,
>       write_timeout_sec_, write_timeout_usec_, ctx_, ctx_mutex_, SSL_accept,
>       [](SSL * /*ssl*/) { return true; },
>       [this](SSL *ssl, Stream &strm, bool last_connection,
>              bool &connection_close) {
>         return process_request(strm, last_connection, connection_close,
>                                [&](Request &req) { req.ssl = ssl; });
>       });
> }
5099,5102c5325,5348
<         SSL_CTX_set_verify(ctx_,
<                            SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,  // SSL_VERIFY_CLIENT_ONCE,
<                            nullptr);
<       }
---
> // SSL HTTP client implementation
> inline SSLClient::SSLClient(const std::string &host)
>     : SSLClient(host, 443, std::string(), std::string()) {}
> 
> inline SSLClient::SSLClient(const std::string &host, int port)
>     : SSLClient(host, port, std::string(), std::string()) {}
> 
> inline SSLClient::SSLClient(const std::string &host, int port,
>                             const std::string &client_cert_path,
>                             const std::string &client_key_path)
>     : Client(host, port, client_cert_path, client_key_path) {
>   ctx_ = SSL_CTX_new(SSLv23_client_method());
> 
>   detail::split(&host_[0], &host_[host_.size()], '.',
>                 [&](const char *b, const char *e) {
>                   host_components_.emplace_back(std::string(b, e));
>                 });
>   if (!client_cert_path.empty() && !client_key_path.empty()) {
>     if (SSL_CTX_use_certificate_file(ctx_, client_cert_path.c_str(),
>                                      SSL_FILETYPE_PEM) != 1 ||
>         SSL_CTX_use_PrivateKey_file(ctx_, client_key_path.c_str(),
>                                     SSL_FILETYPE_PEM) != 1) {
>       SSL_CTX_free(ctx_);
>       ctx_ = nullptr;
5104a5351
> }
5106,5107c5353,5364
<   inline SSLServer::~SSLServer() {
<     if (ctx_) {
---
> inline SSLClient::SSLClient(const std::string &host, int port,
>                             X509 *client_cert, EVP_PKEY *client_key)
>     : Client(host, port) {
>   ctx_ = SSL_CTX_new(SSLv23_client_method());
> 
>   detail::split(&host_[0], &host_[host_.size()], '.',
>                 [&](const char *b, const char *e) {
>                   host_components_.emplace_back(std::string(b, e));
>                 });
>   if (client_cert != nullptr && client_key != nullptr) {
>     if (SSL_CTX_use_certificate(ctx_, client_cert) != 1 ||
>         SSL_CTX_use_PrivateKey(ctx_, client_key) != 1) {
5108a5366
>       ctx_ = nullptr;
5110a5369
> }
5112,5142c5371,5373
<   inline bool SSLServer::is_valid() const { return ctx_; }
< 
<   inline bool SSLServer::process_and_close_socket(socket_t sock) {
<     return detail::process_and_close_socket_ssl(
<         false, sock, keep_alive_max_count_, read_timeout_sec_, read_timeout_usec_, write_timeout_sec_, write_timeout_usec_, ctx_,
<         ctx_mutex_, SSL_accept, [](SSL * /*ssl*/) { return true; },
<         [this](SSL *ssl, Stream &strm, bool last_connection, bool &connection_close) {
<           return process_request(strm, last_connection, connection_close, [&](Request &req) { req.ssl = ssl; });
<         });
<   }
< 
<   // SSL HTTP client implementation
<   inline SSLClient::SSLClient(const std::string &host) : SSLClient(host, 443, std::string(), std::string()) {}
< 
<   inline SSLClient::SSLClient(const std::string &host, int port) : SSLClient(host, port, std::string(), std::string()) {}
< 
<   inline SSLClient::SSLClient(const std::string &host, int port, const std::string &client_cert_path,
<                               const std::string &client_key_path) :
<       Client(host, port, client_cert_path, client_key_path) {
<     ctx_ = SSL_CTX_new(SSLv23_client_method());
< 
<     detail::split(&host_[0], &host_[host_.size()], '.',
<                   [&](const char *b, const char *e) { host_components_.emplace_back(std::string(b, e)); });
<     if (!client_cert_path.empty() && !client_key_path.empty()) {
<       if (SSL_CTX_use_certificate_file(ctx_, client_cert_path.c_str(), SSL_FILETYPE_PEM) != 1
<           || SSL_CTX_use_PrivateKey_file(ctx_, client_key_path.c_str(), SSL_FILETYPE_PEM) != 1) {
<         SSL_CTX_free(ctx_);
<         ctx_ = nullptr;
<       }
<     }
<   }
---
> inline SSLClient::~SSLClient() {
>   if (ctx_) { SSL_CTX_free(ctx_); }
> }
5144,5145c5375
<   inline SSLClient::SSLClient(const std::string &host, int port, X509 *client_cert, EVP_PKEY *client_key) : Client(host, port) {
<     ctx_ = SSL_CTX_new(SSLv23_client_method());
---
> inline bool SSLClient::is_valid() const { return ctx_; }
5147,5155c5377,5381
<     detail::split(&host_[0], &host_[host_.size()], '.',
<                   [&](const char *b, const char *e) { host_components_.emplace_back(std::string(b, e)); });
<     if (client_cert != nullptr && client_key != nullptr) {
<       if (SSL_CTX_use_certificate(ctx_, client_cert) != 1 || SSL_CTX_use_PrivateKey(ctx_, client_key) != 1) {
<         SSL_CTX_free(ctx_);
<         ctx_ = nullptr;
<       }
<     }
<   }
---
> inline void SSLClient::set_ca_cert_path(const char *ca_cert_file_path,
>                                         const char *ca_cert_dir_path) {
>   if (ca_cert_file_path) { ca_cert_file_path_ = ca_cert_file_path; }
>   if (ca_cert_dir_path) { ca_cert_dir_path_ = ca_cert_dir_path; }
> }
5157,5161c5383,5385
<   inline SSLClient::~SSLClient() {
<     if (ctx_) {
<       SSL_CTX_free(ctx_);
<     }
<   }
---
> inline void SSLClient::set_ca_cert_store(X509_STORE *ca_cert_store) {
>   if (ca_cert_store) { ca_cert_store_ = ca_cert_store; }
> }
5163c5387,5389
<   inline bool SSLClient::is_valid() const { return ctx_; }
---
> inline void SSLClient::enable_server_certificate_verification(bool enabled) {
>   server_certificate_verification_ = enabled;
> }
5165,5172c5391,5393
<   inline void SSLClient::set_ca_cert_path(const char *ca_cert_file_path, const char *ca_cert_dir_path) {
<     if (ca_cert_file_path) {
<       ca_cert_file_path_ = ca_cert_file_path;
<     }
<     if (ca_cert_dir_path) {
<       ca_cert_dir_path_ = ca_cert_dir_path;
<     }
<   }
---
> inline long SSLClient::get_openssl_verify_result() const {
>   return verify_result_;
> }
5174,5178c5395
<   inline void SSLClient::set_ca_cert_store(X509_STORE *ca_cert_store) {
<     if (ca_cert_store) {
<       ca_cert_store_ = ca_cert_store;
<     }
<   }
---
> inline SSL_CTX *SSLClient::ssl_context() const { return ctx_; }
5180c5397,5423
<   inline void SSLClient::enable_server_certificate_verification(bool enabled) { server_certificate_verification_ = enabled; }
---
> inline bool SSLClient::process_and_close_socket(
>     socket_t sock, size_t request_count,
>     std::function<bool(Stream &strm, bool last_connection,
>                        bool &connection_close)>
>         callback) {
> 
>   request_count = std::min(request_count, keep_alive_max_count_);
> 
>   return is_valid() &&
>          detail::process_and_close_socket_ssl(
>              true, sock, request_count, read_timeout_sec_, read_timeout_usec_,
>              write_timeout_sec_, write_timeout_usec_, ctx_, ctx_mutex_,
>              [&](SSL *ssl) {
>                if (ca_cert_file_path_.empty() && ca_cert_store_ == nullptr) {
>                  SSL_CTX_set_verify(ctx_, SSL_VERIFY_NONE, nullptr);
>                } else if (!ca_cert_file_path_.empty()) {
>                  if (!SSL_CTX_load_verify_locations(
>                          ctx_, ca_cert_file_path_.c_str(), nullptr)) {
>                    return false;
>                  }
>                  SSL_CTX_set_verify(ctx_, SSL_VERIFY_PEER, nullptr);
>                } else if (ca_cert_store_ != nullptr) {
>                  if (SSL_CTX_get_cert_store(ctx_) != ca_cert_store_) {
>                    SSL_CTX_set_cert_store(ctx_, ca_cert_store_);
>                  }
>                  SSL_CTX_set_verify(ctx_, SSL_VERIFY_PEER, nullptr);
>                }
5182c5425
<   inline long SSLClient::get_openssl_verify_result() const { return verify_result_; }
---
>                if (SSL_connect(ssl) != 1) { return false; }
5184c5427,5428
<   inline SSL_CTX *SSLClient::ssl_context() const { return ctx_; }
---
>                if (server_certificate_verification_) {
>                  verify_result_ = SSL_get_verify_result(ssl);
5186,5188c5430
<   inline bool
<   SSLClient::process_and_close_socket(socket_t sock, size_t request_count,
<                                       std::function<bool(Stream &strm, bool last_connection, bool &connection_close)> callback) {
---
>                  if (verify_result_ != X509_V_OK) { return false; }
5190c5432
<     request_count = std::min(request_count, keep_alive_max_count_);
---
>                  auto server_cert = SSL_get_peer_certificate(ssl);
5192,5209c5434
<     return is_valid()
<         && detail::process_and_close_socket_ssl(
<                true, sock, request_count, read_timeout_sec_, read_timeout_usec_, write_timeout_sec_, write_timeout_usec_, ctx_,
<                ctx_mutex_,
<                [&](SSL *ssl) {
<                  if (ca_cert_file_path_.empty() && ca_cert_store_ == nullptr) {
<                    SSL_CTX_set_verify(ctx_, SSL_VERIFY_NONE, nullptr);
<                  } else if (!ca_cert_file_path_.empty()) {
<                    if (!SSL_CTX_load_verify_locations(ctx_, ca_cert_file_path_.c_str(), nullptr)) {
<                      return false;
<                    }
<                    SSL_CTX_set_verify(ctx_, SSL_VERIFY_PEER, nullptr);
<                  } else if (ca_cert_store_ != nullptr) {
<                    if (SSL_CTX_get_cert_store(ctx_) != ca_cert_store_) {
<                      SSL_CTX_set_cert_store(ctx_, ca_cert_store_);
<                    }
<                    SSL_CTX_set_verify(ctx_, SSL_VERIFY_PEER, nullptr);
<                  }
---
>                  if (server_cert == nullptr) { return false; }
5211c5436,5437
<                  if (SSL_connect(ssl) != 1) {
---
>                  if (!verify_host(server_cert)) {
>                    X509_free(server_cert);
5213a5440,5441
>                  X509_free(server_cert);
>                }
5215,5216c5443,5453
<                  if (server_certificate_verification_) {
<                    verify_result_ = SSL_get_verify_result(ssl);
---
>                return true;
>              },
>              [&](SSL *ssl) {
>                SSL_set_tlsext_host_name(ssl, host_.c_str());
>                return true;
>              },
>              [&](SSL * /*ssl*/, Stream &strm, bool last_connection,
>                  bool &connection_close) {
>                return callback(strm, last_connection, connection_close);
>              });
> }
5218,5233c5455,5481
<                    if (verify_result_ != X509_V_OK) {
<                      return false;
<                    }
< 
<                    auto server_cert = SSL_get_peer_certificate(ssl);
< 
<                    if (server_cert == nullptr) {
<                      return false;
<                    }
< 
<                    if (!verify_host(server_cert)) {
<                      X509_free(server_cert);
<                      return false;
<                    }
<                    X509_free(server_cert);
<                  }
---
> inline bool SSLClient::is_ssl() const { return true; }
> 
> inline bool SSLClient::verify_host(X509 *server_cert) const {
>   /* Quote from RFC2818 section 3.1 "Server Identity"
> 
>      If a subjectAltName extension of type dNSName is present, that MUST
>      be used as the identity. Otherwise, the (most specific) Common Name
>      field in the Subject field of the certificate MUST be used. Although
>      the use of the Common Name is existing practice, it is deprecated and
>      Certification Authorities are encouraged to use the dNSName instead.
> 
>      Matching is performed using the matching rules specified by
>      [RFC2459].  If more than one identity of a given type is present in
>      the certificate (e.g., more than one dNSName name, a match in any one
>      of the set is considered acceptable.) Names may contain the wildcard
>      character * which is considered to match any single domain name
>      component or component fragment. E.g., *.a.com matches foo.a.com but
>      not bar.foo.a.com. f*.com matches foo.com but not bar.com.
> 
>      In some cases, the URI is specified as an IP address rather than a
>      hostname. In this case, the iPAddress subjectAltName must be present
>      in the certificate and must exactly match the IP in the URI.
> 
>   */
>   return verify_host_with_subject_alt_name(server_cert) ||
>          verify_host_with_common_name(server_cert);
> }
5235,5280c5483,5491
<                  return true;
<                },
<                [&](SSL *ssl) {
<                  SSL_set_tlsext_host_name(ssl, host_.c_str());
<                  return true;
<                },
<                [&](SSL * /*ssl*/, Stream &strm, bool last_connection, bool &connection_close) {
<                  return callback(strm, last_connection, connection_close);
<                });
<   }
< 
<   inline bool SSLClient::is_ssl() const { return true; }
< 
<   inline bool SSLClient::verify_host(X509 *server_cert) const {
<     /* Quote from RFC2818 section 3.1 "Server Identity"
< 
<        If a subjectAltName extension of type dNSName is present, that MUST
<        be used as the identity. Otherwise, the (most specific) Common Name
<        field in the Subject field of the certificate MUST be used. Although
<        the use of the Common Name is existing practice, it is deprecated and
<        Certification Authorities are encouraged to use the dNSName instead.
< 
<        Matching is performed using the matching rules specified by
<        [RFC2459].  If more than one identity of a given type is present in
<        the certificate (e.g., more than one dNSName name, a match in any one
<        of the set is considered acceptable.) Names may contain the wildcard
<        character * which is considered to match any single domain name
<        component or component fragment. E.g., *.a.com matches foo.a.com but
<        not bar.foo.a.com. f*.com matches foo.com but not bar.com.
< 
<        In some cases, the URI is specified as an IP address rather than a
<        hostname. In this case, the iPAddress subjectAltName must be present
<        in the certificate and must exactly match the IP in the URI.
< 
<     */
<     return verify_host_with_subject_alt_name(server_cert) || verify_host_with_common_name(server_cert);
<   }
< 
<   inline bool SSLClient::verify_host_with_subject_alt_name(X509 *server_cert) const {
<     auto ret = false;
< 
<     auto type = GEN_DNS;
< 
<     struct in6_addr addr6;
<     struct in_addr addr;
<     size_t addr_len = 0;
---
> inline bool
> SSLClient::verify_host_with_subject_alt_name(X509 *server_cert) const {
>   auto ret = false;
> 
>   auto type = GEN_DNS;
> 
>   struct in6_addr addr6;
>   struct in_addr addr;
>   size_t addr_len = 0;
5283,5289c5494,5500
<     if (inet_pton(AF_INET6, host_.c_str(), &addr6)) {
<       type = GEN_IPADD;
<       addr_len = sizeof(struct in6_addr);
<     } else if (inet_pton(AF_INET, host_.c_str(), &addr)) {
<       type = GEN_IPADD;
<       addr_len = sizeof(struct in_addr);
<     }
---
>   if (inet_pton(AF_INET6, host_.c_str(), &addr6)) {
>     type = GEN_IPADD;
>     addr_len = sizeof(struct in6_addr);
>   } else if (inet_pton(AF_INET, host_.c_str(), &addr)) {
>     type = GEN_IPADD;
>     addr_len = sizeof(struct in_addr);
>   }
5292,5317c5503,5525
<     auto alt_names = static_cast<const struct stack_st_GENERAL_NAME *>(
<         X509_get_ext_d2i(server_cert, NID_subject_alt_name, nullptr, nullptr));
< 
<     if (alt_names) {
<       auto dsn_matched = false;
<       auto ip_mached = false;
< 
<       auto count = sk_GENERAL_NAME_num(alt_names);
< 
<       for (auto i = 0; i < count && !dsn_matched; i++) {
<         auto val = sk_GENERAL_NAME_value(alt_names, i);
<         if (val->type == type) {
<           auto name = (const char *)ASN1_STRING_get0_data(val->d.ia5);
<           auto name_len = (size_t)ASN1_STRING_length(val->d.ia5);
< 
<           if (strlen(name) == name_len) {
<             switch (type) {
<               case GEN_DNS:
<                 dsn_matched = check_host_name(name, name_len);
<                 break;
< 
<               case GEN_IPADD:
<                 if (!memcmp(&addr6, name, addr_len) || !memcmp(&addr, name, addr_len)) {
<                   ip_mached = true;
<                 }
<                 break;
---
>   auto alt_names = static_cast<const struct stack_st_GENERAL_NAME *>(
>       X509_get_ext_d2i(server_cert, NID_subject_alt_name, nullptr, nullptr));
> 
>   if (alt_names) {
>     auto dsn_matched = false;
>     auto ip_mached = false;
> 
>     auto count = sk_GENERAL_NAME_num(alt_names);
> 
>     for (auto i = 0; i < count && !dsn_matched; i++) {
>       auto val = sk_GENERAL_NAME_value(alt_names, i);
>       if (val->type == type) {
>         auto name = (const char *)ASN1_STRING_get0_data(val->d.ia5);
>         auto name_len = (size_t)ASN1_STRING_length(val->d.ia5);
> 
>         if (strlen(name) == name_len) {
>           switch (type) {
>           case GEN_DNS: dsn_matched = check_host_name(name, name_len); break;
> 
>           case GEN_IPADD:
>             if (!memcmp(&addr6, name, addr_len) ||
>                 !memcmp(&addr, name, addr_len)) {
>               ip_mached = true;
5318a5527
>             break;
5322,5325d5530
< 
<       if (dsn_matched || ip_mached) {
<         ret = true;
<       }
5328,5330c5533
<     GENERAL_NAMES_free((STACK_OF(GENERAL_NAME) *)alt_names);
< 
<     return ret;
---
>     if (dsn_matched || ip_mached) { ret = true; }
5333,5334c5536
<   inline bool SSLClient::verify_host_with_common_name(X509 *server_cert) const {
<     const auto subject_name = X509_get_subject_name(server_cert);
---
>   GENERAL_NAMES_free((STACK_OF(GENERAL_NAME) *)alt_names);
5336,5338c5538,5539
<     if (subject_name != nullptr) {
<       char name[BUFSIZ];
<       auto name_len = X509_NAME_get_text_by_NID(subject_name, NID_commonName, name, sizeof(name));
---
>   return ret;
> }
5340,5343c5541,5542
<       if (name_len != -1) {
<         return check_host_name(name, static_cast<size_t>(name_len));
<       }
<     }
---
> inline bool SSLClient::verify_host_with_common_name(X509 *server_cert) const {
>   const auto subject_name = X509_get_subject_name(server_cert);
5345,5346c5544,5547
<     return false;
<   }
---
>   if (subject_name != nullptr) {
>     char name[BUFSIZ];
>     auto name_len = X509_NAME_get_text_by_NID(subject_name, NID_commonName,
>                                               name, sizeof(name));
5348,5350c5549,5550
<   inline bool SSLClient::check_host_name(const char *pattern, size_t pattern_len) const {
<     if (host_.size() == pattern_len && host_ == pattern) {
<       return true;
---
>     if (name_len != -1) {
>       return check_host_name(name, static_cast<size_t>(name_len));
5351a5552
>   }
5353,5361c5554,5555
<     // Wildcard match
<     // https://bugs.launchpad.net/ubuntu/+source/firefox-3.0/+bug/376484
<     std::vector<std::string> pattern_components;
<     detail::split(&pattern[0], &pattern[pattern_len], '.',
<                   [&](const char *b, const char *e) { pattern_components.emplace_back(std::string(b, e)); });
< 
<     if (host_components_.size() != pattern_components.size()) {
<       return false;
<     }
---
>   return false;
> }
5363,5372c5557,5577
<     auto itr = pattern_components.begin();
<     for (const auto &h : host_components_) {
<       auto &p = *itr;
<       if (p != h && p != "*") {
<         auto partial_match = (p.size() > 0 && p[p.size() - 1] == '*' && !p.compare(0, p.size() - 1, h));
<         if (!partial_match) {
<           return false;
<         }
<       }
<       ++itr;
---
> inline bool SSLClient::check_host_name(const char *pattern,
>                                        size_t pattern_len) const {
>   if (host_.size() == pattern_len && host_ == pattern) { return true; }
> 
>   // Wildcard match
>   // https://bugs.launchpad.net/ubuntu/+source/firefox-3.0/+bug/376484
>   std::vector<std::string> pattern_components;
>   detail::split(&pattern[0], &pattern[pattern_len], '.',
>                 [&](const char *b, const char *e) {
>                   pattern_components.emplace_back(std::string(b, e));
>                 });
> 
>   if (host_components_.size() != pattern_components.size()) { return false; }
> 
>   auto itr = pattern_components.begin();
>   for (const auto &h : host_components_) {
>     auto &p = *itr;
>     if (p != h && p != "*") {
>       auto partial_match = (p.size() > 0 && p[p.size() - 1] == '*' &&
>                             !p.compare(0, p.size() - 1, h));
>       if (!partial_match) { return false; }
5374,5375c5579
< 
<     return true;
---
>     ++itr;
5376a5581,5583
> 
>   return true;
> }
5379c5586
<   namespace detail {
---
> namespace detail {
5383c5590
<   }  // namespace detail
---
> } // namespace detail
5385c5592
<   // ----------------------------------------------------------------------------
---
> // ----------------------------------------------------------------------------
5387c5594
< }  // namespace httplib
---
> } // namespace httplib
